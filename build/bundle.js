/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	window.Tone = __webpack_require__(3);

	var widgets = __webpack_require__(1);
	var synth = __webpack_require__(2);
	var nexus = __webpack_require__(4);

	// Copy all widgets functions to the global scope
	Object.keys(widgets).forEach(function (key) {
	  window[key] = widgets[key];
	});

	Object.keys(synth).forEach(function (key) {
	  window[key] = synth[key];
	});

	Tone.Transport.start();


	window.setBPM = function(bpm) {
	  Tone.Transport.bpm.value = bpm;
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* global nx, Tone, module, require */

	var musical = __webpack_require__(5);
	var _ = __webpack_require__(6);
	var eventEmitter = __webpack_require__(7);
	var midiToNote = musical.midiToNote,
	  noteToMidi = musical.noteToMidi;

	var widgetIdsByType = {};


	function createWidgetId(type) {
	  var lastId = widgetIdsByType[type] || 0;
	  var newId = lastId + 1;
	  widgetIdsByType[type] = newId;
	  return type + String(newId);
	}

	var STYLE_ATTRIBUTES = {
	  'top': true,
	  'left': true,
	  'width': true,
	  'height': true,
	};


	function nxColorAttribute(colorName) {
	  return {
	    getter: function (widget) {
	      return widget._nxWidget.colors[colorName];
	    },
	    setter: function (widget, value) {
	      widget._nxWidget.colors[colorName] = value;
	      widget._nxWidget.init();
	    }
	  };
	}

	var enabledAttribute = {
	  valueType: Boolean,
	  defaultValue: true,
	  getter: function (widget) {
	    return widget._data.enabled;
	  },
	  setter: function (widget, value) {
	    var containerElement = widget._containerElement;
	    value = !!value;
	    widget._data.enabled = value;
	    containerElement.style.pointerEvents = value ? '' : 'none';
	    // TODO: Disabled due to a problem
	    containerElement.style.opacity = value ? 1 : 1;
	  }
	};

	function nxAttribute(attributeName) {
	  return {
	    getter: function (widget) {
	      return widget._nxWidget[attributeName];
	    },
	    setter: function (widget, value) {
	      widget._nxWidget[attributeName] = value;
	      widget._nxWidget.init();
	    }
	  };
	}

	function nxSetter(attributeName, setFunctonName) {
	  return {
	    getter: function (widget) {
	      return widget._nxWidget[attributeName];
	    },
	    setter: function (widget, value) {
	      widget._nxWidget[setFunctonName](value);
	    }
	  };
	}

	function nxValue(attributeName) {
	  return {
	    getter: function (widget) {
	      return widget._nxWidget.val[attributeName];
	    },
	    setter: function (widget, value) {
	      widget._nxWidget.val[attributeName] = value;
	      widget._nxWidget.init();
	    }
	  };
	}

	function dataAttribute(valueType, defaultValue, attributeName) {
	  return {
	    getter: function (widget) {
	      return widget._data[attributeName];
	    },
	    setter: function (widget, value) {
	      widget._data[attributeName] = value;
	    },
	    defaultValue: defaultValue,
	    valueType: valueType
	  };
	}

	var WIDGET_DEFS = {

	  'keyboard': {
	    nxType: 'keyboard',
	    events: ['onPress', 'onRelease'],
	    attributes: {
	      'octaves': nxAttribute('octaves'),
	      'startNote': {
	        getter: function (widget) {
	          return midiToNote(widget._nxWidget.midibase);
	        },
	        setter: function (widget, value) {
	          widget._nxWidget.midibase = noteToMidi(value);
	          widget._nxWidget.init();
	        },
	      }
	    },
	    nxEventRoute: function (widget, emitter, data) {
	      if (data.on === 0) {
	        emitter.emit('onRelease', midiToNote(data['note']));
	      } else {
	        emitter.emit('onPress', midiToNote(data['note']));
	      }
	    },
	  },

	  'button': {
	    nxType: 'button',
	    events: ['onPress', 'onRelease'],
	    attributes: {},

	    methods: {
	      'press': {
	        func: function (widget) {

	          widget._nxWidget.set({
	            'press': 1
	          }, true);
	        }
	      },
	      'release': {
	        func: function (widget) {
	          widget._nxWidget.set({
	            'press': 0
	          });
	        }
	      },
	      'pressRelease': {
	        func: function (widget, time) {
	          time = time || 0.25;
	          widget.press();
	          setTimeout(_.partial(widget.release, widget), time * 1000);
	        }
	      },
	    },

	    nxEventRoute: function (widget, emitter, data) {
	      if (data.press === 0) {
	        emitter.emit('onRelease');
	      } else {
	        emitter.emit('onPress');
	      }
	    },
	  },

	  'label': {
	    nxType: 'comment',
	    attributes: {
	      'text': nxValue('text'),
	      'size': nxSetter('size', 'setSize')
	    }
	  },

	  'matrix': {
	    nxType: 'matrix',
	    attributes: {
	      cols: nxAttribute('col'),
	      rows: nxAttribute('row'),
	      place: nxAttribute('place'),
	      matrix: nxAttribute('matrix')
	    }
	  },

	  'metronome': {
	    nxType: 'button',
	    events: ['onTick', 'onEnd'],
	    attributes: {
	      interval: dataAttribute('interval', '4n', 'interval'),
	    },
	    init: function (widget) {

	      widget.start = function (options) {
	        var BUTTON_CLICK_TIME = 100;

	        options = options || {};
	        var ticks = options.ticks || null;
	        var wait = options.wait || 0;
	        if (widget._interval) {
	          widget.stop();
	        }
	        var interval = widget.interval || '4n';
	        var tickIndex = 0;

	        var scheduleTransport = function () {
	          widget._interval = Tone.Transport.setInterval(function (time) {

	            widget._emitter.emit('onTick', time, tickIndex);
	            tickIndex++;
	            widget._nxWidget.val.press = 1;
	            widget._nxWidget.draw();
	            window.setTimeout(function () {
	              widget._nxWidget.val.press = 0;
	              widget._nxWidget.draw();
	            }, BUTTON_CLICK_TIME);
	            if (tickIndex === ticks) {
	              widget.stop();
	              widget._emitter.emit('onEnd');
	              return;
	            }



	          }, interval);
	        };

	        if (!wait) {
	          scheduleTransport();
	        } else {
	          setTimeout(scheduleTransport, wait * 1000);
	        }




	      };

	      widget.stop = function () {
	        Tone.Transport.clearInterval(widget._interval);
	      };
	    }
	  },
	};

	// Extend defs with some common attributes
	Object.keys(WIDGET_DEFS).forEach(function (key) {
	  var def = WIDGET_DEFS[key];

	  def.attributes.enabled = enabledAttribute;

	  if (def.nxType) {
	    //“accent”, “fill”, “border”, “black”, and “white”)
	    ['accent', 'fill', 'border', 'black', 'white'].forEach(function(color) {
	      def.attributes[color+'Color'] = nxColorAttribute(color);
	    });
	  }

	});


	function createWidget(type, attributes) {
	  var widgetDef = WIDGET_DEFS[type];
	  if (!widgetDef) {
	    throw new Error('No widget type defined: ' + type);
	  }

	  var widget = {
	    _data: {},
	    _nxWidget: undefined
	  };
	  var emitter = eventEmitter({});

	  widget._emitter = emitter;


	  var containerElement = document.createElement('div');
	  widget._containerElement = containerElement;
	  containerElement.className = "widgetContainer";
	  window.document.body.appendChild(containerElement);

	  // Create style attributes as getter and setter with nx widget initialization
	  Object.keys(STYLE_ATTRIBUTES).forEach(function (attribute) {
	    Object.defineProperty(widget, attribute, {
	      get: function () {
	        return containerElement.style[attribute];
	      },
	      set: function (value) {
	        containerElement.style[attribute] = value;
	        // nx widget needs to be resized if the container element is resized
	        if (widget._nxWidget) {
	          containerElement.style[attribute] = value;
	          var width = Number(window.getComputedStyle(containerElement, null).getPropertyValue('width').slice(0, -2));
	          var height = Number(window.getComputedStyle(containerElement, null).getPropertyValue('height').slice(0, -2));
	          widget._nxWidget.resize(width, height);
	        }

	      }
	    });

	    // Canvas properties should be set in advance for nexusosc to work
	    if (attributes[attribute]) {
	      containerElement.style[attribute] = attributes[attribute];
	    }
	  });


	  if (widgetDef.nxType) {
	    var element = document.createElement('canvas');
	    element.id = createWidgetId(type);
	    element.className = 'widget';
	    element.style.width = '100%';
	    element.style.height = '100%';

	    element.id = createWidgetId(type);
	    element.className = 'widget';
	    containerElement.appendChild(element);

	    var nxWidget = nx.transform(element, widgetDef.nxType);
	    widget._nxWidget = nxWidget;


	    if (widgetDef.nxEventRoute) {
	      nxWidget.on('*', function (data) {
	        widgetDef.nxEventRoute(widget, emitter, data);
	      });
	    }

	    nxWidget.init();
	  }

	  // Create  attributes as getters and setters
	  Object.keys(widgetDef.attributes).forEach(function (attribute) {
	    var attributeSettings = widgetDef.attributes[attribute];
	    var getter = _.partial(attributeSettings.getter, widget);
	    var setter = _.partial(attributeSettings.setter, widget);

	    Object.defineProperty(widget, attribute, {
	      get: getter,
	      set: setter
	    });

	    if (attributeSettings.hasOwnProperty('defaultValue')) {
	      widget[attribute] = attributeSettings.defaultValue;
	    }
	  });

	  if (widgetDef.init) {
	    widgetDef.init(widget);
	  }

	  if (widgetDef.events) {
	    widgetDef.events.forEach(function (eventName) {
	      // TODO: use currying (using lodash?) to make this clearer, since we're only proxying the emitter function
	      widget[eventName] = function (listener) {
	        emitter.on(eventName, listener);
	      };
	    });
	  }

	  if (widgetDef.methods) {
	    Object.keys(widgetDef.methods).forEach(function (methodName) {
	      var functionDef = widgetDef.methods[methodName];
	      widget[methodName] = _.partial(functionDef.func, widget);
	    });
	  }

	  // Apply the passed attributes to the widget
	  Object.keys(attributes).forEach(function (attribute) {
	    if (!widget.hasOwnProperty(attribute)) {
	      throw new Error('widget ' + type + ' does not have attribute ' + attribute);
	    }
	    // skip style attributes, since they are already created
	    if (STYLE_ATTRIBUTES[attribute]) {
	      return;
	    }

	    widget[attribute] = attributes[attribute];
	  });


	  // Route nx event to the router function of the widget

	  return widget;
	}


	module.exports = {
	  createWidget: createWidget
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* global Tone, module */

	function createSimpleSynth(attributes) {
	  var synth = new Tone.SimpleSynth();
	  synth.chain(Tone.Master);
	  return synth;
	}

	module.exports = {
	  createSimpleSynth: createSimpleSynth
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root) {
		"use strict";
		var Tone;
		//constructs the main Tone object
		function Main(func){
			Tone = func();
		}
		//invokes each of the modules with the main Tone object as the argument
		function Module(func){
			func(Tone);
		}
		/**
		 *  Tone.js
		 *  @author Yotam Mann
		 *  @license http://opensource.org/licenses/MIT MIT License
		 *  @copyright 2014-2015 Yotam Mann
		 */
		Main(function () {
		    
		    //////////////////////////////////////////////////////////////////////////
		    //	WEB AUDIO CONTEXT
		    ///////////////////////////////////////////////////////////////////////////
		    //borrowed from underscore.js
		    function isUndef(val) {
		        return val === void 0;
		    }
		    //borrowed from underscore.js
		    function isFunction(val) {
		        return typeof val === 'function';
		    }
		    var audioContext;
		    //polyfill for AudioContext and OfflineAudioContext
		    if (isUndef(window.AudioContext)) {
		        window.AudioContext = window.webkitAudioContext;
		    }
		    if (isUndef(window.OfflineAudioContext)) {
		        window.OfflineAudioContext = window.webkitOfflineAudioContext;
		    }
		    if (!isUndef(AudioContext)) {
		        audioContext = new AudioContext();
		    } else {
		        throw new Error('Web Audio is not supported in this browser');
		    }
		    //SHIMS////////////////////////////////////////////////////////////////////
		    if (!isFunction(AudioContext.prototype.createGain)) {
		        AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;
		    }
		    if (!isFunction(AudioContext.prototype.createDelay)) {
		        AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;
		    }
		    if (!isFunction(AudioContext.prototype.createPeriodicWave)) {
		        AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;
		    }
		    if (!isFunction(AudioBufferSourceNode.prototype.start)) {
		        AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn;
		    }
		    if (!isFunction(AudioBufferSourceNode.prototype.stop)) {
		        AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff;
		    }
		    if (!isFunction(OscillatorNode.prototype.start)) {
		        OscillatorNode.prototype.start = OscillatorNode.prototype.noteOn;
		    }
		    if (!isFunction(OscillatorNode.prototype.stop)) {
		        OscillatorNode.prototype.stop = OscillatorNode.prototype.noteOff;
		    }
		    if (!isFunction(OscillatorNode.prototype.setPeriodicWave)) {
		        OscillatorNode.prototype.setPeriodicWave = OscillatorNode.prototype.setWaveTable;
		    }
		    //extend the connect function to include Tones
		    AudioNode.prototype._nativeConnect = AudioNode.prototype.connect;
		    AudioNode.prototype.connect = function (B, outNum, inNum) {
		        if (B.input) {
		            if (Array.isArray(B.input)) {
		                if (isUndef(inNum)) {
		                    inNum = 0;
		                }
		                this.connect(B.input[inNum]);
		            } else {
		                this.connect(B.input, outNum, inNum);
		            }
		        } else {
		            try {
		                if (B instanceof AudioNode) {
		                    this._nativeConnect(B, outNum, inNum);
		                } else {
		                    this._nativeConnect(B, outNum);
		                }
		            } catch (e) {
		                throw new Error('error connecting to node: ' + B);
		            }
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	TONE
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  @class  Tone is the base class of all other classes. It provides 
			 *          a lot of methods and functionality to all classes that extend
			 *          it. 
			 *  
			 *  @constructor
			 *  @alias Tone
			 *  @param {number} [inputs=1] the number of input nodes
			 *  @param {number} [outputs=1] the number of output nodes
			 */
		    var Tone = function (inputs, outputs) {
		        /**
				 *  the input node(s)
				 *  @type {GainNode|Array}
				 */
		        if (isUndef(inputs) || inputs === 1) {
		            this.input = this.context.createGain();
		        } else if (inputs > 1) {
		            this.input = new Array(inputs);
		        }
		        /**
				 *  the output node(s)
				 *  @type {GainNode|Array}
				 */
		        if (isUndef(outputs) || outputs === 1) {
		            this.output = this.context.createGain();
		        } else if (outputs > 1) {
		            this.output = new Array(inputs);
		        }
		    };
		    /**
			 *  Set the parameters at once. Either pass in an
			 *  object mapping parameters to values, or to set a
			 *  single parameter, by passing in a string and value.
			 *  The last argument is an optional ramp time which 
			 *  will ramp any signal values to their destination value
			 *  over the duration of the rampTime.
			 *  @param {Object|string} params
			 *  @param {number=} value
			 *  @param {Time=} rampTime
			 *  @returns {Tone} this
			 *  @example
			 * //set values using an object
			 * filter.set({
			 * 	"frequency" : 300,
			 * 	"type" : highpass
			 * });
			 *  @example
			 * filter.set("type", "highpass");
			 *  @example
			 * //ramp to the value 220 over 3 seconds. 
			 * oscillator.set({
			 * 	"frequency" : 220
			 * }, 3);
			 */
		    Tone.prototype.set = function (params, value, rampTime) {
		        if (typeof params === 'object') {
		            rampTime = value;
		        } else if (typeof params === 'string') {
		            var tmpObj = {};
		            tmpObj[params] = value;
		            params = tmpObj;
		        }
		        for (var attr in params) {
		            value = params[attr];
		            var parent = this;
		            if (attr.indexOf('.') !== -1) {
		                var attrSplit = attr.split('.');
		                for (var i = 0; i < attrSplit.length - 1; i++) {
		                    parent = parent[attrSplit[i]];
		                }
		                attr = attrSplit[attrSplit.length - 1];
		            }
		            var param = parent[attr];
		            if (isUndef(param)) {
		                continue;
		            }
		            if (param instanceof Tone.Signal) {
		                if (param.value !== value) {
		                    if (isUndef(rampTime)) {
		                        param.value = value;
		                    } else {
		                        param.rampTo(value, rampTime);
		                    }
		                }
		            } else if (param instanceof AudioParam) {
		                if (param.value !== value) {
		                    param.value = value;
		                }
		            } else if (param instanceof Tone) {
		                param.set(value);
		            } else if (param !== value) {
		                parent[attr] = value;
		            }
		        }
		        return this;
		    };
		    /**
			 *  Get the object's attributes. Given no arguments get
			 *  will return all available object properties and their corresponding
			 *  values. Pass in a single attribute to retrieve or an array
			 *  of attributes. The attribute strings can also include a "."
			 *  to access deeper properties.
			 *  @example
			 * osc.get();
			 * //returns {"type" : "sine", "frequency" : 440, ...etc}
			 *  @example
			 * osc.get("type");
			 * //returns { "type" : "sine"}
			 * @example
			 * //use dot notation to access deep properties
			 * synth.get(["envelope.attack", "envelope.release"]);
			 * //returns {"envelope" : {"attack" : 0.2, "release" : 0.4}}
			 *  @param {Array=|string|undefined} params the parameters to get, otherwise will return 
			 *  					                  all available.
			 *  @returns {Object}
			 */
		    Tone.prototype.get = function (params) {
		        if (isUndef(params)) {
		            params = this._collectDefaults(this.constructor);
		        } else if (typeof params === 'string') {
		            params = [params];
		        }
		        var ret = {};
		        for (var i = 0; i < params.length; i++) {
		            var attr = params[i];
		            var parent = this;
		            var subRet = ret;
		            if (attr.indexOf('.') !== -1) {
		                var attrSplit = attr.split('.');
		                for (var j = 0; j < attrSplit.length - 1; j++) {
		                    var subAttr = attrSplit[j];
		                    subRet[subAttr] = subRet[subAttr] || {};
		                    subRet = subRet[subAttr];
		                    parent = parent[subAttr];
		                }
		                attr = attrSplit[attrSplit.length - 1];
		            }
		            var param = parent[attr];
		            if (typeof params[attr] === 'object') {
		                subRet[attr] = param.get();
		            } else if (param instanceof Tone.Signal) {
		                subRet[attr] = param.value;
		            } else if (param instanceof AudioParam) {
		                subRet[attr] = param.value;
		            } else if (param instanceof Tone) {
		                subRet[attr] = param.get();
		            } else if (!isFunction(param) && !isUndef(param)) {
		                subRet[attr] = param;
		            }
		        }
		        return ret;
		    };
		    /**
			 *  collect all of the default attributes in one
			 *  @private
			 *  @param {function} constr the constructor to find the defaults from
			 *  @return {Array} all of the attributes which belong to the class
			 */
		    Tone.prototype._collectDefaults = function (constr) {
		        var ret = [];
		        if (!isUndef(constr.defaults)) {
		            ret = Object.keys(constr.defaults);
		        }
		        if (!isUndef(constr._super)) {
		            var superDefs = this._collectDefaults(constr._super);
		            //filter out repeats
		            for (var i = 0; i < superDefs.length; i++) {
		                if (ret.indexOf(superDefs[i]) === -1) {
		                    ret.push(superDefs[i]);
		                }
		            }
		        }
		        return ret;
		    };
		    /**
			 *  Set the preset if it exists. 
			 *  @param {string} presetName the name of the preset
			 *  @returns {Tone} this
			 */
		    Tone.prototype.setPreset = function (presetName) {
		        if (!this.isUndef(this.preset) && this.preset.hasOwnProperty(presetName)) {
		            this.set(this.preset[presetName]);
		        }
		        return this;
		    };
		    /**
			 *  @returns {string} returns the name of the class as a string
			 */
		    Tone.prototype.toString = function () {
		        for (var className in Tone) {
		            var isLetter = className[0].match(/^[A-Z]$/);
		            var sameConstructor = Tone[className] === this.constructor;
		            if (isFunction(Tone[className]) && isLetter && sameConstructor) {
		                return className;
		            }
		        }
		        return 'Tone';
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	CLASS VARS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  A static pointer to the audio context accessible as Tone.context. 
			 *  @type {AudioContext}
			 */
		    Tone.context = audioContext;
		    /**
			 *  The audio context.
			 *  @type {AudioContext}
			 */
		    Tone.prototype.context = Tone.context;
		    /**
			 *  the default buffer size
			 *  @type {number}
			 *  @static
			 *  @const
			 */
		    Tone.prototype.bufferSize = 2048;
		    /**
			 *  the delay time of a single buffer frame
			 *  @type {number}
			 *  @static
			 *  @const
			 */
		    Tone.prototype.bufferTime = Tone.prototype.bufferSize / Tone.context.sampleRate;
		    ///////////////////////////////////////////////////////////////////////////
		    //	CONNECTIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  disconnect and dispose
			 *  @returns {Tone} this
			 */
		    Tone.prototype.dispose = function () {
		        if (!this.isUndef(this.input)) {
		            if (this.input instanceof AudioNode) {
		                this.input.disconnect();
		            }
		            this.input = null;
		        }
		        if (!this.isUndef(this.output)) {
		            if (this.output instanceof AudioNode) {
		                this.output.disconnect();
		            }
		            this.output = null;
		        }
		        return this;
		    };
		    /**
			 *  a silent connection to the DesinationNode
			 *  which will ensure that anything connected to it
			 *  will not be garbage collected
			 *  
			 *  @private
			 */
		    var _silentNode = null;
		    /**
			 *  makes a connection to ensure that the node will not be garbage collected
			 *  until 'dispose' is explicitly called
			 *
			 *  use carefully. circumvents JS and WebAudio's normal Garbage Collection behavior
			 *  @returns {Tone} this
			 */
		    Tone.prototype.noGC = function () {
		        this.output.connect(_silentNode);
		        return this;
		    };
		    AudioNode.prototype.noGC = function () {
		        this.connect(_silentNode);
		        return this;
		    };
		    /**
			 *  connect the output of a ToneNode to an AudioParam, AudioNode, or ToneNode
			 *  @param  {Tone | AudioParam | AudioNode} unit 
			 *  @param {number} [outputNum=0] optionally which output to connect from
			 *  @param {number} [inputNum=0] optionally which input to connect to
			 *  @returns {Tone} this
			 */
		    Tone.prototype.connect = function (unit, outputNum, inputNum) {
		        if (Array.isArray(this.output)) {
		            outputNum = this.defaultArg(outputNum, 0);
		            this.output[outputNum].connect(unit, 0, inputNum);
		        } else {
		            this.output.connect(unit, outputNum, inputNum);
		        }
		        return this;
		    };
		    /**
			 *  disconnect the output
			 *  @returns {Tone} this
			 */
		    Tone.prototype.disconnect = function (outputNum) {
		        if (Array.isArray(this.output)) {
		            outputNum = this.defaultArg(outputNum, 0);
		            this.output[outputNum].disconnect();
		        } else {
		            this.output.disconnect();
		        }
		        return this;
		    };
		    /**
			 *  connect together all of the arguments in series
			 *  @param {...AudioParam|Tone|AudioNode}
			 *  @returns {Tone} this
			 */
		    Tone.prototype.connectSeries = function () {
		        if (arguments.length > 1) {
		            var currentUnit = arguments[0];
		            for (var i = 1; i < arguments.length; i++) {
		                var toUnit = arguments[i];
		                currentUnit.connect(toUnit);
		                currentUnit = toUnit;
		            }
		        }
		        return this;
		    };
		    /**
			 *  fan out the connection from the first argument to the rest of the arguments
			 *  @param {...AudioParam|Tone|AudioNode}
			 *  @returns {Tone} this
			 */
		    Tone.prototype.connectParallel = function () {
		        var connectFrom = arguments[0];
		        if (arguments.length > 1) {
		            for (var i = 1; i < arguments.length; i++) {
		                var connectTo = arguments[i];
		                connectFrom.connect(connectTo);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Connect the output of this node to the rest of the nodes in series.
			 *  @example
			 *  //connect a node to an effect, panVol and then to the master output
			 *  node.chain(effect, panVol, Tone.Master);
			 *  @param {...AudioParam|Tone|AudioNode} nodes
			 *  @returns {Tone} this
			 */
		    Tone.prototype.chain = function () {
		        if (arguments.length > 0) {
		            var currentUnit = this;
		            for (var i = 0; i < arguments.length; i++) {
		                var toUnit = arguments[i];
		                currentUnit.connect(toUnit);
		                currentUnit = toUnit;
		            }
		        }
		        return this;
		    };
		    /**
			 *  connect the output of this node to the rest of the nodes in parallel.
			 *  @param {...AudioParam|Tone|AudioNode}
			 *  @returns {Tone} this
			 */
		    Tone.prototype.fan = function () {
		        if (arguments.length > 0) {
		            for (var i = 0; i < arguments.length; i++) {
		                this.connect(arguments[i]);
		            }
		        }
		        return this;
		    };
		    //give native nodes chain and fan methods
		    AudioNode.prototype.chain = Tone.prototype.chain;
		    AudioNode.prototype.fan = Tone.prototype.fan;
		    ///////////////////////////////////////////////////////////////////////////
		    //	UTILITIES / HELPERS / MATHS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  if a the given is undefined, use the fallback. 
			 *  if both given and fallback are objects, given
			 *  will be augmented with whatever properties it's
			 *  missing which are in fallback
			 *
			 *  warning: if object is self referential, it will go into an an 
			 *  infinite recursive loop. 
			 *  
			 *  @param  {*} given    
			 *  @param  {*} fallback 
			 *  @return {*}          
			 */
		    Tone.prototype.defaultArg = function (given, fallback) {
		        if (typeof given === 'object' && typeof fallback === 'object') {
		            var ret = {};
		            //make a deep copy of the given object
		            for (var givenProp in given) {
		                ret[givenProp] = this.defaultArg(given[givenProp], given[givenProp]);
		            }
		            for (var prop in fallback) {
		                ret[prop] = this.defaultArg(given[prop], fallback[prop]);
		            }
		            return ret;
		        } else {
		            return isUndef(given) ? fallback : given;
		        }
		    };
		    /**
			 *  returns the args as an options object with given arguments
			 *  mapped to the names provided. 
			 *
			 *  if the args given is an array containing an object, it is assumed
			 *  that that's already the options object and will just return it. 
			 *  
			 *  @param  {Array} values  the 'arguments' object of the function
			 *  @param  {Array} keys the names of the arguments as they
			 *                                 should appear in the options object
			 *  @param {Object=} defaults optional defaults to mixin to the returned 
			 *                            options object                              
			 *  @return {Object}       the options object with the names mapped to the arguments
			 */
		    Tone.prototype.optionsObject = function (values, keys, defaults) {
		        var options = {};
		        if (values.length === 1 && typeof values[0] === 'object') {
		            options = values[0];
		        } else {
		            for (var i = 0; i < keys.length; i++) {
		                options[keys[i]] = values[i];
		            }
		        }
		        if (!this.isUndef(defaults)) {
		            return this.defaultArg(options, defaults);
		        } else {
		            return options;
		        }
		    };
		    /**
			 *  test if the arg is undefined
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is undefined
			 *  @function
			 */
		    Tone.prototype.isUndef = isUndef;
		    /**
			 *  test if the arg is a function
			 *  @param {*} arg the argument to test
			 *  @returns {boolean} true if the arg is a function
			 *  @function
			 */
		    Tone.prototype.isFunction = isFunction;
		    /**
			 *  Make the property not writable. Internal use only. 
			 *  @private
			 *  @param  {string}  property  the property to make not writable
			 */
		    Tone.prototype._readOnly = function (property) {
		        if (Array.isArray(property)) {
		            for (var i = 0; i < property.length; i++) {
		                this._readOnly(property[i]);
		            }
		        } else {
		            Object.defineProperty(this, property, {
		                writable: false,
		                enumerable: true
		            });
		        }
		    };
		    /**
			 *  Make an attribute writeable. Interal use only. 
			 *  @private
			 *  @param  {string}  property  the property to make writable
			 */
		    Tone.prototype._writable = function (property) {
		        if (Array.isArray(property)) {
		            for (var i = 0; i < property.length; i++) {
		                this._writable(property[i]);
		            }
		        } else {
		            Object.defineProperty(this, property, { writable: true });
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // GAIN CONVERSIONS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  equal power gain scale
			 *  good for cross-fading
			 *  @param  {number} percent (0-1)
			 *  @return {number}         output gain (0-1)
			 */
		    Tone.prototype.equalPowerScale = function (percent) {
		        var piFactor = 0.5 * Math.PI;
		        return Math.sin(percent * piFactor);
		    };
		    /**
			 *  convert db scale to gain scale (0-1)
			 *  @param  {number} db
			 *  @return {number}   
			 */
		    Tone.prototype.dbToGain = function (db) {
		        return Math.pow(2, db / 6);
		    };
		    /**
			 *  convert gain scale to decibels
			 *  @param  {number} gain (0-1)
			 *  @return {number}   
			 */
		    Tone.prototype.gainToDb = function (gain) {
		        return 20 * (Math.log(gain) / Math.LN10);
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	TIMING
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  @return {number} the currentTime from the AudioContext
			 */
		    Tone.prototype.now = function () {
		        return this.context.currentTime;
		    };
		    /**
			 *  convert a sample count to seconds
			 *  @param  {number} samples 
			 *  @return {number}         
			 */
		    Tone.prototype.samplesToSeconds = function (samples) {
		        return samples / this.context.sampleRate;
		    };
		    /**
			 *  convert a time into samples
			 *  
			 *  @param  {Tone.time} time
			 *  @return {number}         
			 */
		    Tone.prototype.toSamples = function (time) {
		        var seconds = this.toSeconds(time);
		        return Math.round(seconds * this.context.sampleRate);
		    };
		    /**
			 *  convert time to seconds
			 *
			 *  this is a simplified version which only handles numbers and 
			 *  'now' relative numbers. If the Transport is included this 
			 *  method is overridden to include many other features including 
			 *  notationTime, Frequency, and transportTime
			 *  
			 *  @param  {number=} time 
			 *  @param {number=} now if passed in, this number will be 
			 *                       used for all 'now' relative timings
			 *  @return {number}   	seconds in the same timescale as the AudioContext
			 */
		    Tone.prototype.toSeconds = function (time, now) {
		        now = this.defaultArg(now, this.now());
		        if (typeof time === 'number') {
		            return time;    //assuming that it's seconds
		        } else if (typeof time === 'string') {
		            var plusTime = 0;
		            if (time.charAt(0) === '+') {
		                time = time.slice(1);
		                plusTime = now;
		            }
		            return parseFloat(time) + plusTime;
		        } else {
		            return now;
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // FREQUENCY CONVERSION
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  true if the input is in the format number+hz
			 *  i.e.: 10hz
			 *
			 *  @param {number} freq 
			 *  @return {boolean} 
			 *  @function
			 */
		    Tone.prototype.isFrequency = function () {
		        var freqFormat = new RegExp(/\d*\.?\d+hz$/i);
		        return function (freq) {
		            return freqFormat.test(freq);
		        };
		    }();
		    /**
			 *  Convert a frequency into seconds.
			 *  Accepts numbers and strings: i.e. "10hz" or 
			 *  10 both return 0.1. 
			 *  
			 *  @param  {number|string} freq 
			 *  @return {number}      
			 */
		    Tone.prototype.frequencyToSeconds = function (freq) {
		        return 1 / parseFloat(freq);
		    };
		    /**
			 *  Convert a number in seconds to a frequency.
			 *  @param  {number} seconds 
			 *  @return {number}         
			 */
		    Tone.prototype.secondsToFrequency = function (seconds) {
		        return 1 / seconds;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	INHERITANCE
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  have a child inherit all of Tone's (or a parent's) prototype
			 *  to inherit the parent's properties, make sure to call 
			 *  Parent.call(this) in the child's constructor
			 *
			 *  based on closure library's inherit function
			 *
			 *  @static
			 *  @param  {function} 	child  
			 *  @param  {function=} parent (optional) parent to inherit from
			 *                             if no parent is supplied, the child
			 *                             will inherit from Tone
			 */
		    Tone.extend = function (child, parent) {
		        if (isUndef(parent)) {
		            parent = Tone;
		        }
		        function TempConstructor() {
		        }
		        TempConstructor.prototype = parent.prototype;
		        child.prototype = new TempConstructor();
		        /** @override */
		        child.prototype.constructor = child;
		        child._super = parent;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	TYPES / STATES
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 * Possible types which a value can take on
			 * @enum {string}
			 */
		    Tone.Type = {
		        /** 
				 *  The default value is a number which can take on any value between [-Infinity, Infinity]
				 */
		        Default: 'number',
		        /**
				 *  Time can be described in a number of ways. Read more [Time](https://github.com/TONEnoTONE/Tone.js/wiki/Time).
				 *
				 *  <ul>
				 *  <li>Numbers, which will be taken literally as the time (in seconds).</li>
				 *  <li>Notation, ("4n", "8t") describes time in BPM and time signature relative values.</li>
				 *  <li>TransportTime, ("4:3:2") will also provide tempo and time signature relative times 
				 *  in the form BARS:QUARTERS:SIXTEENTHS.</li>
				 *  <li>Frequency, ("8hz") is converted to the length of the cycle in seconds.</li>
				 *  <li>Now-Relative, ("+1") prefix any of the above with "+" and it will be interpreted as 
				 *  "the current time plus whatever expression follows".</li>
				 *  <li>Expressions, ("3:0 + 2 - (1m / 7)") any of the above can also be combined 
				 *  into a mathematical expression which will be evaluated to compute the desired time.</li>
				 *  <li>No Argument, for methods which accept time, no argument will be interpreted as 
				 *  "now" (i.e. the currentTime).</li>
				 *  </ul>
				 *  
				 *  @typedef {Time}
				 */
		        Time: 'time',
		        /**
				 *  Frequency can be described similar to time, except ultimately the
				 *  values are converted to frequency instead of seconds. A number
				 *  is taken literally as the value in hertz. Additionally any of the 
				 *  Time encodings can be used. Note names in the form
				 *  of NOTE OCTAVE (i.e. C4) are also accepted and converted to their
				 *  frequency value. 
				 *  @typedef {Frequency}
				 */
		        Frequency: 'frequency',
		        /**
				 * Gain is the ratio between the input and the output value of a signal.
				 *  @typedef {Gain}
				 */
		        Gain: 'gain',
		        /** 
				 *  Normal values are within the range [0, 1].
				 *  @typedef {NormalRange}
				 */
		        NormalRange: 'normalrange',
		        /** 
				 *  AudioRange values are between [-1, 1].
				 *  @typedef {AudioRange}
				 */
		        AudioRange: 'audiorange',
		        /** 
				 *  Decibels are a logarithmic unit of measurement which is useful for volume
				 *  because of the logarithmic way that we perceive loudness. 0 decibels 
				 *  means no change in volume. -10db is approximately half as loud and 10db 
				 *  is twice is loud. 
				 *  @typedef {Decibels}
				 */
		        Decibels: 'db',
		        /** 
				 *  Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.
				 *  @typedef {Interval}
				 */
		        Interval: 'interval',
		        /** 
				 *  Beats per minute. 
				 *  @typedef {BPM}
				 */
		        BPM: 'bpm',
		        /** 
				 *  The value must be greater than 0.
				 *  @typedef {Positive}
				 */
		        Positive: 'positive',
		        /** 
				 *  A cent is a hundredth of a semitone. 
				 *  @typedef {Cents}
				 */
		        Cents: 'cents',
		        /** 
				 *  Angle between 0 and 360. 
				 *  @typedef {Degrees}
				 */
		        Degrees: 'degrees',
		        /** 
				 *  A number representing a midi note.
				 *  @typedef {MIDI}
				 */
		        MIDI: 'midi',
		        /** 
				 *  A colon-separated representation of time in the form of
				 *  BARS:QUARTERS:SIXTEENTHS. 
				 *  @typedef {TransportTime}
				 */
		        TransportTime: 'transporttime'
		    };
		    /**
			 * Possible play states. 
			 * @enum {string}
			 */
		    Tone.State = {
		        Started: 'started',
		        Stopped: 'stopped',
		        Paused: 'paused'
		    };
		    /**
			 *  An empty function.
			 *  @static
			 */
		    Tone.noOp = function () {
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	CONTEXT
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  array of callbacks to be invoked when a new context is added
			 *  @private 
			 *  @private
			 */
		    var newContextCallbacks = [];
		    /**
			 *  invoke this callback when a new context is added
			 *  will be invoked initially with the first context
			 *  @private 
			 *  @static
			 *  @param {function(AudioContext)} callback the callback to be invoked
			 *                                           with the audio context
			 */
		    Tone._initAudioContext = function (callback) {
		        //invoke the callback with the existing AudioContext
		        callback(Tone.context);
		        //add it to the array
		        newContextCallbacks.push(callback);
		    };
		    /**
			 *  Tone automatically creates a context on init, but if you are working
			 *  with other libraries which also create an AudioContext, it can be
			 *  useful to set your own. If you are going to set your own context, 
			 *  be sure to do it at the start of your code, before creating any objects.
			 *  @static
			 *  @param {AudioContext} ctx The new audio context to set
			 */
		    Tone.setContext = function (ctx) {
		        //set the prototypes
		        Tone.prototype.context = ctx;
		        Tone.context = ctx;
		        //invoke all the callbacks
		        for (var i = 0; i < newContextCallbacks.length; i++) {
		            newContextCallbacks[i](ctx);
		        }
		    };
		    /**
			 *  Bind this to a touchstart event to start the audio on mobile devices. 
			 *  <br>
			 *  http://stackoverflow.com/questions/12517000/no-sound-on-ios-6-web-audio-api/12569290#12569290
			 *  @static
			 */
		    Tone.startMobile = function () {
		        var osc = Tone.context.createOscillator();
		        var silent = Tone.context.createGain();
		        silent.gain.value = 0;
		        osc.connect(silent);
		        silent.connect(Tone.context.destination);
		        var now = Tone.context.currentTime;
		        osc.start(now);
		        osc.stop(now + 1);
		    };
		    //setup the context
		    Tone._initAudioContext(function (audioContext) {
		        //set the bufferTime
		        Tone.prototype.bufferTime = Tone.prototype.bufferSize / audioContext.sampleRate;
		        _silentNode = audioContext.createGain();
		        _silentNode.gain.value = 0;
		        _silentNode.connect(audioContext.destination);
		    });
		    Tone.version = 'r5';
		    console.log('%c * Tone.js ' + Tone.version + ' * ', 'background: #000; color: #fff');
		    return Tone;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Base class for all Signals. Used Internally. 
			 *
			 *  @constructor
			 *  @extends {Tone}
			 */
		    Tone.SignalBase = function () {
		    };
		    Tone.extend(Tone.SignalBase);
		    /**
			 *  When signals connect to other signals or AudioParams, 
			 *  they take over the output value of that signal or AudioParam. 
			 *  For all other nodes, the behavior is the same as a default <code>connect</code>. 
			 *
			 *  @override
			 *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node 
			 *  @param {number} [outputNumber=0] The output number to connect from.
			 *  @param {number} [inputNumber=0] The input number to connect to.
			 *  @returns {Tone.SignalBase} this
			 */
		    Tone.SignalBase.prototype.connect = function (node, outputNumber, inputNumber) {
		        //zero it out so that the signal can have full control
		        if (node.constructor === Tone.Signal) {
		            //cancel changes
		            node._value.cancelScheduledValues(0);
		            //reset the value
		            node._value.value = 0;
		            //mark the value as overridden
		            node.overridden = true;
		        } else if (node instanceof AudioParam) {
		            node.cancelScheduledValues(0);
		            node.value = 0;
		        }
		        Tone.prototype.connect.call(this, node, outputNumber, inputNumber);
		        return this;
		    };
		    return Tone.SignalBase;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Wraps the native Web Audio API 
			 *         [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {function|Array|Number} mapping The function used to define the values. 
			 *                                    The mapping function should take two arguments: 
			 *                                    the first is the value at the current position 
			 *                                    and the second is the array position. 
			 *                                    If the argument is an array, that array will be
			 *                                    set as the wave shaping function. The input
			 *                                    signal is an AudioRange [-1, 1] value and the output
			 *                                    signal can take on any numerical values. 
			 *                                    
			 *  @param {Number} [bufferLen=1024] The length of the WaveShaperNode buffer.
			 *  @example
			 * var timesTwo = new Tone.WaveShaper(function(val){
			 * 	return val * 2;
			 * }, 2048);
			 *  @example
			 * //a waveshaper can also be constructed with an array of values
			 * var invert = new Tone.WaveShaper([1, -1]);
			 */
		    Tone.WaveShaper = function (mapping, bufferLen) {
		        /**
				 *  the waveshaper
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._shaper = this.input = this.output = this.context.createWaveShaper();
		        /**
				 *  the waveshapers curve
				 *  @type {Float32Array}
				 *  @private
				 */
		        this._curve = null;
		        if (Array.isArray(mapping)) {
		            this.curve = mapping;
		        } else if (isFinite(mapping) || this.isUndef(mapping)) {
		            this._curve = new Float32Array(this.defaultArg(mapping, 1024));
		        } else if (this.isFunction(mapping)) {
		            this._curve = new Float32Array(this.defaultArg(bufferLen, 1024));
		            this.setMap(mapping);
		        }
		    };
		    Tone.extend(Tone.WaveShaper, Tone.SignalBase);
		    /**
			 *  Uses a mapping function to set the value of the curve. 
			 *  @param {function} mapping The function used to define the values. 
			 *                            The mapping function take two arguments: 
			 *                            the first is the value at the current position 
			 *                            which goes from -1 to 1 over the number of elements
			 *                            in the curve array. The second argument is the array position. 
			 *  @returns {Tone.WaveShaper} this
			 *  @example
			 * //map the input signal from [-1, 1] to [0, 10]
			 * shaper.setMap(function(val, index){
			 * 	return (val + 1) * 5;
			 * })
			 */
		    Tone.WaveShaper.prototype.setMap = function (mapping) {
		        for (var i = 0, len = this._curve.length; i < len; i++) {
		            var normalized = i / len * 2 - 1;
		            this._curve[i] = mapping(normalized, i);
		        }
		        this._shaper.curve = this._curve;
		        return this;
		    };
		    /**
			 * The array to set as the waveshaper curve. For linear curves
			 * array length does not make much difference, but for complex curves
			 * longer arrays will provide smoother interpolation. 
			 * @memberOf Tone.WaveShaper#
			 * @type {Array}
			 * @name curve
			 */
		    Object.defineProperty(Tone.WaveShaper.prototype, 'curve', {
		        get: function () {
		            return this._shaper.curve;
		        },
		        set: function (mapping) {
		            //fixes safari WaveShaperNode bug
		            if (this._isSafari()) {
		                var first = mapping[0];
		                mapping.unshift(first);
		            }
		            this._curve = new Float32Array(mapping);
		            this._shaper.curve = this._curve;
		        }
		    });
		    /**
			 * Specifies what type of oversampling (if any) should be used when 
			 * applying the shaping curve. Can either be "none", "2x" or "4x". 
			 * @memberOf Tone.WaveShaper#
			 * @type {string}
			 * @name oversample
			 */
		    Object.defineProperty(Tone.WaveShaper.prototype, 'oversample', {
		        get: function () {
		            return this._shaper.oversample;
		        },
		        set: function (oversampling) {
		            this._shaper.oversample = oversampling;
		        }
		    });
		    /**
			 *  returns true if the browser is safari
			 *  @return  {boolean} 
			 *  @private
			 */
		    Tone.WaveShaper.prototype._isSafari = function () {
		        var ua = navigator.userAgent.toLowerCase();
		        return ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.WaveShaper} this
			 */
		    Tone.WaveShaper.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._shaper.disconnect();
		        this._shaper = null;
		        this._curve = null;
		        return this;
		    };
		    return Tone.WaveShaper;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A signal is an audio-rate value. Tone.Signal is a core component of the library.
			 *          Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal
			 *          has all of the methods available to native Web Audio 
			 *          [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)
			 *          as well as additional conveniences. Read more about working with signals 
			 *          [here](https://github.com/TONEnoTONE/Tone.js/wiki/Signals).
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {Number|AudioParam} [value] Initial value of the signal. If an AudioParam
			 *                                     is passed in, that parameter will be wrapped
			 *                                     and controlled by the Signal. 
			 *  @param {string} [units=Number] unit The units the signal is in. 
			 *  @example
			 * var signal = new Tone.Signal(10);
			 */
		    Tone.Signal = function () {
		        var options = this.optionsObject(arguments, [
		            'value',
		            'units'
		        ], Tone.Signal.defaults);
		        /**
				 * The units of the signal.
				 * @type {string}
				 */
		        this.units = options.units;
		        /**
				 *  When true, converts the set value
				 *  based on the units given. When false,
				 *  applies no conversion and the units
				 *  are merely used as a label. 
				 *  @type  {boolean}
				 */
		        this.convert = options.convert;
		        /**
				 *  True if the signal value is being overridden by 
				 *  a connected signal.
				 *  @readOnly
				 *  @type  {boolean}
				 *  @private
				 */
		        this.overridden = false;
		        /**
				 * The node where the constant signal value is scaled.
				 * @type {GainNode}
				 * @private
				 */
		        this.output = this._scaler = this.context.createGain();
		        /**
				 * The node where the value is set.
				 * @type {AudioParam}
				 * @private
				 */
		        this.input = this._value = this._scaler.gain;
		        if (options.value instanceof AudioParam) {
		            this._scaler.connect(options.value);
		            //zero out the value
		            options.value.value = 0;
		        } else {
		            if (!this.isUndef(options.param)) {
		                this._scaler.connect(options.param);
		                options.param.value = 0;
		            }
		            this.value = options.value;
		        }
		        //connect the constant 1 output to the node output
		        Tone.Signal._constant.chain(this._scaler);
		    };
		    Tone.extend(Tone.Signal, Tone.SignalBase);
		    /**
			 *  The default values
			 *  @type  {Object}
			 *  @static
			 *  @const
			 */
		    Tone.Signal.defaults = {
		        'value': 0,
		        'param': undefined,
		        'units': Tone.Type.Default,
		        'convert': true
		    };
		    /**
			 * The current value of the signal. 
			 * @memberOf Tone.Signal#
			 * @type {Number}
			 * @name value
			 */
		    Object.defineProperty(Tone.Signal.prototype, 'value', {
		        get: function () {
		            return this._toUnits(this._value.value);
		        },
		        set: function (value) {
		            var convertedVal = this._fromUnits(value);
		            //is this what you want?
		            this.cancelScheduledValues(0);
		            this._value.value = convertedVal;
		        }
		    });
		    /**
			 * @private
			 * @param  {*} val the value to convert
			 * @return {number}     the number which the value should be set to
			 */
		    Tone.Signal.prototype._fromUnits = function (val) {
		        if (this.convert || this.isUndef(this.convert)) {
		            switch (this.units) {
		            case Tone.Type.Time:
		                return this.toSeconds(val);
		            case Tone.Type.Frequency:
		                return this.toFrequency(val);
		            case Tone.Type.Decibels:
		                return this.dbToGain(val);
		            case Tone.Type.NormalRange:
		                return Math.min(Math.max(val, 0), 1);
		            case Tone.Type.AudioRange:
		                return Math.min(Math.max(val, -1), 1);
		            case Tone.Type.Positive:
		                return Math.max(val, 0);
		            default:
		                return val;
		            }
		        } else {
		            return val;
		        }
		    };
		    /**
			 * convert to the desired units
			 * @private
			 * @param  {number} val the value to convert
			 * @return {number}
			 */
		    Tone.Signal.prototype._toUnits = function (val) {
		        if (this.convert || this.isUndef(this.convert)) {
		            switch (this.units) {
		            case Tone.Type.Decibels:
		                return this.gainToDb(val);
		            default:
		                return val;
		            }
		        } else {
		            return val;
		        }
		    };
		    /**
			 *  Schedules a parameter value change at the given time.
			 *  @param {*}	value The value to set the signal.
			 *  @param {Time}  time The time when the change should occur.
			 *  @returns {Tone.Signal} this
			 *  @example
			 * //set the frequency to "G4" in exactly 1 second from now. 
			 * freq.setValueAtTime("G4", "+1");
			 */
		    Tone.Signal.prototype.setValueAtTime = function (value, time) {
		        value = this._fromUnits(value);
		        this._value.setValueAtTime(value, this.toSeconds(time));
		        return this;
		    };
		    /**
			 *  Creates a schedule point with the current value at the current time.
			 *  This is useful for creating an automation anchor point in order to 
			 *  schedule changes from the current value. 
			 *
			 *  @param {number=} now (Optionally) pass the now value in. 
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.setCurrentValueNow = function (now) {
		        now = this.defaultArg(now, this.now());
		        var currentVal = this._value.value;
		        this.cancelScheduledValues(now);
		        this._value.setValueAtTime(currentVal, now);
		        return this;
		    };
		    /**
			 *  Schedules a linear continuous change in parameter value from the 
			 *  previous scheduled parameter value to the given value.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} endTime 
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.linearRampToValueAtTime = function (value, endTime) {
		        value = this._fromUnits(value);
		        this._value.linearRampToValueAtTime(value, this.toSeconds(endTime));
		        return this;
		    };
		    /**
			 *  Schedules an exponential continuous change in parameter value from 
			 *  the previous scheduled parameter value to the given value.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} endTime 
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.exponentialRampToValueAtTime = function (value, endTime) {
		        value = this._fromUnits(value);
		        value = Math.max(0.00001, value);
		        this._value.exponentialRampToValueAtTime(value, this.toSeconds(endTime));
		        return this;
		    };
		    /**
			 *  Schedules an exponential continuous change in parameter value from 
			 *  the current time and current value to the given value.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} rampTime the time that it takes the 
			 *                               value to ramp from it's current value
			 *  @returns {Tone.Signal} this
			 *  @example
			 * //exponentially ramp to the value 2 over 4 seconds. 
			 * signal.exponentialRampToValueNow(2, 4);
			 */
		    Tone.Signal.prototype.exponentialRampToValueNow = function (value, rampTime) {
		        var now = this.now();
		        // exponentialRampToValueAt cannot ever ramp from 0, apparently.
		        // More info: https://bugzilla.mozilla.org/show_bug.cgi?id=1125600#c2
		        var currentVal = this.value;
		        this.setValueAtTime(Math.max(currentVal, 0.0001), now);
		        this.exponentialRampToValueAtTime(value, now + this.toSeconds(rampTime));
		        return this;
		    };
		    /**
			 *  Schedules an linear continuous change in parameter value from 
			 *  the current time and current value to the given value at the given time.
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} rampTime the time that it takes the 
			 *                               value to ramp from it's current value
			 *  @returns {Tone.Signal} this
			 *  @example
			 * //linearly ramp to the value 4 over 3 seconds. 
			 * signal.linearRampToValueNow(4, 3);
			 */
		    Tone.Signal.prototype.linearRampToValueNow = function (value, rampTime) {
		        var now = this.now();
		        this.setCurrentValueNow(now);
		        this.linearRampToValueAtTime(value, now + this.toSeconds(rampTime));
		        return this;
		    };
		    /**
			 *  Start exponentially approaching the target value at the given time with
			 *  a rate having the given time constant.
			 *  @param {number} value        
			 *  @param {Time} startTime    
			 *  @param {number} timeConstant 
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {
		        value = this._fromUnits(value);
		        // The value will never be able to approach without timeConstant > 0.
		        // http://www.w3.org/TR/webaudio/#dfn-setTargetAtTime, where the equation
		        // is described. 0 results in a division by 0.
		        timeConstant = Math.max(0.00001, timeConstant);
		        this._value.setTargetAtTime(value, this.toSeconds(startTime), timeConstant);
		        return this;
		    };
		    /**
			 *  Sets an array of arbitrary parameter values starting at the given time
			 *  for the given duration.
			 *  	
			 *  @param {Array} values    
			 *  @param {Time} startTime 
			 *  @param {Time} duration  
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.setValueCurveAtTime = function (values, startTime, duration) {
		        for (var i = 0; i < values.length; i++) {
		            values[i] = this._fromUnits(values[i]);
		        }
		        this._value.setValueCurveAtTime(values, this.toSeconds(startTime), this.toSeconds(duration));
		        return this;
		    };
		    /**
			 *  Cancels all scheduled parameter changes with times greater than or 
			 *  equal to startTime.
			 *  
			 *  @param  {Time} startTime
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.cancelScheduledValues = function (startTime) {
		        this._value.cancelScheduledValues(this.toSeconds(startTime));
		        return this;
		    };
		    /**
			 *  Ramps to the given value over the duration of the rampTime. 
			 *  Automatically selects the best ramp type (exponential or linear)
			 *  depending on the `units` of the signal
			 *  
			 *  @param  {number} value   
			 *  @param  {Time} rampTime the time that it takes the 
			 *                               value to ramp from it's current value
			 *  @returns {Tone.Signal} this
			 *  @example
			 * //ramp to the value either linearly or exponentially 
			 * //depending on the "units" value of the signal
			 * signal.rampTo(0, 10);
			 */
		    Tone.Signal.prototype.rampTo = function (value, rampTime) {
		        rampTime = this.defaultArg(rampTime, 0);
		        if (this.units === Tone.Type.Frequency || this.units === Tone.Type.BPM) {
		            this.exponentialRampToValueNow(value, rampTime);
		        } else {
		            this.linearRampToValueNow(value, rampTime);
		        }
		        return this;
		    };
		    /**
			 *  dispose and disconnect
			 *  @returns {Tone.Signal} this
			 */
		    Tone.Signal.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._value = null;
		        this._scaler = null;
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	STATIC
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  the constant signal generator
			 *  @static
			 *  @private
			 *  @const
			 *  @type {OscillatorNode}
			 */
		    Tone.Signal._generator = null;
		    /**
			 *  the signal generator waveshaper. makes the incoming signal
			 *  only output 1 for all inputs.
			 *  @static
			 *  @private
			 *  @const
			 *  @type {Tone.WaveShaper}
			 */
		    Tone.Signal._constant = null;
		    /**
			 *  initializer function
			 */
		    Tone._initAudioContext(function (audioContext) {
		        Tone.Signal._generator = audioContext.createOscillator();
		        Tone.Signal._constant = new Tone.WaveShaper([
		            1,
		            1
		        ]);
		        Tone.Signal._generator.connect(Tone.Signal._constant);
		        Tone.Signal._generator.start(0);
		        Tone.Signal._generator.noGC();
		    });
		    return Tone.Signal;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Pow applies an exponent to the incoming signal. The incoming signal
			 *         must be AudioRange.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {number} exp The exponent to apply to the incoming signal, must be at least 2. 
			 *  @example
			 * var pow = new Tone.Pow(2);
			 * var sig = new Tone.Signal(0.5).connect(pow);
			 * //output of pow is 0.25. 
			 */
		    Tone.Pow = function (exp) {
		        /**
				 * the exponent
				 * @private
				 * @type {number}
				 */
		        this._exp = this.defaultArg(exp, 1);
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._expScaler = this.input = this.output = new Tone.WaveShaper(this._expFunc(this._exp), 8192);
		    };
		    Tone.extend(Tone.Pow, Tone.SignalBase);
		    /**
			 * The value of the exponent.
			 * @memberOf Tone.Pow#
			 * @type {number}
			 * @name value
			 */
		    Object.defineProperty(Tone.Pow.prototype, 'value', {
		        get: function () {
		            return this._exp;
		        },
		        set: function (exp) {
		            this._exp = exp;
		            this._expScaler.setMap(this._expFunc(this._exp));
		        }
		    });
		    /**
			 *  the function which maps the waveshaper
			 *  @param   {number} exp
			 *  @return {function}
			 *  @private
			 */
		    Tone.Pow.prototype._expFunc = function (exp) {
		        return function (val) {
		            return Math.pow(Math.abs(val), exp);
		        };
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Pow} this
			 */
		    Tone.Pow.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._expScaler.dispose();
		        this._expScaler = null;
		        return this;
		    };
		    return Tone.Pow;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)
			 *          envelope generator. Tone.Envelope outputs a signal which 
			 *          can be connected to an AudioParam or Tone.Signal. 
			 *          <img src="https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg">
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Time} [attack] The amount of time it takes for the envelope to go from 
			 *                         0 to it's maximum value. 
			 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
			 *                       	to fall to the sustain value. 
			 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
			 *                                	the release is triggered. 
			 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0. 
			 *  @example
			 * //an amplitude envelope
			 * var gainNode = Tone.context.createGain();
			 * var env = new Tone.Envelope({
			 * 	"attack" : 0.1,
			 * 	"decay" : 0.2,
			 * 	"sustain" : 1,
			 * 	"release" : 0.8,
			 * });
			 * env.connect(gainNode.gain);
			 */
		    Tone.Envelope = function () {
		        //get all of the defaults
		        var options = this.optionsObject(arguments, [
		            'attack',
		            'decay',
		            'sustain',
		            'release'
		        ], Tone.Envelope.defaults);
		        /** 
				 *  When triggerAttack is called, the attack time is the amount of
				 *  time it takes for the envelope to reach it's maximum value. 
				 *  @type {Time}
				 */
		        this.attack = options.attack;
		        /**
				 *  After the attack portion of the envelope, the value will fall
				 *  over the duration of the decay time to it's sustain value. 
				 *  @type {Time}
				 */
		        this.decay = options.decay;
		        /**
				 * 	The sustain value is the value 
				 * 	which the envelope rests at after triggerAttack is
				 * 	called, but before triggerRelease is invoked. 
				 *  @type {NormalRange}
				 */
		        this.sustain = options.sustain;
		        /**
				 *  After triggerRelease is called, the envelope's
				 *  value will fall to it's miminum value over the
				 *  duration of the release time. 
				 *  @type {Time}
				 */
		        this.release = options.release;
		        /**
				 *  the next time the envelope is attacked
				 *  @type {number}
				 *  @private
				 */
		        this._nextAttack = Infinity;
		        /**
				 *  the next time the envelope is decayed
				 *  @type {number}
				 *  @private
				 */
		        this._nextDecay = Infinity;
		        /**
				 *  the next time the envelope is sustain
				 *  @type {number}
				 *  @private
				 */
		        this._nextSustain = Infinity;
		        /**
				 *  the next time the envelope is released
				 *  @type {number}
				 *  @private
				 */
		        this._nextRelease = Infinity;
		        /**
				 *  the next time the envelope is at standby
				 *  @type {number}
				 *  @private
				 */
		        this._nextStandby = Infinity;
		        /**
				 *  the next time the envelope is at standby
				 *  @type {number}
				 *  @private
				 */
		        this._attackCurve = Tone.Envelope.Type.Linear;
		        /** 
				 *  the last recorded velocity value
				 *  @type {number}
				 *  @private
				 */
		        this._peakValue = 1;
		        /**
				 *  the minimum output value
				 *  @type {number}
				 *  @private
				 */
		        this._minOutput = 0.0001;
		        /**
				 *  the signal
				 *  @type {Tone.Signal}
				 *  @private
				 */
		        this._sig = this.output = new Tone.Signal(0);
		        //set the attackCurve initially
		        this.attackCurve = options.attackCurve;
		    };
		    Tone.extend(Tone.Envelope);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 */
		    Tone.Envelope.defaults = {
		        'attack': 0.01,
		        'decay': 0.1,
		        'sustain': 0.5,
		        'release': 1,
		        'attackCurve': 'linear'
		    };
		    /**
			 *  the envelope time multipler
			 *  @type {number}
			 *  @private
			 */
		    Tone.Envelope.prototype._timeMult = 0.25;
		    /**
			 * Read the current value of the envelope. Useful for 
			 * syncronizing visual output to the envelope. 
			 * @memberOf Tone.Envelope#
			 * @type {Number}
			 * @name value
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Envelope.prototype, 'value', {
		        get: function () {
		            return this._sig.value;
		        }
		    });
		    /**
			 * The slope of the attack. Either "linear" or "exponential". 
			 * @memberOf Tone.Envelope#
			 * @type {string}
			 * @name attackCurve
			 * @example
			 * env.attackCurve = "linear";
			 */
		    Object.defineProperty(Tone.Envelope.prototype, 'attackCurve', {
		        get: function () {
		            return this._attackCurve;
		        },
		        set: function (type) {
		            if (type === Tone.Envelope.Type.Linear || type === Tone.Envelope.Type.Exponential) {
		                this._attackCurve = type;
		            } else {
		                throw Error('attackCurve must be either "linear" or "exponential". Invalid type: ', type);
		            }
		        }
		    });
		    /**
			 *  Get the phase of the envelope at the specified time.
			 *  @param  {number}  time
			 *  @return  {Tone.Envelope.Phase} 
			 *  @private
			 */
		    Tone.Envelope.prototype._phaseAtTime = function (time) {
		        if (this._nextRelease > time) {
		            if (this._nextAttack <= time && this._nextDecay > time) {
		                return Tone.Envelope.Phase.Attack;
		            } else if (this._nextDecay <= time && this._nextSustain > time) {
		                return Tone.Envelope.Phase.Decay;
		            } else if (this._nextSustain <= time && this._nextRelease > time) {
		                return Tone.Envelope.Phase.Sustain;
		            } else {
		                return Tone.Envelope.Phase.Standby;
		            }
		        } else if (this._nextRelease < time && this._nextStandby > time) {
		            return Tone.Envelope.Phase.Release;
		        } else {
		            return Tone.Envelope.Phase.Standby;
		        }
		    };
		    /**
			 *  https://github.com/jsantell/web-audio-automation-timeline
			 *  MIT License, copyright (c) 2014 Jordan Santell
			 *  @private
			 */
		    Tone.Envelope.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {
		        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);
		    };
		    /**
			 *  @private
			 */
		    Tone.Envelope.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {
		        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));
		    };
		    /**
			 *  @private
			 */
		    Tone.Envelope.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {
		        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));
		    };
		    /**
			 *  Get the envelopes value at the given time
			 *  @param  {number}  time
			 *  @param  {number}  velocity
			 *  @return  {number} 
			 *  @private
			 */
		    Tone.Envelope.prototype._valueAtTime = function (time) {
		        var attack = this.toSeconds(this.attack);
		        var decay = this.toSeconds(this.decay);
		        var release = this.toSeconds(this.release);
		        switch (this._phaseAtTime(time)) {
		        case Tone.Envelope.Phase.Attack:
		            if (this._attackCurve === Tone.Envelope.Type.Linear) {
		                return this._linearInterpolate(this._nextAttack, this._minOutput, this._nextAttack + attack, this._peakValue, time);
		            } else {
		                return this._exponentialInterpolate(this._nextAttack, this._minOutput, this._nextAttack + attack, this._peakValue, time);
		            }
		            break;
		        case Tone.Envelope.Phase.Decay:
		            return this._exponentialApproach(this._nextDecay, this._peakValue, this.sustain * this._peakValue, decay * this._timeMult, time);
		        case Tone.Envelope.Phase.Release:
		            return this._exponentialApproach(this._nextRelease, this._peakValue, this._minOutput, release * this._timeMult, time);
		        case Tone.Envelope.Phase.Sustain:
		            return this.sustain * this._peakValue;
		        case Tone.Envelope.Phase.Standby:
		            return this._minOutput;
		        }
		    };
		    /**
			 *  Trigger the attack/decay portion of the ADSR envelope. 
			 *  @param  {Time} [time=now] When the attack should start.
			 *  @param {NormalRange} [velocity=1] The velocity of the envelope scales the vales.
			 *                               number between 0-1
			 *  @returns {Tone.Envelope} this
			 *  @example
			 *  //trigger the attack 0.5 seconds from now with a velocity of 0.2
			 *  env.triggerAttack("+0.5", 0.2);
			 */
		    Tone.Envelope.prototype.triggerAttack = function (time, velocity) {
		        //to seconds
		        time = this.toSeconds(time);
		        var attack = this.toSeconds(this.attack);
		        var decay = this.toSeconds(this.decay);
		        //get the phase and position
		        var valueAtTime = this._valueAtTime(time);
		        var attackPast = valueAtTime * attack;
		        //compute the timing
		        this._nextAttack = time - attackPast;
		        this._nextDecay = this._nextAttack + attack;
		        this._nextSustain = this._nextDecay + decay;
		        this._nextRelease = Infinity;
		        //get the values
		        this._peakValue = this.defaultArg(velocity, 1);
		        var scaledMax = this._peakValue;
		        var sustainVal = this.sustain * scaledMax;
		        //set the curve		
		        this._sig.cancelScheduledValues(time);
		        this._sig.setValueAtTime(valueAtTime, time);
		        if (this._attackCurve === Tone.Envelope.Type.Linear) {
		            this._sig.linearRampToValueAtTime(scaledMax, this._nextDecay);
		        } else {
		            this._sig.exponentialRampToValueAtTime(scaledMax, this._nextDecay);
		        }
		        this._sig.setTargetAtTime(sustainVal, this._nextDecay, decay * this._timeMult);
		        return this;
		    };
		    /**
			 *  Triggers the release of the envelope.
			 *  @param  {Time} [time=now] When the release portion of the envelope should start. 
			 *  @returns {Tone.Envelope} this
			 *  @example
			 *  //trigger release immediately
			 *  env.triggerRelease();
			 */
		    Tone.Envelope.prototype.triggerRelease = function (time) {
		        time = this.toSeconds(time);
		        var phase = this._phaseAtTime(time);
		        var release = this.toSeconds(this.release);
		        //computer the value at the start of the next release
		        var valueAtTime = this._valueAtTime(time);
		        this._peakValue = valueAtTime;
		        this._nextRelease = time;
		        this._nextStandby = this._nextRelease + release;
		        //set the values
		        this._sig.cancelScheduledValues(this._nextRelease);
		        //if the phase is in the attack still, must reschedule the rest of the attack
		        if (phase === Tone.Envelope.Phase.Attack) {
		            this._sig.setCurrentValueNow();
		            if (this.attackCurve === Tone.Envelope.Type.Linear) {
		                this._sig.linearRampToValueAtTime(this._peakValue, this._nextRelease);
		            } else {
		                this._sig.exponentialRampToValueAtTime(this._peakValue, this._nextRelease);
		            }
		        } else {
		            this._sig.setValueAtTime(this._peakValue, this._nextRelease);
		        }
		        this._sig.setTargetAtTime(this._minOutput, this._nextRelease, release * this._timeMult);
		        return this;
		    };
		    /**
			 *  triggerAttackRelease is shorthand for triggerAttack, then waiting
			 *  some duration, then triggerRelease. 
			 *  @param {Time} duration The duration of the sustain.
			 *  @param {Time} [time=now] When the attack should be triggered.
			 *  @param {number} [velocity=1] The velocity of the envelope. 
			 *  @returns {Tone.Envelope} this
			 *  @example
			 * //trigger the attack and then the release after 0.6 seconds.
			 * env.triggerAttackRelease(0.6);
			 */
		    Tone.Envelope.prototype.triggerAttackRelease = function (duration, time, velocity) {
		        time = this.toSeconds(time);
		        this.triggerAttack(time, velocity);
		        this.triggerRelease(time + this.toSeconds(duration));
		        return this;
		    };
		    /**
			 *  Borrows the connect method from Tone.Signal. 
			 *  @function
			 *  @private
			 */
		    Tone.Envelope.prototype.connect = Tone.Signal.prototype.connect;
		    /**
			 *  Disconnect and dispose.
			 *  @returns {Tone.Envelope} this
			 */
		    Tone.Envelope.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._sig.dispose();
		        this._sig = null;
		        return this;
		    };
		    /**
			 *  The phase of the envelope. 
			 *  @enum {string}
			 */
		    Tone.Envelope.Phase = {
		        Attack: 'attack',
		        Decay: 'decay',
		        Sustain: 'sustain',
		        Release: 'release',
		        Standby: 'standby'
		    };
		    /**
			 *  The phase of the envelope. 
			 *  @enum {string}
			 */
		    Tone.Envelope.Type = {
		        Linear: 'linear',
		        Exponential: 'exponential'
		    };
		    return Tone.Envelope;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.AmplitudeEnvelope is a Tone.Envelope connected to a gain node. 
			 *          Unlike Tone.Envelope, which outputs the envelope's value, Tone.AmplitudeEnvelope accepts
			 *          an audio signal as the input and will apply the envelope to the amplitude
			 *          of the signal. Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).
			 *  
			 *  @constructor
			 *  @extends {Tone.Envelope}
			 *  @param {Time|Object} [attack] The amount of time it takes for the envelope to go from 
			 *                               0 to it's maximum value. 
			 *  @param {Time} [decay]	The period of time after the attack that it takes for the envelope
			 *                       	to fall to the sustain value. 
			 *  @param {NormalRange} [sustain]	The percent of the maximum value that the envelope rests at until
			 *                                	the release is triggered. 
			 *  @param {Time} [release]	The amount of time after the release is triggered it takes to reach 0. 
			 *  @example
			 * var ampEnv = new Tone.AmplitudeEnvelope({
			 * 	"attack": 0.1,
			 * 	"decay": 0.2,
			 * 	"sustain": 1.0,
			 * 	"release": 0.8
			 * }).toMaster();
			 * //create an oscillator and connect it
			 * var osc = new Tone.Oscillator().connect(ampEnv).start();
			 * //trigger the envelopes attack and release "8t" apart
			 * ampEnv.triggerAttackRelease("8t");
			 */
		    Tone.AmplitudeEnvelope = function () {
		        Tone.Envelope.apply(this, arguments);
		        /**
				 *  the input node
				 *  @type {GainNode}
				 *  @private
				 */
		        this.input = this.output = this.context.createGain();
		        this._sig.connect(this.output.gain);
		    };
		    Tone.extend(Tone.AmplitudeEnvelope, Tone.Envelope);
		    return Tone.AmplitudeEnvelope;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Compressor is a thin wrapper around the Web Audio 
			 *         [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).
			 *         Compression reduces the volume of loud sounds or amplifies quiet sounds 
			 *         by narrowing or "compressing" an audio signal's dynamic range. 
			 *         Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Decibels|Object} [threshold] The value above which the compression starts to be applied.
			 *  @param {Positive} [ratio] The gain reduction ratio.
			 *  @example
			 * var comp = new Tone.Compressor(-30, 3);
			 */
		    Tone.Compressor = function () {
		        var options = this.optionsObject(arguments, [
		            'threshold',
		            'ratio'
		        ], Tone.Compressor.defaults);
		        /**
				 *  the compressor node
				 *  @type {DynamicsCompressorNode}
				 *  @private
				 */
		        this._compressor = this.input = this.output = this.context.createDynamicsCompressor();
		        /**
				 *  the threshold vaue
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.threshold = this._compressor.threshold;
		        /**
				 *  The attack parameter
				 *  @type {Time}
				 *  @signal
				 */
		        this.attack = new Tone.Signal(this._compressor.attack, Tone.Type.Time);
		        /**
				 *  The release parameter
				 *  @type {Time}
				 *  @signal
				 */
		        this.release = new Tone.Signal(this._compressor.release, Tone.Type.Time);
		        /**
				 *  The knee parameter
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.knee = this._compressor.knee;
		        /**
				 *  The ratio value
				 *  @type {Number}
				 *  @signal
				 */
		        this.ratio = this._compressor.ratio;
		        //set the defaults
		        this._readOnly([
		            'knee',
		            'release',
		            'attack',
		            'ratio',
		            'threshold'
		        ]);
		        this.set(options);
		    };
		    Tone.extend(Tone.Compressor);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Compressor.defaults = {
		        'ratio': 12,
		        'threshold': -24,
		        'release': 0.25,
		        'attack': 0.003,
		        'knee': 30
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Compressor} this
			 */
		    Tone.Compressor.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'knee',
		            'release',
		            'attack',
		            'ratio',
		            'threshold'
		        ]);
		        this._compressor.disconnect();
		        this._compressor = null;
		        this.attack.dispose();
		        this.attack = null;
		        this.release.dispose();
		        this.release = null;
		        this.threshold = null;
		        this.ratio = null;
		        this.knee = null;
		        return this;
		    };
		    return Tone.Compressor;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Add a signal and a number or two signals. When no value is
			 *         passed into the constructor, Tone.Add will sum <code>input[0]</code>
			 *         and <code>input[1]</code>. If a value is passed into the constructor, 
			 *         the it will be added to the input.
			 *  
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number=} value If no value is provided, Tone.Add will sum the first
			 *                         and second inputs. 
			 *  @example
			 * var signal = new Tone.Signal(2);
			 * var add = new Tone.Add(2);
			 * signal.connect(add);
			 * //the output of add equals 4
			 *  @example
			 * //if constructed with no arguments
			 * //it will add the first and second inputs
			 * var add = new Tone.Add();
			 * var sig0 = new Tone.Signal(3).connect(add, 0, 0);
			 * var sig1 = new Tone.Signal(4).connect(add, 0, 1);
			 * //the output of add equals 7. 
			 */
		    Tone.Add = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  the summing node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._sum = this.input[0] = this.input[1] = this.output = this.context.createGain();
		        /**
				 *  @private
				 *  @type {Tone.Signal}
				 */
		        this._value = this.input[1] = new Tone.Signal(value);
		        this._value.connect(this._sum);
		    };
		    Tone.extend(Tone.Add, Tone.Signal);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Add} this
			 */
		    Tone.Add.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._sum.disconnect();
		        this._sum = null;
		        this._value.dispose();
		        this._value = null;
		        return this;
		    };
		    return Tone.Add;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Multiply two incoming signals. Or, if a number is given in the constructor, 
			 *          multiplies the incoming signal by that value. 
			 *
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number=} value Constant value to multiple. If no value is provided,
			 *                         it will return the product of the first and second inputs
			 *  @example
			 * var mult = new Tone.Multiply();
			 * var sigA = new Tone.Signal(3);
			 * var sigB = new Tone.Signal(4);
			 * sigA.connect(mult, 0, 0);
			 * sigB.connect(mult, 0, 1);
			 * //output of mult is 12.
			 *  @example
			 * var mult = new Tone.Multiply(10);
			 * var sig = new Tone.Signal(2).connect(mult);
			 * //the output of mult is 20. 
			 */
		    Tone.Multiply = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  the input node is the same as the output node
				 *  it is also the GainNode which handles the scaling of incoming signal
				 *  
				 *  @type {GainNode}
				 *  @private
				 */
		        this._mult = this.input[0] = this.output = this.context.createGain();
		        /**
				 *  the scaling parameter
				 *  @type {AudioParam}
				 *  @private
				 */
		        this._value = this.input[1] = this.output.gain;
		        this._value.value = this.defaultArg(value, 0);
		    };
		    Tone.extend(Tone.Multiply, Tone.Signal);
		    /**
			 *  clean up
			 *  @returns {Tone.Multiply} this
			 */
		    Tone.Multiply.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._mult.disconnect();
		        this._mult = null;
		        this._value = null;
		        return this;
		    };
		    return Tone.Multiply;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Negate the incoming signal. i.e. an input signal of 10 will output -10
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var neg = new Tone.Negate();
			 * var sig = new Tone.Signal(-2).connect(neg);
			 * //output of neg is positive 2. 
			 */
		    Tone.Negate = function () {
		        /**
				 *  negation is done by multiplying by -1
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._multiply = this.input = this.output = new Tone.Multiply(-1);
		    };
		    Tone.extend(Tone.Negate, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.Negate} this
			 */
		    Tone.Negate.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._multiply.dispose();
		        this._multiply = null;
		        return this;
		    };
		    return Tone.Negate;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Subtract the signal connected to <code>input[1]</code> from the signal connected 
			 *         to <code>input[0]</code>. If an argument is provided in the constructor, the 
			 *         signals <code>.value</code> will be subtracted from the incoming signal.
			 *
			 *  @extends {Tone.Signal}
			 *  @constructor
			 *  @param {number=} value The value to subtract from the incoming signal. If the value
			 *                         is omitted, it will subtract the second signal from the first.
			 *  @example
			 * var sub = new Tone.Subtract(1);
			 * var sig = new Tone.Signal(4).connect(sub);
			 * //the output of sub is 3. 
			 *  @example
			 * var sub = new Tone.Subtract();
			 * var sigA = new Tone.Signal(10);
			 * var sigB = new Tone.Signal(2.5);
			 * sigA.connect(sub, 0, 0);
			 * sigB.connect(sub, 0, 1);
			 * //output of sub is 7.5
			 */
		    Tone.Subtract = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  the summing node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._sum = this.input[0] = this.output = this.context.createGain();
		        /**
				 *  negate the input of the second input before connecting it
				 *  to the summing node.
				 *  @type {Tone.Negate}
				 *  @private
				 */
		        this._neg = new Tone.Negate();
		        /**
				 *  the node where the value is set
				 *  @private
				 *  @type {Tone.Signal}
				 */
		        this._value = this.input[1] = new Tone.Signal(value);
		        this._value.chain(this._neg, this._sum);
		    };
		    Tone.extend(Tone.Subtract, Tone.Signal);
		    /**
			 *  Clean up.
			 *  @returns {Tone.SignalBase} this
			 */
		    Tone.Subtract.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._neg.dispose();
		        this._neg = null;
		        this._sum.disconnect();
		        this._sum = null;
		        this._value.dispose();
		        this._value = null;
		        return this;
		    };
		    return Tone.Subtract;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  GreaterThanZero outputs 1 when the input is strictly greater than zero
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var gt0 = new Tone.GreaterThanZero();
			 * var sig = new Tone.Signal(0.01).connect(gt0);
			 * //the output of gt0 is 1. 
			 * sig.value = 0;
			 * //the output of gt0 is 0. 
			 */
		    Tone.GreaterThanZero = function () {
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._thresh = this.output = new Tone.WaveShaper(function (val) {
		            if (val <= 0) {
		                return 0;
		            } else {
		                return 1;
		            }
		        });
		        /**
				 *  scale the first thresholded signal by a large value.
				 *  this will help with values which are very close to 0
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = this.input = new Tone.Multiply(10000);
		        //connections
		        this._scale.connect(this._thresh);
		    };
		    Tone.extend(Tone.GreaterThanZero, Tone.SignalBase);
		    /**
			 *  dispose method
			 *  @returns {Tone.GreaterThanZero} this
			 */
		    Tone.GreaterThanZero.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._scale.dispose();
		        this._scale = null;
		        this._thresh.dispose();
		        this._thresh = null;
		        return this;
		    };
		    return Tone.GreaterThanZero;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  EqualZero outputs 1 when the input is equal to 
			 *          0 and outputs 0 otherwise. 
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var eq0 = new Tone.EqualZero();
			 * var sig = new Tone.Signal(0).connect(eq0);
			 * //the output of eq0 is 1. 
			 */
		    Tone.EqualZero = function () {
		        /**
				 *  scale the incoming signal by a large factor
				 *  @private
				 *  @type {Tone.Multiply}
				 */
		        this._scale = this.input = new Tone.Multiply(10000);
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._thresh = new Tone.WaveShaper(function (val) {
		            if (val === 0) {
		                return 1;
		            } else {
		                return 0;
		            }
		        }, 128);
		        /**
				 *  threshold the output so that it's 0 or 1
				 *  @type {Tone.GreaterThanZero}
				 *  @private
				 */
		        this._gtz = this.output = new Tone.GreaterThanZero();
		        //connections
		        this._scale.chain(this._thresh, this._gtz);
		    };
		    Tone.extend(Tone.EqualZero, Tone.SignalBase);
		    /**
			 *  Clean up.
			 *  @returns {Tone.EqualZero} this
			 */
		    Tone.EqualZero.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._gtz.dispose();
		        this._gtz = null;
		        this._scale.dispose();
		        this._scale = null;
		        this._thresh.dispose();
		        this._thresh = null;
		        return this;
		    };
		    return Tone.EqualZero;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Output 1 if the signal is equal to the value, otherwise outputs 0. 
			 *          Can accept two signals if connected to inputs 0 and 1.
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number=} value The number to compare the incoming signal to
			 *  @example
			 * var eq = new Tone.Equal(3);
			 * var sig = new Tone.Signal(3).connect(eq);
			 * //the output of eq is 1. 
			 */
		    Tone.Equal = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  subtract the value from the incoming signal
				 *  
				 *  @type {Tone.Add}
				 *  @private
				 */
		        this._sub = this.input[0] = new Tone.Subtract(value);
		        /**
				 *  @type {Tone.EqualZero}
				 *  @private
				 */
		        this._equals = this.output = new Tone.EqualZero();
		        this._sub.connect(this._equals);
		        this.input[1] = this._sub.input[1];
		    };
		    Tone.extend(Tone.Equal, Tone.SignalBase);
		    /**
			 * The value to compare to the incoming signal.
			 * @memberOf Tone.Equal#
			 * @type {number}
			 * @name value
			 */
		    Object.defineProperty(Tone.Equal.prototype, 'value', {
		        get: function () {
		            return this._sub.value;
		        },
		        set: function (value) {
		            this._sub.value = value;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.Equal} this
			 */
		    Tone.Equal.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._equals.dispose();
		        this._equals = null;
		        this._sub.dispose();
		        this._sub = null;
		        return this;
		    };
		    return Tone.Equal;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Select between any number of inputs, sending the one 
			 *         selected by the gate signal to the output
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} [sourceCount=2] the number of inputs the switch accepts
			 *  @example
			 * var sel = new Tone.Select(2);
			 * var sigA = new Tone.Signal(10).connect(sel, 0, 0);
			 * var sigB = new Tone.Signal(20).connect(sel, 0, 1);
			 * sel.gate.value = 0;
			 * //sel outputs 10 (the value of sigA);
			 * sel.gate.value = 1;
			 * //sel outputs 20 (the value of sigB);
			 */
		    Tone.Select = function (sourceCount) {
		        sourceCount = this.defaultArg(sourceCount, 2);
		        Tone.call(this, sourceCount, 1);
		        /**
				 *  the control signal
				 *  @type {Number}
				 *  @signal
				 */
		        this.gate = new Tone.Signal(0);
		        this._readOnly('gate');
		        //make all the inputs and connect them
		        for (var i = 0; i < sourceCount; i++) {
		            var switchGate = new SelectGate(i);
		            this.input[i] = switchGate;
		            this.gate.connect(switchGate.selecter);
		            switchGate.connect(this.output);
		        }
		    };
		    Tone.extend(Tone.Select, Tone.SignalBase);
		    /**
			 *  Open a specific input and close the others.
			 *  @param {number} which The gate to open. 
			 *  @param {Time} [time=now] The time when the switch will open
			 *  @returns {Tone.Select} this
			 *  @example
			 * //open input 1 in a half second from now
			 * sel.select(1, "+0.5");
			 */
		    Tone.Select.prototype.select = function (which, time) {
		        //make sure it's an integer
		        which = Math.floor(which);
		        this.gate.setValueAtTime(which, this.toSeconds(time));
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Select} this
			 */
		    Tone.Select.prototype.dispose = function () {
		        this._writable('gate');
		        this.gate.dispose();
		        this.gate = null;
		        for (var i = 0; i < this.input.length; i++) {
		            this.input[i].dispose();
		            this.input[i] = null;
		        }
		        Tone.prototype.dispose.call(this);
		        return this;
		    };
		    ////////////START HELPER////////////
		    /**
			 *  helper class for Tone.Select representing a single gate
			 *  @constructor
			 *  @extends {Tone}
			 *  @private
			 */
		    var SelectGate = function (num) {
		        /**
				 *  the selector
				 *  @type {Tone.Equal}
				 */
		        this.selecter = new Tone.Equal(num);
		        /**
				 *  the gate
				 *  @type {GainNode}
				 */
		        this.gate = this.input = this.output = this.context.createGain();
		        //connect the selecter to the gate gain
		        this.selecter.connect(this.gate.gain);
		    };
		    Tone.extend(SelectGate);
		    /**
			 *  clean up
			 *  @private
			 */
		    SelectGate.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.selecter.dispose();
		        this.gate.disconnect();
		        this.selecter = null;
		        this.gate = null;
		    };
		    ////////////END HELPER////////////
		    //return Tone.Select
		    return Tone.Select;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class IfThenElse has three inputs. When the first input (if) is true (i.e. === 1), 
			 *         then it will pass the second input (then) through to the output, otherwise, 
			 *         if it's not true (i.e. === 0) then it will pass the third input (else) 
			 *         through to the output. 
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 * var ifThenElse = new Tone.IfThenElse();
			 * var ifSignal = new Tone.Signal(1).connect(ifThenElse.if);
			 * var pwmOsc = new Tone.PWMOscillator().connect(ifThenElse.then);
			 * var pulseOsc = new Tone.PulseOscillator().connect(ifThenElse.else);
			 * //ifThenElse outputs pwmOsc
			 * signal.value = 0;
			 * //now ifThenElse outputs pulseOsc
			 */
		    Tone.IfThenElse = function () {
		        Tone.call(this, 3, 0);
		        /**
				 *  the selector node which is responsible for the routing
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._selector = this.output = new Tone.Select(2);
		        //the input mapping
		        this.if = this.input[0] = this._selector.gate;
		        this.then = this.input[1] = this._selector.input[1];
		        this.else = this.input[2] = this._selector.input[0];
		    };
		    Tone.extend(Tone.IfThenElse, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.IfThenElse} this
			 */
		    Tone.IfThenElse.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._selector.dispose();
		        this._selector = null;
		        this.if = null;
		        this.then = null;
		        this.else = null;
		        return this;
		    };
		    return Tone.IfThenElse;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class [OR](https://en.wikipedia.org/wiki/OR_gate)
			 *         the inputs together. True if at least one of the inputs is true. 
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {number} [inputCount=2] the input count
			 *  @example
			 * var or = new Tone.OR(2);
			 * var sigA = new Tone.Signal(0)connect(or, 0, 0);
			 * var sigB = new Tone.Signal(1)connect(or, 0, 1);
			 * //output of or is 1 because at least
			 * //one of the inputs is equal to 1. 
			 */
		    Tone.OR = function (inputCount) {
		        inputCount = this.defaultArg(inputCount, 2);
		        Tone.call(this, inputCount, 0);
		        /**
				 *  a private summing node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._sum = this.context.createGain();
		        /**
				 *  @type {Tone.Equal}
				 *  @private
				 */
		        this._gtz = this.output = new Tone.GreaterThanZero();
		        //make each of the inputs an alias
		        for (var i = 0; i < inputCount; i++) {
		            this.input[i] = this._sum;
		        }
		        this._sum.connect(this._gtz);
		    };
		    Tone.extend(Tone.OR, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.OR} this
			 */
		    Tone.OR.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._gtz.dispose();
		        this._gtz = null;
		        this._sum.disconnect();
		        this._sum = null;
		        return this;
		    };
		    return Tone.OR;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class [AND](https://en.wikipedia.org/wiki/Logical_conjunction)
			 *         returns 1 when all the inputs are equal to 1 and returns 0 otherwise.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {number} [inputCount=2] the number of inputs. NOTE: all inputs are
			 *                                 connected to the single AND input node
			 *  @example
			 * var and = new Tone.AND(2);
			 * var sigA = new Tone.Signal(0).connect(and, 0, 0);
			 * var sigB = new Tone.Signal(1).connect(and, 0, 1);
			 * //the output of and is 0. 
			 */
		    Tone.AND = function (inputCount) {
		        inputCount = this.defaultArg(inputCount, 2);
		        Tone.call(this, inputCount, 0);
		        /**
				 *  @type {Tone.Equal}
				 *  @private
				 */
		        this._equals = this.output = new Tone.Equal(inputCount);
		        //make each of the inputs an alias
		        for (var i = 0; i < inputCount; i++) {
		            this.input[i] = this._equals;
		        }
		    };
		    Tone.extend(Tone.AND, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.AND} this
			 */
		    Tone.AND.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._equals.dispose();
		        this._equals = null;
		        return this;
		    };
		    return Tone.AND;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Just an alias for Tone.EqualZero, but has the same effect as a NOT operator. 
			 *          Outputs 1 when input equals 0. 
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var not = new Tone.NOT();
			 * var sig = new Tone.Signal(1).connect(not);
			 * //output of not equals 0. 
			 * sig.value = 0;
			 * //output of not equals 1.
			 */
		    Tone.NOT = Tone.EqualZero;
		    return Tone.NOT;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Output 1 if the signal is greater than the value, otherwise outputs 0.
			 *          can compare two signals or a signal and a number. 
			 *  
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number} [value=0] the value to compare to the incoming signal
			 *  @example
			 * var gt = new Tone.GreaterThan(2);
			 * var sig = new Tone.Signal(4).connect(gt);
			 * //output of gt is equal 1. 
			 */
		    Tone.GreaterThan = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  subtract the amount from the incoming signal
				 *  @type {Tone.Subtract}
				 *  @private
				 */
		        this._value = this.input[0] = new Tone.Subtract(value);
		        this.input[1] = this._value.input[1];
		        /**
				 *  compare that amount to zero
				 *  @type {Tone.GreaterThanZero}
				 *  @private
				 */
		        this._gtz = this.output = new Tone.GreaterThanZero();
		        //connect
		        this._value.connect(this._gtz);
		    };
		    Tone.extend(Tone.GreaterThan, Tone.Signal);
		    /**
			 *  dispose method
			 *  @returns {Tone.GreaterThan} this
			 */
		    Tone.GreaterThan.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._value.dispose();
		        this._value = null;
		        this._gtz.dispose();
		        this._gtz = null;
		        return this;
		    };
		    return Tone.GreaterThan;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Output 1 if the signal is less than the value, otherwise outputs 0.
			 *          Can compare two signals or a signal and a number. 
			 *  
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number=} value The value to compare to the incoming signal. 
			 *                            If no value is provided, it will compare 
			 *                            <code>input[0]</code> and <code>input[1]</code>
			 *  @example
			 * var lt = new Tone.LessThan(2);
			 * var sig = new Tone.Signal(-1).connect(lt);
			 * //if (sig < 2) lt outputs 1
			 */
		    Tone.LessThan = function (value) {
		        Tone.call(this, 2, 0);
		        /**
				 *  negate the incoming signal
				 *  @type {Tone.Negate}
				 *  @private
				 */
		        this._neg = this.input[0] = new Tone.Negate();
		        /**
				 *  input < value === -input > -value
				 *  @type {Tone.GreaterThan}
				 *  @private
				 */
		        this._gt = this.output = new Tone.GreaterThan();
		        /**
				 *  negate the signal coming from the second input
				 *  @private
				 *  @type {Tone.Negate}
				 */
		        this._rhNeg = new Tone.Negate();
		        /**
				 *  the node where the value is set
				 *  @private
				 *  @type {Tone.Signal}
				 */
		        this._value = this.input[1] = new Tone.Signal(value);
		        //connect
		        this._neg.connect(this._gt);
		        this._value.connect(this._rhNeg);
		        this._rhNeg.connect(this._gt, 0, 1);
		    };
		    Tone.extend(Tone.LessThan, Tone.Signal);
		    /**
			 *  Clean up.
			 *  @returns {Tone.LessThan} this
			 */
		    Tone.LessThan.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._neg.dispose();
		        this._neg = null;
		        this._gt.dispose();
		        this._gt = null;
		        this._rhNeg.dispose();
		        this._rhNeg = null;
		        this._value.dispose();
		        this._value = null;
		        return this;
		    };
		    return Tone.LessThan;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Return the absolute value of an incoming signal. 
			 *  
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @example
			 * var signal = new Tone.Signal(-1);
			 * var abs = new Tone.Abs();
			 * signal.connect(abs);
			 * //the output of abs is 1. 
			 */
		    Tone.Abs = function () {
		        Tone.call(this, 1, 0);
		        /**
				 *  @type {Tone.LessThan}
				 *  @private
				 */
		        this._ltz = new Tone.LessThan(0);
		        /**
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._switch = this.output = new Tone.Select(2);
		        /**
				 *  @type {Tone.Negate}
				 *  @private
				 */
		        this._negate = new Tone.Negate();
		        //two signal paths, positive and negative
		        this.input.connect(this._switch, 0, 0);
		        this.input.connect(this._negate);
		        this._negate.connect(this._switch, 0, 1);
		        //the control signal
		        this.input.chain(this._ltz, this._switch.gate);
		    };
		    Tone.extend(Tone.Abs, Tone.SignalBase);
		    /**
			 *  dispose method
			 *  @returns {Tone.Abs} this
			 */
		    Tone.Abs.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._switch.dispose();
		        this._switch = null;
		        this._ltz.dispose();
		        this._ltz = null;
		        this._negate.dispose();
		        this._negate = null;
		        return this;
		    };
		    return Tone.Abs;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Outputs the greater of two signals. If a number is provided in the constructor
			 * 	        it will use that instead of the signal. 
			 * 	
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number=} max Max value if provided. if not provided, it will use the
			 *                       signal value from input 1. 
			 *  @example
			 * var max = new Tone.Max(2);
			 * var sig = new Tone.Signal(3).connect(max);
			 * //max outputs 3
			 * sig.value = 1;
			 * //max outputs 2
			 *  @example
			 * var max = new Tone.Max();
			 * var sigA = new Tone.Signal(3);
			 * var sigB = new Tone.Signal(4);
			 * sigA.connect(max, 0, 0);
			 * sigB.connect(max, 0, 1);
			 * //output of max is 4.
			 */
		    Tone.Max = function (max) {
		        Tone.call(this, 2, 0);
		        this.input[0] = this.context.createGain();
		        /**
				 *  the max signal
				 *  @type {Tone.Signal}
				 *  @private
				 */
		        this._value = this.input[1] = new Tone.Signal(max);
		        /**
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._ifThenElse = this.output = new Tone.IfThenElse();
		        /**
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._gt = new Tone.GreaterThan();
		        //connections
		        this.input[0].chain(this._gt, this._ifThenElse.if);
		        this.input[0].connect(this._ifThenElse.then);
		        this._value.connect(this._ifThenElse.else);
		        this._value.connect(this._gt, 0, 1);
		    };
		    Tone.extend(Tone.Max, Tone.Signal);
		    /**
			 * 	Clean up.
			 *  @returns {Tone.Max} this
			 */
		    Tone.Max.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._value.dispose();
		        this._ifThenElse.dispose();
		        this._gt.dispose();
		        this._value = null;
		        this._ifThenElse = null;
		        this._gt = null;
		        return this;
		    };
		    return Tone.Max;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Outputs the lesser of two signals. If a number is given 
			 * 	        in the constructor, it will use a signal and a number. 
			 * 	
			 *  @constructor
			 *  @extends {Tone.Signal}
			 *  @param {number} min The minimum to compare to the incoming signal
			 *  @example
			 * var min = new Tone.Min(2);
			 * var sig = new Tone.Signal(3).connect(min);
			 * //min outputs 2
			 * sig.value = 1;
			 * //min outputs 1
			 * 	 @example
			 * var min = new Tone.Min();
			 * var sigA = new Tone.Signal(3);
			 * var sigB = new Tone.Signal(4);
			 * sigA.connect(min, 0, 0);
			 * sigB.connect(min, 0, 1);
			 * //output of min is 3.
			 */
		    Tone.Min = function (min) {
		        Tone.call(this, 2, 0);
		        this.input[0] = this.context.createGain();
		        /**
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._ifThenElse = this.output = new Tone.IfThenElse();
		        /**
				 *  @type {Tone.Select}
				 *  @private
				 */
		        this._lt = new Tone.LessThan();
		        /**
				 *  the min signal
				 *  @type {Tone.Signal}
				 *  @private
				 */
		        this._value = this.input[1] = new Tone.Signal(min);
		        //connections
		        this.input[0].chain(this._lt, this._ifThenElse.if);
		        this.input[0].connect(this._ifThenElse.then);
		        this._value.connect(this._ifThenElse.else);
		        this._value.connect(this._lt, 0, 1);
		    };
		    Tone.extend(Tone.Min, Tone.Signal);
		    /**
			 *  clean up
			 *  @returns {Tone.Min} this
			 */
		    Tone.Min.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._value.dispose();
		        this._ifThenElse.dispose();
		        this._lt.dispose();
		        this._value = null;
		        this._ifThenElse = null;
		        this._lt = null;
		        return this;
		    };
		    return Tone.Min;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Signal-rate modulo operator. Only works in AudioRange [-1, 1] and for modulus
			 *         values in the NormalRange. 
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {NormalRange} modulus The modulus to apply.
			 *  @example
			 * var mod = new Tone.Modulo(0.2)
			 * var sig = new Tone.Signal(0.5).connect(mod);
			 * //mod outputs 0.1
			 */
		    Tone.Modulo = function (modulus) {
		        Tone.call(this, 1, 1);
		        /**
				 *  A waveshaper gets the integer multiple of 
				 *  the input signal and the modulus.
				 *  @private
				 *  @type {Tone.WaveShaper}
				 */
		        this._shaper = new Tone.WaveShaper(Math.pow(2, 16));
		        /**
				 *  the integer multiple is multiplied by the modulus
				 *  @type  {Tone.Multiply}
				 *  @private
				 */
		        this._multiply = new Tone.Multiply();
		        /**
				 *  and subtracted from the input signal
				 *  @type  {Tone.Subtract}
				 *  @private
				 */
		        this._subtract = this.output = new Tone.Subtract();
		        /**
				 *  the modulus signal
				 *  @type  {Tone.Signal}
				 *  @private
				 */
		        this._modSignal = new Tone.Signal(modulus);
		        //connections
		        this.input.fan(this._shaper, this._subtract);
		        this._modSignal.connect(this._multiply, 0, 0);
		        this._shaper.connect(this._multiply, 0, 1);
		        this._multiply.connect(this._subtract, 0, 1);
		        this._setWaveShaper(modulus);
		    };
		    Tone.extend(Tone.Modulo, Tone.SignalBase);
		    /**
			 *  @param  {number}  mod  the modulus to apply
			 *  @private
			 */
		    Tone.Modulo.prototype._setWaveShaper = function (mod) {
		        this._shaper.setMap(function (val) {
		            var multiple = Math.floor((val + 0.0001) / mod);
		            return multiple;
		        });
		    };
		    /**
			 * The modulus value.
			 * @memberOf Tone.Modulo#
			 * @type {NormalRange}
			 * @name value
			 */
		    Object.defineProperty(Tone.Modulo.prototype, 'value', {
		        get: function () {
		            return this._modSignal.value;
		        },
		        set: function (mod) {
		            this._modSignal.value = mod;
		            this._setWaveShaper(mod);
		        }
		    });
		    /**
			 * clean up
			 *  @returns {Tone.Modulo} this
			 */
		    Tone.Modulo.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._shaper.dispose();
		        this._shaper = null;
		        this._multiply.dispose();
		        this._multiply = null;
		        this._subtract.dispose();
		        this._subtract = null;
		        this._modSignal.dispose();
		        this._modSignal = null;
		        return this;
		    };
		    return Tone.Modulo;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Evaluate an expression at audio rate. <br><br>
			 *         Parsing code modified from https://code.google.com/p/tapdigit/
			 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {string} expr the expression to generate
			 *  @example
			 * //adds the signals from input[0] and input[1].
			 * var expr = new Tone.Expr("$0 + $1");
			 */
		    Tone.Expr = function () {
		        var expr = this._replacements(Array.prototype.slice.call(arguments));
		        var inputCount = this._parseInputs(expr);
		        /**
				 *  hold onto all of the nodes for disposal
				 *  @type {Array}
				 *  @private
				 */
		        this._nodes = [];
		        /**
				 *  The inputs. The length is determined by the expression. 
				 *  @type {Array}
				 */
		        this.input = new Array(inputCount);
		        //create a gain for each input
		        for (var i = 0; i < inputCount; i++) {
		            this.input[i] = this.context.createGain();
		        }
		        //parse the syntax tree
		        var tree = this._parseTree(expr);
		        //evaluate the results
		        var result;
		        try {
		            result = this._eval(tree);
		        } catch (e) {
		            this._disposeNodes();
		            throw new Error('Could evaluate expression: ' + expr);
		        }
		        /**
				 *  The output node is the result of the expression
				 *  @type {Tone}
				 */
		        this.output = result;
		    };
		    Tone.extend(Tone.Expr, Tone.SignalBase);
		    //some helpers to cut down the amount of code
		    function applyBinary(Constructor, args, self) {
		        var op = new Constructor();
		        self._eval(args[0]).connect(op, 0, 0);
		        self._eval(args[1]).connect(op, 0, 1);
		        return op;
		    }
		    function applyUnary(Constructor, args, self) {
		        var op = new Constructor();
		        self._eval(args[0]).connect(op, 0, 0);
		        return op;
		    }
		    function getNumber(arg) {
		        return arg ? parseFloat(arg) : undefined;
		    }
		    function literalNumber(arg) {
		        return arg && arg.args ? parseFloat(arg.args) : undefined;
		    }
		    /*
			 *  the Expressions that Tone.Expr can parse.
			 *
			 *  each expression belongs to a group and contains a regexp 
			 *  for selecting the operator as well as that operators method
			 *  
			 *  @type {Object}
			 *  @private
			 */
		    Tone.Expr._Expressions = {
		        //values
		        'value': {
		            'signal': {
		                regexp: /^\d+\.\d+|^\d+/,
		                method: function (arg) {
		                    var sig = new Tone.Signal(getNumber(arg));
		                    return sig;
		                }
		            },
		            'input': {
		                regexp: /^\$\d/,
		                method: function (arg, self) {
		                    return self.input[getNumber(arg.substr(1))];
		                }
		            }
		        },
		        //syntactic glue
		        'glue': {
		            '(': { regexp: /^\(/ },
		            ')': { regexp: /^\)/ },
		            ',': { regexp: /^,/ }
		        },
		        //functions
		        'func': {
		            'abs': {
		                regexp: /^abs/,
		                method: applyUnary.bind(this, Tone.Abs)
		            },
		            'min': {
		                regexp: /^min/,
		                method: applyBinary.bind(this, Tone.Min)
		            },
		            'max': {
		                regexp: /^max/,
		                method: applyBinary.bind(this, Tone.Max)
		            },
		            'if': {
		                regexp: /^if/,
		                method: function (args, self) {
		                    var op = new Tone.IfThenElse();
		                    self._eval(args[0]).connect(op.if);
		                    self._eval(args[1]).connect(op.then);
		                    self._eval(args[2]).connect(op.else);
		                    return op;
		                }
		            },
		            'gt0': {
		                regexp: /^gt0/,
		                method: applyUnary.bind(this, Tone.GreaterThanZero)
		            },
		            'eq0': {
		                regexp: /^eq0/,
		                method: applyUnary.bind(this, Tone.EqualZero)
		            },
		            'mod': {
		                regexp: /^mod/,
		                method: function (args, self) {
		                    var modulus = literalNumber(args[1]);
		                    var op = new Tone.Modulo(modulus);
		                    self._eval(args[0]).connect(op);
		                    return op;
		                }
		            },
		            'pow': {
		                regexp: /^pow/,
		                method: function (args, self) {
		                    var exp = literalNumber(args[1]);
		                    var op = new Tone.Pow(exp);
		                    self._eval(args[0]).connect(op);
		                    return op;
		                }
		            }
		        },
		        //binary expressions
		        'binary': {
		            '+': {
		                regexp: /^\+/,
		                precedence: 1,
		                method: applyBinary.bind(this, Tone.Add)
		            },
		            '-': {
		                regexp: /^\-/,
		                precedence: 1,
		                method: function (args, self) {
		                    //both unary and binary op
		                    if (args.length === 1) {
		                        return applyUnary(Tone.Negate, args, self);
		                    } else {
		                        return applyBinary(Tone.Subtract, args, self);
		                    }
		                }
		            },
		            '*': {
		                regexp: /^\*/,
		                precedence: 0,
		                method: applyBinary.bind(this, Tone.Multiply)
		            },
		            '>': {
		                regexp: /^\>/,
		                precedence: 2,
		                method: applyBinary.bind(this, Tone.GreaterThan)
		            },
		            '<': {
		                regexp: /^</,
		                precedence: 2,
		                method: applyBinary.bind(this, Tone.LessThan)
		            },
		            '==': {
		                regexp: /^==/,
		                precedence: 3,
		                method: applyBinary.bind(this, Tone.Equal)
		            },
		            '&&': {
		                regexp: /^&&/,
		                precedence: 4,
		                method: applyBinary.bind(this, Tone.AND)
		            },
		            '||': {
		                regexp: /^\|\|/,
		                precedence: 5,
		                method: applyBinary.bind(this, Tone.OR)
		            }
		        },
		        //unary expressions
		        'unary': {
		            '-': {
		                regexp: /^\-/,
		                method: applyUnary.bind(this, Tone.Negate)
		            },
		            '!': {
		                regexp: /^\!/,
		                method: applyUnary.bind(this, Tone.NOT)
		            }
		        }
		    };
		    /**
			 *  @param   {string} expr the expression string
			 *  @return  {number}      the input count
			 *  @private
			 */
		    Tone.Expr.prototype._parseInputs = function (expr) {
		        var inputArray = expr.match(/\$\d/g);
		        var inputMax = 0;
		        if (inputArray !== null) {
		            for (var i = 0; i < inputArray.length; i++) {
		                var inputNum = parseInt(inputArray[i].substr(1)) + 1;
		                inputMax = Math.max(inputMax, inputNum);
		            }
		        }
		        return inputMax;
		    };
		    /**
			 *  @param   {Array} args 	an array of arguments
			 *  @return  {string} the results of the replacements being replaced
			 *  @private
			 */
		    Tone.Expr.prototype._replacements = function (args) {
		        var expr = args.shift();
		        for (var i = 0; i < args.length; i++) {
		            expr = expr.replace(/\%/i, args[i]);
		        }
		        return expr;
		    };
		    /**
			 *  tokenize the expression based on the Expressions object
			 *  @param   {string} expr 
			 *  @return  {Object}      returns two methods on the tokenized list, next and peek
			 *  @private
			 */
		    Tone.Expr.prototype._tokenize = function (expr) {
		        var position = -1;
		        var tokens = [];
		        while (expr.length > 0) {
		            expr = expr.trim();
		            var token = getNextToken(expr);
		            tokens.push(token);
		            expr = expr.substr(token.value.length);
		        }
		        function getNextToken(expr) {
		            for (var type in Tone.Expr._Expressions) {
		                var group = Tone.Expr._Expressions[type];
		                for (var opName in group) {
		                    var op = group[opName];
		                    var reg = op.regexp;
		                    var match = expr.match(reg);
		                    if (match !== null) {
		                        return {
		                            type: type,
		                            value: match[0],
		                            method: op.method
		                        };
		                    }
		                }
		            }
		            throw new SyntaxError('Unexpected token ' + expr);
		        }
		        return {
		            next: function () {
		                return tokens[++position];
		            },
		            peek: function () {
		                return tokens[position + 1];
		            }
		        };
		    };
		    /**
			 *  recursively parse the string expression into a syntax tree
			 *  
			 *  @param   {string} expr 
			 *  @return  {Object}
			 *  @private
			 */
		    Tone.Expr.prototype._parseTree = function (expr) {
		        var lexer = this._tokenize(expr);
		        var isUndef = this.isUndef.bind(this);
		        function matchSyntax(token, syn) {
		            return !isUndef(token) && token.type === 'glue' && token.value === syn;
		        }
		        function matchGroup(token, groupName, prec) {
		            var ret = false;
		            var group = Tone.Expr._Expressions[groupName];
		            if (!isUndef(token)) {
		                for (var opName in group) {
		                    var op = group[opName];
		                    if (op.regexp.test(token.value)) {
		                        if (!isUndef(prec)) {
		                            if (op.precedence === prec) {
		                                return true;
		                            }
		                        } else {
		                            return true;
		                        }
		                    }
		                }
		            }
		            return ret;
		        }
		        function parseExpression(precedence) {
		            if (isUndef(precedence)) {
		                precedence = 5;
		            }
		            var expr;
		            if (precedence < 0) {
		                expr = parseUnary();
		            } else {
		                expr = parseExpression(precedence - 1);
		            }
		            var token = lexer.peek();
		            while (matchGroup(token, 'binary', precedence)) {
		                token = lexer.next();
		                expr = {
		                    operator: token.value,
		                    method: token.method,
		                    args: [
		                        expr,
		                        parseExpression(precedence)
		                    ]
		                };
		                token = lexer.peek();
		            }
		            return expr;
		        }
		        function parseUnary() {
		            var token, expr;
		            token = lexer.peek();
		            if (matchGroup(token, 'unary')) {
		                token = lexer.next();
		                expr = parseUnary();
		                return {
		                    operator: token.value,
		                    method: token.method,
		                    args: [expr]
		                };
		            }
		            return parsePrimary();
		        }
		        function parsePrimary() {
		            var token, expr;
		            token = lexer.peek();
		            if (isUndef(token)) {
		                throw new SyntaxError('Unexpected termination of expression');
		            }
		            if (token.type === 'func') {
		                token = lexer.next();
		                return parseFunctionCall(token);
		            }
		            if (token.type === 'value') {
		                token = lexer.next();
		                return {
		                    method: token.method,
		                    args: token.value
		                };
		            }
		            if (matchSyntax(token, '(')) {
		                lexer.next();
		                expr = parseExpression();
		                token = lexer.next();
		                if (!matchSyntax(token, ')')) {
		                    throw new SyntaxError('Expected )');
		                }
		                return expr;
		            }
		            throw new SyntaxError('Parse error, cannot process token ' + token.value);
		        }
		        function parseFunctionCall(func) {
		            var token, args = [];
		            token = lexer.next();
		            if (!matchSyntax(token, '(')) {
		                throw new SyntaxError('Expected ( in a function call "' + func.value + '"');
		            }
		            token = lexer.peek();
		            if (!matchSyntax(token, ')')) {
		                args = parseArgumentList();
		            }
		            token = lexer.next();
		            if (!matchSyntax(token, ')')) {
		                throw new SyntaxError('Expected ) in a function call "' + func.value + '"');
		            }
		            return {
		                method: func.method,
		                args: args,
		                name: name
		            };
		        }
		        function parseArgumentList() {
		            var token, expr, args = [];
		            while (true) {
		                expr = parseExpression();
		                if (isUndef(expr)) {
		                    // TODO maybe throw exception?
		                    break;
		                }
		                args.push(expr);
		                token = lexer.peek();
		                if (!matchSyntax(token, ',')) {
		                    break;
		                }
		                lexer.next();
		            }
		            return args;
		        }
		        return parseExpression();
		    };
		    /**
			 *  recursively evaluate the expression tree
			 *  @param   {Object} tree 
			 *  @return  {AudioNode}      the resulting audio node from the expression
			 *  @private
			 */
		    Tone.Expr.prototype._eval = function (tree) {
		        if (!this.isUndef(tree)) {
		            var node = tree.method(tree.args, this);
		            this._nodes.push(node);
		            return node;
		        }
		    };
		    /**
			 *  dispose all the nodes
			 *  @private
			 */
		    Tone.Expr.prototype._disposeNodes = function () {
		        for (var i = 0; i < this._nodes.length; i++) {
		            var node = this._nodes[i];
		            if (this.isFunction(node.dispose)) {
		                node.dispose();
		            } else if (this.isFunction(node.disconnect)) {
		                node.disconnect();
		            }
		            node = null;
		            this._nodes[i] = null;
		        }
		        this._nodes = null;
		    };
		    /**
			 *  clean up
			 */
		    Tone.Expr.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._disposeNodes();
		    };
		    return Tone.Expr;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Convert an incoming signal between 0, 1 to an equal power gain scale.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 * var eqPowGain = new Tone.EqualPowerGain();
			 */
		    Tone.EqualPowerGain = function () {
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._eqPower = this.input = this.output = new Tone.WaveShaper(function (val) {
		            if (Math.abs(val) < 0.001) {
		                //should output 0 when input is 0
		                return 0;
		            } else {
		                return this.equalPowerScale(val);
		            }
		        }.bind(this), 4096);
		    };
		    Tone.extend(Tone.EqualPowerGain, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.EqualPowerGain} this
			 */
		    Tone.EqualPowerGain.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._eqPower.dispose();
		        this._eqPower = null;
		        return this;
		    };
		    return Tone.EqualPowerGain;
		});
		Module(function (Tone) {
		    
		    /**
			 * @class  Tone.Crossfade provides equal power fading between two inputs. 
			 *         More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).
			 *
			 * @constructor
			 * @extends {Tone}
			 * @param {NormalRange} [initialFade=0.5]
			 * @example
			 * var crossFade = new Tone.CrossFade(0.5);
			 * //connect effect A to crossfade from
			 * //effect output 0 to crossfade input 0
			 * effectA.connect(crossFade, 0, 0);
			 * //connect effect B to crossfade from
			 * //effect output 0 to crossfade input 1
			 * effectB.connect(crossFade, 0, 1);
			 * crossFade.fade.value = 0;
			 * // ^ only effectA is output
			 * crossFade.fade.value = 1;
			 * // ^ only effectB is output
			 * crossFade.fade.value = 0.5;
			 * // ^ the two signals are mixed equally. 
			 */
		    Tone.CrossFade = function (initialFade) {
		        Tone.call(this, 2, 1);
		        /**
				 *  Alias for <code>input[0]</code>. 
				 *  @type {GainNode}
				 */
		        this.a = this.input[0] = this.context.createGain();
		        /**
				 *  Alias for <code>input[1]</code>. 
				 *  @type {GainNode}
				 */
		        this.b = this.input[1] = this.context.createGain();
		        /**
				 * 	The mix between the two inputs. A fade value of 0
				 * 	will output 100% <code>input[0]</code> and 
				 * 	a value of 1 will output 100% <code>input[1]</code>. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.fade = new Tone.Signal(this.defaultArg(initialFade, 0.5), Tone.Type.NormalRange);
		        /**
				 *  equal power gain cross fade
				 *  @private
				 *  @type {Tone.EqualPowerGain}
				 */
		        this._equalPowerA = new Tone.EqualPowerGain();
		        /**
				 *  equal power gain cross fade
				 *  @private
				 *  @type {Tone.EqualPowerGain}
				 */
		        this._equalPowerB = new Tone.EqualPowerGain();
		        /**
				 *  invert the incoming signal
				 *  @private
				 *  @type {Tone}
				 */
		        this._invert = new Tone.Expr('1 - $0');
		        //connections
		        this.a.connect(this.output);
		        this.b.connect(this.output);
		        this.fade.chain(this._equalPowerB, this.b.gain);
		        this.fade.chain(this._invert, this._equalPowerA, this.a.gain);
		        this._readOnly('fade');
		    };
		    Tone.extend(Tone.CrossFade);
		    /**
			 *  clean up
			 *  @returns {Tone.CrossFade} this
			 */
		    Tone.CrossFade.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('fade');
		        this._equalPowerA.dispose();
		        this._equalPowerA = null;
		        this._equalPowerB.dispose();
		        this._equalPowerB = null;
		        this.fade.dispose();
		        this.fade = null;
		        this._invert.dispose();
		        this._invert = null;
		        this.a.disconnect();
		        this.a = null;
		        this.b.disconnect();
		        this.b = null;
		        return this;
		    };
		    return Tone.CrossFade;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Filter is a filter which allows for all of the same native methods
			 *          as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface). 
			 *          Tone.Filter has the added ability to set the filter rolloff at -12 
			 *          (default), -24 and -48. 
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Frequency|Object} [frequency] The cutoff frequency of the filter.
			 *  @param {string=} type The type of filter.
			 *  @param {number=} rolloff The drop in decibels per octave after the cutoff frequency.
			 *                            3 choices: -12, -24, and -48
			 *  @example
			 *  var filter = new Tone.Filter(200, "highpass");
			 */
		    Tone.Filter = function () {
		        Tone.call(this);
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type',
		            'rolloff'
		        ], Tone.Filter.defaults);
		        /**
				 *  the filter(s)
				 *  @type {Array}
				 *  @private
				 */
		        this._filters = [];
		        /**
				 *  The cutoff frequency of the filter. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune parameter
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(0, Tone.Type.Cents);
		        /**
				 *  The gain of the filter, only used in certain filter types
				 *  @type {Gain}
				 *  @signal
				 */
		        this.gain = new Tone.Signal({
		            'value': options.gain,
		            'units': Tone.Type.Decibels,
		            'convert': false
		        });
		        /**
				 *  The Q or Quality of the filter
				 *  @type {Positive}
				 *  @signal
				 */
		        this.Q = new Tone.Signal(options.Q);
		        /**
				 *  the type of the filter
				 *  @type {string}
				 *  @private
				 */
		        this._type = options.type;
		        /**
				 *  the rolloff value of the filter
				 *  @type {number}
				 *  @private
				 */
		        this._rolloff = options.rolloff;
		        //set the rolloff;
		        this.rolloff = options.rolloff;
		        this._readOnly([
		            'detune',
		            'frequency',
		            'gain',
		            'Q'
		        ]);
		    };
		    Tone.extend(Tone.Filter);
		    /**
			 *  the default parameters
			 *
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Filter.defaults = {
		        'type': 'lowpass',
		        'frequency': 350,
		        'rolloff': -12,
		        'Q': 1,
		        'gain': 0
		    };
		    /**
			 * The type of the filter. Types: "lowpass", "highpass", 
			 * "bandpass", "lowshelf", "highshelf", "notch", "allpass", or "peaking". 
			 * @memberOf Tone.Filter#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.Filter.prototype, 'type', {
		        get: function () {
		            return this._type;
		        },
		        set: function (type) {
		            var types = [
		                'lowpass',
		                'highpass',
		                'bandpass',
		                'lowshelf',
		                'highshelf',
		                'notch',
		                'allpass',
		                'peaking'
		            ];
		            if (types.indexOf(type) === -1) {
		                throw new TypeError('Tone.Filter does not have filter type ' + type);
		            }
		            this._type = type;
		            for (var i = 0; i < this._filters.length; i++) {
		                this._filters[i].type = type;
		            }
		        }
		    });
		    /**
			 * The rolloff of the filter which is the drop in db
			 * per octave. Implemented internally by cascading filters.
			 * Only accepts the values -12, -24, and -48.
			 * @memberOf Tone.Filter#
			 * @type {number}
			 * @name rolloff
			 */
		    Object.defineProperty(Tone.Filter.prototype, 'rolloff', {
		        get: function () {
		            return this._rolloff;
		        },
		        set: function (rolloff) {
		            var possibilities = [
		                -12,
		                -24,
		                -48
		            ];
		            var cascadingCount = possibilities.indexOf(rolloff);
		            //check the rolloff is valid
		            if (cascadingCount === -1) {
		                throw new RangeError('Filter rolloff can only be -12, -24, or -48');
		            }
		            cascadingCount++;
		            this._rolloff = rolloff;
		            //first disconnect the filters and throw them away
		            this.input.disconnect();
		            for (var i = 0; i < this._filters.length; i++) {
		                this._filters[i].disconnect();
		                this._filters[i] = null;
		            }
		            this._filters = new Array(cascadingCount);
		            for (var count = 0; count < cascadingCount; count++) {
		                var filter = this.context.createBiquadFilter();
		                filter.type = this._type;
		                this.frequency.connect(filter.frequency);
		                this.detune.connect(filter.detune);
		                this.Q.connect(filter.Q);
		                this.gain.connect(filter.gain);
		                this._filters[count] = filter;
		            }
		            //connect them up
		            var connectionChain = [this.input].concat(this._filters).concat([this.output]);
		            this.connectSeries.apply(this, connectionChain);
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @return {Tone.Filter} this
			 */
		    Tone.Filter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        for (var i = 0; i < this._filters.length; i++) {
		            this._filters[i].disconnect();
		            this._filters[i] = null;
		        }
		        this._filters = null;
		        this._writable([
		            'detune',
		            'frequency',
		            'gain',
		            'Q'
		        ]);
		        this.frequency.dispose();
		        this.Q.dispose();
		        this.frequency = null;
		        this.Q = null;
		        this.detune.dispose();
		        this.detune = null;
		        this.gain.dispose();
		        this.gain = null;
		        return this;
		    };
		    return Tone.Filter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Split the incoming signal into three bands (low, mid, high)
			 *         with two crossover frequency controls. 
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Frequency|Object} [lowFrequency] the low/mid crossover frequency
			 *  @param {Frequency} [highFrequency] the mid/high crossover frequency
			 */
		    Tone.MultibandSplit = function () {
		        var options = this.optionsObject(arguments, [
		            'lowFrequency',
		            'highFrequency'
		        ], Tone.MultibandSplit.defaults);
		        /**
				 *  the input
				 *  @type {GainNode}
				 *  @private
				 */
		        this.input = this.context.createGain();
		        /**
				 *  the outputs
				 *  @type {Array}
				 *  @private
				 */
		        this.output = new Array(3);
		        /**
				 *  The low band. Alias for <code>output[0]</code>
				 *  @type {Tone.Filter}
				 */
		        this.low = this.output[0] = new Tone.Filter(0, 'lowpass');
		        /**
				 *  the lower filter of the mid band
				 *  @type {Tone.Filter}
				 *  @private
				 */
		        this._lowMidFilter = new Tone.Filter(0, 'highpass');
		        /**
				 *  The mid band output. Alias for <code>output[1]</code>
				 *  @type {Tone.Filter}
				 */
		        this.mid = this.output[1] = new Tone.Filter(0, 'lowpass');
		        /**
				 *  The high band output. Alias for <code>output[2]</code>
				 *  @type {Tone.Filter}
				 */
		        this.high = this.output[2] = new Tone.Filter(0, 'highpass');
		        /**
				 *  The low/mid crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.lowFrequency = new Tone.Signal(options.lowFrequency, Tone.Type.Frequency);
		        /**
				 *  The mid/high crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.highFrequency = new Tone.Signal(options.highFrequency, Tone.Type.Frequency);
		        /**
				 *  The quality of all the filters
				 *  @type {Number}
				 *  @signal
				 */
		        this.Q = new Tone.Signal(options.Q);
		        this.input.fan(this.low, this.high);
		        this.input.chain(this._lowMidFilter, this.mid);
		        //the frequency control signal
		        this.lowFrequency.connect(this.low.frequency);
		        this.lowFrequency.connect(this._lowMidFilter.frequency);
		        this.highFrequency.connect(this.mid.frequency);
		        this.highFrequency.connect(this.high.frequency);
		        //the Q value
		        this.Q.connect(this.low.Q);
		        this.Q.connect(this._lowMidFilter.Q);
		        this.Q.connect(this.mid.Q);
		        this.Q.connect(this.high.Q);
		        this._readOnly([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		    };
		    Tone.extend(Tone.MultibandSplit);
		    /**
			 *  @private
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MultibandSplit.defaults = {
		        'lowFrequency': 400,
		        'highFrequency': 2500,
		        'Q': 1
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.MultibandSplit} this
			 */
		    Tone.MultibandSplit.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		        this.low.dispose();
		        this.low = null;
		        this._lowMidFilter.dispose();
		        this._lowMidFilter = null;
		        this.mid.dispose();
		        this.mid = null;
		        this.high.dispose();
		        this.high = null;
		        this.lowFrequency.dispose();
		        this.lowFrequency = null;
		        this.highFrequency.dispose();
		        this.highFrequency = null;
		        this.Q.dispose();
		        this.Q = null;
		        return this;
		    };
		    return Tone.MultibandSplit;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.EQ3 is a three band EQ with control over low, mid, and high gain as
			 *         well as the low and high crossover frequencies.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  
			 *  @param {Decibels|Object} [lowLevel] The gain applied to the lows.
			 *  @param {Decibels} [midLevel] The gain applied to the mid.
			 *  @param {Decibels} [highLevel] The gain applied to the high.
			 *  @example
			 * var eq = new Tone.EQ3(-10, 3, -20);
			 */
		    Tone.EQ3 = function () {
		        var options = this.optionsObject(arguments, [
		            'low',
		            'mid',
		            'high'
		        ], Tone.EQ3.defaults);
		        /**
				 *  the output node
				 *  @type {GainNode}
				 *  @private
				 */
		        this.output = this.context.createGain();
		        /**
				 *  the multiband split
				 *  @type {Tone.MultibandSplit}
				 *  @private
				 */
		        this._multibandSplit = this.input = new Tone.MultibandSplit({
		            'lowFrequency': options.lowFrequency,
		            'highFrequency': options.highFrequency
		        });
		        /**
				 *  the low gain
				 *  @type {GainNode}
				 *  @private
				 */
		        this._lowGain = this.context.createGain();
		        /**
				 *  the mid gain
				 *  @type {GainNode}
				 *  @private
				 */
		        this._midGain = this.context.createGain();
		        /**
				 *  the high gain
				 *  @type {GainNode}
				 *  @private
				 */
		        this._highGain = this.context.createGain();
		        /**
				 * The gain in decibels of the low part
				 * @type {Decibels}
				 * @signal
				 */
		        this.low = new Tone.Signal(this._lowGain.gain, Tone.Type.Decibels);
		        /**
				 * The gain in decibels of the mid part
				 * @type {Decibels}
				 * @signal
				 */
		        this.mid = new Tone.Signal(this._midGain.gain, Tone.Type.Decibels);
		        /**
				 * The gain in decibels of the high part
				 * @type {Decibels}
				 * @signal
				 */
		        this.high = new Tone.Signal(this._highGain.gain, Tone.Type.Decibels);
		        /**
				 *  The Q value for all of the filters. 
				 *  @type {Positive}
				 *  @signal
				 */
		        this.Q = this._multibandSplit.Q;
		        /**
				 *  The low/mid crossover frequency. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.lowFrequency = this._multibandSplit.lowFrequency;
		        /**
				 *  The mid/high crossover frequency. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.highFrequency = this._multibandSplit.highFrequency;
		        //the frequency bands
		        this._multibandSplit.low.chain(this._lowGain, this.output);
		        this._multibandSplit.mid.chain(this._midGain, this.output);
		        this._multibandSplit.high.chain(this._highGain, this.output);
		        //set the gains
		        this.low.value = options.low;
		        this.mid.value = options.mid;
		        this.high.value = options.high;
		        this._readOnly([
		            'low',
		            'mid',
		            'high',
		            'lowFrequency',
		            'highFrequency'
		        ]);
		    };
		    Tone.extend(Tone.EQ3);
		    /**
			 *  the default values
			 */
		    Tone.EQ3.defaults = {
		        'low': 0,
		        'mid': 0,
		        'high': 0,
		        'lowFrequency': 400,
		        'highFrequency': 2500
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.EQ3} this
			 */
		    Tone.EQ3.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'low',
		            'mid',
		            'high',
		            'lowFrequency',
		            'highFrequency'
		        ]);
		        this._multibandSplit.dispose();
		        this._multibandSplit = null;
		        this.lowFrequency = null;
		        this.highFrequency = null;
		        this._lowGain.disconnect();
		        this._lowGain = null;
		        this._midGain.disconnect();
		        this._midGain = null;
		        this._highGain.disconnect();
		        this._highGain = null;
		        this.low.dispose();
		        this.low = null;
		        this.mid.dispose();
		        this.mid = null;
		        this.high.dispose();
		        this.high = null;
		        this.Q = null;
		        return this;
		    };
		    return Tone.EQ3;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Performs a linear scaling on an input signal.
			 *          Scales a NormalRange input to between
			 *          outputMin and outputMax.
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} [outputMin=0] The output value when the input is 0. 
			 *  @param {number} [outputMax=1]	The output value when the input is 1. 
			 *  @example
			 * var scale = new Tone.Scale(50, 100);
			 * var signal = new Tone.Signal(0.5).connect(scale);
			 * //the output of scale equals 75
			 */
		    Tone.Scale = function (outputMin, outputMax) {
		        /** 
				 *  @private
				 *  @type {number}
				 */
		        this._outputMin = this.defaultArg(outputMin, 0);
		        /** 
				 *  @private
				 *  @type {number}
				 */
		        this._outputMax = this.defaultArg(outputMax, 1);
		        /** 
				 *  @private
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = this.input = new Tone.Multiply(1);
		        /** 
				 *  @private
				 *  @type {Tone.Add}
				 *  @private
				 */
		        this._add = this.output = new Tone.Add(0);
		        this._scale.connect(this._add);
		        this._setRange();
		    };
		    Tone.extend(Tone.Scale, Tone.SignalBase);
		    /**
			 * The minimum output value. This number is output when 
			 * the value input value is 0. 
			 * @memberOf Tone.Scale#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.Scale.prototype, 'min', {
		        get: function () {
		            return this._outputMin;
		        },
		        set: function (min) {
		            this._outputMin = min;
		            this._setRange();
		        }
		    });
		    /**
			 * The maximum output value. This number is output when 
			 * the value input value is 1. 
			 * @memberOf Tone.Scale#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.Scale.prototype, 'max', {
		        get: function () {
		            return this._outputMax;
		        },
		        set: function (max) {
		            this._outputMax = max;
		            this._setRange();
		        }
		    });
		    /**
			 *  set the values
			 *  @private
			 */
		    Tone.Scale.prototype._setRange = function () {
		        this._add.value = this._outputMin;
		        this._scale.value = this._outputMax - this._outputMin;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Scale} this
			 */
		    Tone.Scale.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._add.dispose();
		        this._add = null;
		        this._scale.dispose();
		        this._scale = null;
		        return this;
		    };
		    return Tone.Scale;
		});
		Module(function (Tone) {
		    /**
			 *  @class  Performs an exponential scaling on an input signal.
			 *          Scales a NormalRange value [0,1] exponentially
			 *          to the output range of outputMin to outputMax.
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} [outputMin=0] The output value when the input is 0. 
			 *  @param {number} [outputMax=1]	The output value when the input is 1. 
			 *  @param {number} [exponent=2] The exponent which scales the incoming signal.
			 *  @example
			 * var scaleExp = new Tone.ScaleExp(0, 100, 2);
			 * var signal = new Tone.Signal(0.5).connect(scaleExp);
			 */
		    Tone.ScaleExp = function (outputMin, outputMax, exponent) {
		        /**
				 *  scale the input to the output range
				 *  @type {Tone.Scale}
				 *  @private
				 */
		        this._scale = this.output = new Tone.Scale(outputMin, outputMax);
		        /**
				 *  @private
				 *  @type {Tone.Pow}
				 *  @private
				 */
		        this._exp = this.input = new Tone.Pow(this.defaultArg(exponent, 2));
		        this._exp.connect(this._scale);
		    };
		    Tone.extend(Tone.ScaleExp, Tone.SignalBase);
		    /**
			 * Instead of interpolating linearly between the <code>min</code> and 
			 * <code>max</code> values, setting the exponent will interpolate between
			 * the two values with an exponential curve. 
			 * @memberOf Tone.ScaleExp#
			 * @type {number}
			 * @name exponent
			 */
		    Object.defineProperty(Tone.ScaleExp.prototype, 'exponent', {
		        get: function () {
		            return this._exp.value;
		        },
		        set: function (exp) {
		            this._exp.value = exp;
		        }
		    });
		    /**
			 * The minimum output value. This number is output when 
			 * the value input value is 0. 
			 * @memberOf Tone.ScaleExp#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.ScaleExp.prototype, 'min', {
		        get: function () {
		            return this._scale.min;
		        },
		        set: function (min) {
		            this._scale.min = min;
		        }
		    });
		    /**
			 * The maximum output value. This number is output when 
			 * the value input value is 1. 
			 * @memberOf Tone.ScaleExp#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.ScaleExp.prototype, 'max', {
		        get: function () {
		            return this._scale.max;
		        },
		        set: function (max) {
		            this._scale.max = max;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.ScaleExp} this
			 */
		    Tone.ScaleExp.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._scale.dispose();
		        this._scale = null;
		        this._exp.dispose();
		        this._exp = null;
		        return this;
		    };
		    return Tone.ScaleExp;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Comb filters are basic building blocks for physical modeling. Read more
			 *         about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Time|Object} [delayTime] The delay time of the filter. 
			 *  @param {NormalRange=} resonance The amount of feedback the filter has. 
			 */
		    Tone.FeedbackCombFilter = function () {
		        Tone.call(this);
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'resonance'
		        ], Tone.FeedbackCombFilter.defaults);
		        /**
				 *  The amount of feedback of the delayed signal. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.resonance = new Tone.Signal(options.resonance, Tone.Type.NormalRange);
		        /**
				 *  the delay node
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delay = this.input = this.output = this.context.createDelay(1);
		        /**
				 *  The amount of delay of the comb filter. 
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
		        /**
				 *  the feedback node
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedback = this.context.createGain();
		        this._delay.chain(this._feedback, this._delay);
		        this.resonance.connect(this._feedback.gain);
		        this.delayTime.connect(this._delay.delayTime);
		        this._readOnly([
		            'resonance',
		            'delayTime'
		        ]);
		    };
		    Tone.extend(Tone.FeedbackCombFilter);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.FeedbackCombFilter.defaults = {
		        'delayTime': 0.1,
		        'resonance': 0.5
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.FeedbackCombFilter} this
			 */
		    Tone.FeedbackCombFilter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'resonance',
		            'delayTime'
		        ]);
		        this._delay.disconnect();
		        this._delay = null;
		        this.delayTime.dispose();
		        this.delayTime = null;
		        this.resonance.dispose();
		        this.resonance = null;
		        this._feedback.disconnect();
		        this._feedback = null;
		        return this;
		    };
		    return Tone.FeedbackCombFilter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Follower is a  crude envelope follower which will follow 
			 *          the amplitude of an incoming signal. 
			 *          Take care with small (< 0.02) attack or decay values 
			 *          as follower has some ripple which is exaggerated
			 *          at these values. Read more about envelope followers (also known 
			 *          as envelope detectors) on [Wikipedia](https://en.wikipedia.org/wiki/Envelope_detector).
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Time|Object} [attack] The rate at which the follower rises.
			 *  @param {Time=} release The rate at which the folower falls. 
			 *  @example
			 * var follower = new Tone.Follower(0.2, 0.4);
			 */
		    Tone.Follower = function () {
		        Tone.call(this);
		        var options = this.optionsObject(arguments, [
		            'attack',
		            'release'
		        ], Tone.Follower.defaults);
		        /**
				 *  @type {Tone.Abs}
				 *  @private
				 */
		        this._abs = new Tone.Abs();
		        /**
				 *  the lowpass filter which smooths the input
				 *  @type {BiquadFilterNode}
				 *  @private
				 */
		        this._filter = this.context.createBiquadFilter();
		        this._filter.type = 'lowpass';
		        this._filter.frequency.value = 0;
		        this._filter.Q.value = -100;
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._frequencyValues = new Tone.WaveShaper();
		        /**
				 *  @type {Tone.Subtract}
				 *  @private
				 */
		        this._sub = new Tone.Subtract();
		        /**
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delay = this.context.createDelay();
		        this._delay.delayTime.value = this.bufferTime;
		        /**
				 *  this keeps it far from 0, even for very small differences
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._mult = new Tone.Multiply(10000);
		        /**
				 *  @private
				 *  @type {number}
				 */
		        this._attack = options.attack;
		        /**
				 *  @private
				 *  @type {number}
				 */
		        this._release = options.release;
		        //the smoothed signal to get the values
		        this.input.chain(this._abs, this._filter, this.output);
		        //the difference path
		        this._abs.connect(this._sub, 0, 1);
		        this._filter.chain(this._delay, this._sub);
		        //threshold the difference and use the thresh to set the frequency
		        this._sub.chain(this._mult, this._frequencyValues, this._filter.frequency);
		        //set the attack and release values in the table
		        this._setAttackRelease(this._attack, this._release);
		    };
		    Tone.extend(Tone.Follower);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Follower.defaults = {
		        'attack': 0.05,
		        'release': 0.5
		    };
		    /**
			 *  sets the attack and release times in the wave shaper
			 *  @param   {Time} attack  
			 *  @param   {Time} release 
			 *  @private
			 */
		    Tone.Follower.prototype._setAttackRelease = function (attack, release) {
		        var minTime = this.bufferTime;
		        attack = this.secondsToFrequency(this.toSeconds(attack));
		        release = this.secondsToFrequency(this.toSeconds(release));
		        attack = Math.max(attack, minTime);
		        release = Math.max(release, minTime);
		        this._frequencyValues.setMap(function (val) {
		            if (val <= 0) {
		                return attack;
		            } else {
		                return release;
		            }
		        });
		    };
		    /**
			 * The attack time.
			 * @memberOf Tone.Follower#
			 * @type {Time}
			 * @name attack
			 */
		    Object.defineProperty(Tone.Follower.prototype, 'attack', {
		        get: function () {
		            return this._attack;
		        },
		        set: function (attack) {
		            this._attack = attack;
		            this._setAttackRelease(this._attack, this._release);
		        }
		    });
		    /**
			 * The release time.
			 * @memberOf Tone.Follower#
			 * @type {Time}
			 * @name release
			 */
		    Object.defineProperty(Tone.Follower.prototype, 'release', {
		        get: function () {
		            return this._release;
		        },
		        set: function (release) {
		            this._release = release;
		            this._setAttackRelease(this._attack, this._release);
		        }
		    });
		    /**
			 *  Borrows the connect method from Signal so that the output can be used
			 *  as a Tone.Signal control signal.
			 *  @function
			 */
		    Tone.Follower.prototype.connect = Tone.Signal.prototype.connect;
		    /**
			 *  dispose
			 *  @returns {Tone.Follower} this
			 */
		    Tone.Follower.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._filter.disconnect();
		        this._filter = null;
		        this._frequencyValues.disconnect();
		        this._frequencyValues = null;
		        this._delay.disconnect();
		        this._delay = null;
		        this._sub.disconnect();
		        this._sub = null;
		        this._abs.dispose();
		        this._abs = null;
		        this._mult.dispose();
		        this._mult = null;
		        this._curve = null;
		        return this;
		    };
		    return Tone.Follower;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Gate only passes a signal through when the incoming 
			 *          signal exceeds a specified threshold. To do this, Gate uses 
			 *          a Tone.Follower to follow the amplitude of the incoming signal. 
			 *          A common implementation of this class is a [Noise Gate](https://en.wikipedia.org/wiki/Noise_gate).
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {Decibels|Object} [threshold] The threshold above which the gate will open. 
			 *  @param {Time=} attack The follower's attack time
			 *  @param {Time=} release The follower's release time
			 *  @example
			 * var gate = new Tone.Gate(-30, 0.2, 0.3).toMaster();
			 * var mic = new Tone.Microphone().connect(gate);
			 * //the gate will only pass through the incoming 
			 * //signal when it's louder than -30db
			 */
		    Tone.Gate = function () {
		        Tone.call(this);
		        var options = this.optionsObject(arguments, [
		            'threshold',
		            'attack',
		            'release'
		        ], Tone.Gate.defaults);
		        /**
				 *  @type {Tone.Follower}
				 *  @private
				 */
		        this._follower = new Tone.Follower(options.attack, options.release);
		        /**
				 *  @type {Tone.GreaterThan}
				 *  @private
				 */
		        this._gt = new Tone.GreaterThan(this.dbToGain(options.threshold));
		        //the connections
		        this.input.connect(this.output);
		        //the control signal
		        this.input.chain(this._gt, this._follower, this.output.gain);
		    };
		    Tone.extend(Tone.Gate);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Gate.defaults = {
		        'attack': 0.1,
		        'release': 0.1,
		        'threshold': -40
		    };
		    /**
			 * The threshold of the gate in decibels
			 * @memberOf Tone.Gate#
			 * @type {Decibels}
			 * @name threshold
			 */
		    Object.defineProperty(Tone.Gate.prototype, 'threshold', {
		        get: function () {
		            return this.gainToDb(this._gt.value);
		        },
		        set: function (thresh) {
		            this._gt.value = this.dbToGain(thresh);
		        }
		    });
		    /**
			 * The attack speed of the gate
			 * @memberOf Tone.Gate#
			 * @type {Time}
			 * @name attack
			 */
		    Object.defineProperty(Tone.Gate.prototype, 'attack', {
		        get: function () {
		            return this._follower.attack;
		        },
		        set: function (attackTime) {
		            this._follower.attack = attackTime;
		        }
		    });
		    /**
			 * The release speed of the gate
			 * @memberOf Tone.Gate#
			 * @type {Time}
			 * @name release
			 */
		    Object.defineProperty(Tone.Gate.prototype, 'release', {
		        get: function () {
		            return this._follower.release;
		        },
		        set: function (releaseTime) {
		            this._follower.release = releaseTime;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Gate} this
			 */
		    Tone.Gate.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._follower.dispose();
		        this._gt.dispose();
		        this._follower = null;
		        this._gt = null;
		        return this;
		    };
		    return Tone.Gate;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A sample accurate clock which provides a callback at the given rate. 
			 *          While the callback is not sample-accurate (it is still susceptible to
			 *          loose JS timing), the time passed in as the argument to the callback
			 *          is precise. For most applications, it is better to use Tone.Transport
			 *          instead of the clock. 
			 *
			 * 	@constructor
			 * 	@extends {Tone}
			 * 	@param {Frequency} frequency The rate of the callback
			 * 	@param {function} callback The callback to be invoked with the time of the audio event
			 * 	@example
			 * //the callback will be invoked approximately once a second
			 * //and will print the time exactly once a second apart.
			 * var clock = new Tone.Clock(1, function(time){
			 * 	console.log(time);
			 * });
			 */
		    Tone.Clock = function (frequency, callback) {
		        /**
				 *  the oscillator
				 *  @type {OscillatorNode}
				 *  @private
				 */
		        this._oscillator = null;
		        /**
				 *  the script processor which listens to the oscillator
				 *  @type {ScriptProcessorNode}
				 *  @private
				 */
		        this._jsNode = this.context.createScriptProcessor(this.bufferSize, 1, 1);
		        this._jsNode.onaudioprocess = this._processBuffer.bind(this);
		        /**
				 *  The frequency in which the callback will be invoked.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(frequency, Tone.Type.Frequency);
		        /**
				 *  whether the tick is on the up or down
				 *  @type {boolean}
				 *  @private
				 */
		        this._upTick = false;
		        /**
				 *  The callback which is invoked on every tick
				 *  with the time of that tick as the argument
				 *  @type {function(number)}
				 */
		        this.tick = callback;
		        /**
				 * Callback is invoked when the clock is stopped.
				 * @type {function}
				 * @example
				 * clock.onended = function(){
				 * 	console.log("the clock is stopped");
				 * }
				 */
		        this.onended = Tone.noOp;
		        //setup
		        this._jsNode.noGC();
		    };
		    Tone.extend(Tone.Clock);
		    /**
			 *  Start the clock.
			 *  @param {Time} [time=now] the time when the clock should start
			 *  @returns {Tone.Clock} this
			 *  @example
			 * clock.start();
			 */
		    Tone.Clock.prototype.start = function (time) {
		        if (!this._oscillator) {
		            this._oscillator = this.context.createOscillator();
		            this._oscillator.type = 'square';
		            this._oscillator.connect(this._jsNode);
		            //connect it up
		            this.frequency.connect(this._oscillator.frequency);
		            this._upTick = false;
		            var startTime = this.toSeconds(time);
		            this._oscillator.start(startTime);
		        }
		        return this;
		    };
		    /**
			 *  Stop the clock.
			 *  @param {Time} [time=now] The time when the clock should stop.
			 *  @returns {Tone.Clock} this
			 *  @example
			 * clock.stop();
			 */
		    Tone.Clock.prototype.stop = function (time) {
		        if (this._oscillator) {
		            var now = this.now();
		            var stopTime = this.toSeconds(time, now);
		            this._oscillator.stop(stopTime);
		            this._oscillator = null;
		            if (time) {
		                //set a timeout for when it stops
		                setTimeout(this.onended, (stopTime - now) * 1000);
		            } else {
		                this.onended();
		            }
		        }
		        return this;
		    };
		    /**
			 *  @private
			 *  @param  {AudioProcessingEvent} event
			 */
		    Tone.Clock.prototype._processBuffer = function (event) {
		        var now = this.defaultArg(event.playbackTime, this.now());
		        var bufferSize = this._jsNode.bufferSize;
		        var incomingBuffer = event.inputBuffer.getChannelData(0);
		        var upTick = this._upTick;
		        var self = this;
		        for (var i = 0; i < bufferSize; i++) {
		            var sample = incomingBuffer[i];
		            if (sample > 0 && !upTick) {
		                upTick = true;
		                //get the callback out of audio thread
		                setTimeout(function () {
		                    //to account for the double buffering
		                    var tickTime = now + self.samplesToSeconds(i + bufferSize * 2);
		                    return function () {
		                        if (self.tick) {
		                            self.tick(tickTime);
		                        }
		                    };
		                }(), 0);    // jshint ignore:line
		            } else if (sample < 0 && upTick) {
		                upTick = false;
		            }
		        }
		        this._upTick = upTick;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Clock} this
			 */
		    Tone.Clock.prototype.dispose = function () {
		        this._jsNode.disconnect();
		        this.frequency.dispose();
		        this.frequency = null;
		        if (this._oscillator) {
		            this._oscillator.disconnect();
		            this._oscillator = null;
		        }
		        this._jsNode.onaudioprocess = Tone.noOp;
		        this._jsNode = null;
		        this.tick = null;
		        this.onended = Tone.noOp;
		        return this;
		    };
		    return Tone.Clock;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Oscillator-based transport allows for timing musical events.
			 *          Supports tempo curves and time changes. A single transport is created
			 *          on initialization. Unlike browser-based timing (setInterval, requestAnimationFrame)
			 *          Tone.Transport timing events pass in the exact time of the scheduled event
			 *          in the argument of the callback function. Pass that time value to the object
			 *          you're scheduling. <br><br>
			 *          A single transport is created for you when the library is initialized. 
			 *
			 *  @extends {Tone}
			 *  @singleton
			 *  @example
			 * //repeated event every 8th note
			 * Tone.Transport.setInterval(function(time){
			 * 	//do something with the time
			 * }, "8n");
			 *  @example
			 * //one time event 1 second in the future
			 * Tone.Transport.setTimeout(function(time){
			 * 	//do something with the time
			 * }, 1);
			 *  @example
			 * //event fixed to the Transports timeline. 
			 * Tone.Transport.setTimeline(function(time){
			 * 	//do something with the time
			 * }, "16:0:0");
			 */
		    Tone.Transport = function () {
		        /**
				 *  watches the main oscillator for timing ticks
				 *  initially starts at 120bpm
				 *  
				 *  @private
				 *  @type {Tone.Clock}
				 */
		        this._clock = new Tone.Clock(0, this._processTick.bind(this));
		        this._clock.onended = this._onended.bind(this);
		        /** 
				 * 	If the transport loops or not.
				 *  @type {boolean}
				 */
		        this.loop = false;
		        /**
				 *  The Beats Per Minute of the Transport. 
				 *  @type {BPM}
				 *  @signal
				 *  @example
				 * Tone.Transport.bpm.value = 80;
				 * //ramp the bpm to 120 over 10 seconds
				 * Tone.Transport.bpm.rampTo(120, 10);
				 */
		        this.bpm = new Tone.Signal(120, Tone.Type.BPM);
		        /**
				 *  the signal scalar
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._bpmMult = new Tone.Multiply(1 / 60 * tatum);
		        /**
				 * 	The state of the transport. READ ONLY. 
				 *  @type {Tone.State}
				 */
		        this.state = Tone.State.Stopped;
		        //connect it all up
		        this.bpm.chain(this._bpmMult, this._clock.frequency);
		    };
		    Tone.extend(Tone.Transport);
		    /**
			 *  the defaults
			 *  @type {Object}
			 *  @const
			 *  @static
			 */
		    Tone.Transport.defaults = {
		        'bpm': 120,
		        'swing': 0,
		        'swingSubdivision': '16n',
		        'timeSignature': 4,
		        'loopStart': 0,
		        'loopEnd': '4m'
		    };
		    /** 
			 * @private
			 * @type {number}
			 */
		    var tatum = 12;
		    /** 
			 * @private 
			 * @type {number} 
			 */
		    var timelineTicks = 0;
		    /** 
			 * @private 
			 * @type {number} 
			 */
		    var transportTicks = 0;
		    /**
			 *  Which subdivision the swing is applied to.
			 *  defaults to an 16th note
			 *  @private
			 *  @type {number}
			 */
		    var swingSubdivision = '16n';
		    /**
			 *  controls which beat the swing is applied to
			 *  defaults to an 16th note
			 *  @private
			 *  @type {number}
			 */
		    var swingTatum = 3;
		    /**
			 *  controls which beat the swing is applied to
			 *  @private
			 *  @type {number}
			 */
		    var swingAmount = 0;
		    /** 
			 * @private
			 * @type {number}
			 */
		    var transportTimeSignature = 4;
		    /** 
			 * @private
			 * @type {number}
			 */
		    var loopStart = 0;
		    /** 
			 * @private
			 * @type {number}
			 */
		    var loopEnd = tatum * 4;
		    /** 
			 * @private
			 * @type {Array}
			 */
		    var intervals = [];
		    /** 
			 * @private
			 * @type {Array}
			 */
		    var timeouts = [];
		    /** 
			 * @private
			 * @type {Array}
			 */
		    var transportTimeline = [];
		    /** 
			 * @private
			 * @type {number}
			 */
		    var timelineProgress = 0;
		    /** 
			 *  All of the synced components
			 *  @private 
			 *  @type {Array}
			 */
		    var SyncedSources = [];
		    /** 
			 *  All of the synced Signals
			 *  @private 
			 *  @type {Array}
			 */
		    var SyncedSignals = [];
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TICKS
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  called on every tick
			 *  @param   {number} tickTime clock relative tick time
			 *  @private
			 */
		    Tone.Transport.prototype._processTick = function (tickTime) {
		        if (this.state === Tone.State.Started) {
		            if (swingAmount > 0 && timelineTicks % tatum !== 0 && //not on a downbeat
		                timelineTicks % swingTatum === 0) {
		                //add some swing
		                tickTime += this._ticksToSeconds(swingTatum) * swingAmount;
		            }
		            processIntervals(tickTime);
		            processTimeouts(tickTime);
		            processTimeline(tickTime);
		            transportTicks += 1;
		            timelineTicks += 1;
		            if (this.loop) {
		                if (timelineTicks === loopEnd) {
		                    this._setTicks(loopStart);
		                }
		            }
		        }
		    };
		    /**
			 *  jump to a specific tick in the timeline
			 *  updates the timeline callbacks
			 *  
			 *  @param   {number} ticks the tick to jump to
			 *  @private
			 */
		    Tone.Transport.prototype._setTicks = function (ticks) {
		        timelineTicks = ticks;
		        for (var i = 0; i < transportTimeline.length; i++) {
		            var timeout = transportTimeline[i];
		            if (timeout.callbackTick() >= ticks) {
		                timelineProgress = i;
		                break;
		            }
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	EVENT PROCESSING
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  process the intervals
			 *  @param  {number} time 
			 */
		    var processIntervals = function (time) {
		        for (var i = 0, len = intervals.length; i < len; i++) {
		            var interval = intervals[i];
		            if (interval.testInterval(transportTicks)) {
		                interval.doCallback(time);
		            }
		        }
		    };
		    /**
			 *  process the timeouts
			 *  @param  {number} time 
			 */
		    var processTimeouts = function (time) {
		        var removeTimeouts = 0;
		        for (var i = 0, len = timeouts.length; i < len; i++) {
		            var timeout = timeouts[i];
		            var callbackTick = timeout.callbackTick();
		            if (callbackTick <= transportTicks) {
		                timeout.doCallback(time);
		                removeTimeouts++;
		            } else if (callbackTick > transportTicks) {
		                break;
		            }
		        }
		        //remove the timeouts off the front of the array after they've been called
		        timeouts.splice(0, removeTimeouts);
		    };
		    /**
			 *  process the transportTimeline events
			 *  @param  {number} time 
			 */
		    var processTimeline = function (time) {
		        for (var i = timelineProgress, len = transportTimeline.length; i < len; i++) {
		            var evnt = transportTimeline[i];
		            var callbackTick = evnt.callbackTick();
		            if (callbackTick === timelineTicks) {
		                timelineProgress = i;
		                evnt.doCallback(time);
		            } else if (callbackTick > timelineTicks) {
		                break;
		            }
		        }
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	INTERVAL
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Set a callback for a recurring event.
			 *  @param {function} callback
			 *  @param {Time}   interval 
			 *  @return {number} the id of the interval
			 *  @example
			 *  //triggers a callback every 8th note with the exact time of the event
			 *  Tone.Transport.setInterval(function(time){
			 *  	envelope.triggerAttack(time);
			 *  }, "8n");
			 */
		    Tone.Transport.prototype.setInterval = function (callback, interval, ctx) {
		        var tickTime = this._toTicks(interval);
		        var timeout = new TimelineEvent(callback, ctx, tickTime, transportTicks);
		        intervals.push(timeout);
		        return timeout.id;
		    };
		    /**
			 *  Stop and ongoing interval.
			 *  @param  {number} intervalID  The ID of interval to remove. The interval
			 *                               ID is given as the return value in Tone.Transport.setInterval.
			 *  @return {boolean}            	true if the event was removed
			 */
		    Tone.Transport.prototype.clearInterval = function (rmInterval) {
		        for (var i = 0; i < intervals.length; i++) {
		            var interval = intervals[i];
		            if (interval.id === rmInterval) {
		                intervals.splice(i, 1);
		                return true;
		            }
		        }
		        return false;
		    };
		    /**
			 *  Removes all of the intervals that are currently set. 
			 *  @return {boolean}            	true if the event was removed
			 */
		    Tone.Transport.prototype.clearIntervals = function () {
		        var willRemove = intervals.length > 0;
		        intervals = [];
		        return willRemove;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TIMEOUT
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Set a timeout to occur after time from now. NB: the transport must be 
			 *  running for this to be triggered. All timeout events are cleared when the 
			 *  transport is stopped. 
			 *
			 *  @param {function} callback 
			 *  @param {Time}   time    The time (from now) that the callback will be invoked.
			 *  @return {number} The id of the timeout.
			 *  @example
			 *  //trigger an event to happen 1 second from now
			 *  Tone.Transport.setTimeout(function(time){
			 *  	player.start(time);
			 *  }, 1)
			 */
		    Tone.Transport.prototype.setTimeout = function (callback, time, ctx) {
		        var ticks = this._toTicks(time);
		        var timeout = new TimelineEvent(callback, ctx, ticks + transportTicks, 0);
		        //put it in the right spot
		        for (var i = 0, len = timeouts.length; i < len; i++) {
		            var testEvnt = timeouts[i];
		            if (testEvnt.callbackTick() > timeout.callbackTick()) {
		                timeouts.splice(i, 0, timeout);
		                return timeout.id;
		            }
		        }
		        //otherwise push it on the end
		        timeouts.push(timeout);
		        return timeout.id;
		    };
		    /**
			 *  Clear a timeout using it's ID.
			 *  @param  {number} intervalID  The ID of timeout to remove. The timeout
			 *                               ID is given as the return value in Tone.Transport.setTimeout.
			 *  @return {boolean}           true if the timeout was removed
			 */
		    Tone.Transport.prototype.clearTimeout = function (timeoutID) {
		        for (var i = 0; i < timeouts.length; i++) {
		            var testTimeout = timeouts[i];
		            if (testTimeout.id === timeoutID) {
		                timeouts.splice(i, 1);
		                return true;
		            }
		        }
		        return false;
		    };
		    /**
			 *  Removes all of the timeouts that are currently set. 
			 *  @return {boolean}            	true if the event was removed
			 */
		    Tone.Transport.prototype.clearTimeouts = function () {
		        var willRemove = timeouts.length > 0;
		        timeouts = [];
		        return willRemove;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TIMELINE
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Timeline events are synced to the timeline of the Tone.Transport.
			 *  Unlike Timeout, Timeline events will restart after the 
			 *  Tone.Transport has been stopped and restarted. 
			 *
			 *  @param {function} 	callback 	
			 *  @param {Tome.Time}  timeout  
			 *  @return {number} 				the id for clearing the transportTimeline event
			 *  @example
			 *  //trigger the start of a part on the 16th measure
			 *  Tone.Transport.setTimeline(function(time){
			 *  	part.start(time);
			 *  }, "16m");
			 */
		    Tone.Transport.prototype.setTimeline = function (callback, timeout, ctx) {
		        var ticks = this._toTicks(timeout);
		        var timelineEvnt = new TimelineEvent(callback, ctx, ticks, 0);
		        //put it in the right spot
		        for (var i = timelineProgress, len = transportTimeline.length; i < len; i++) {
		            var testEvnt = transportTimeline[i];
		            if (testEvnt.callbackTick() > timelineEvnt.callbackTick()) {
		                transportTimeline.splice(i, 0, timelineEvnt);
		                return timelineEvnt.id;
		            }
		        }
		        //otherwise push it on the end
		        transportTimeline.push(timelineEvnt);
		        return timelineEvnt.id;
		    };
		    /**
			 *  Clear the timeline event.
			 *  @param  {number} timelineID 
			 *  @return {boolean} true if it was removed
			 */
		    Tone.Transport.prototype.clearTimeline = function (timelineID) {
		        for (var i = 0; i < transportTimeline.length; i++) {
		            var testTimeline = transportTimeline[i];
		            if (testTimeline.id === timelineID) {
		                transportTimeline.splice(i, 1);
		                return true;
		            }
		        }
		        return false;
		    };
		    /**
			 *  Remove all events from the timeline.
			 *  @returns {boolean} true if the events were removed
			 */
		    Tone.Transport.prototype.clearTimelines = function () {
		        timelineProgress = 0;
		        var willRemove = transportTimeline.length > 0;
		        transportTimeline = [];
		        return willRemove;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TIME CONVERSIONS
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  turns the time into
			 *  @param  {Time} time
			 *  @return {number}   
			 *  @private   
			 */
		    Tone.Transport.prototype._toTicks = function (time) {
		        //get the seconds
		        var seconds = this.toSeconds(time);
		        var quarter = this.notationToSeconds('4n');
		        var quarters = seconds / quarter;
		        var tickNum = quarters * tatum;
		        //quantize to tick value
		        return Math.round(tickNum);
		    };
		    /**
			 *  convert ticks into seconds
			 *  
			 *  @param  {number} ticks 
			 *  @param {number=} bpm 
			 *  @param {number=} timeSignature
			 *  @return {number}               seconds
			 *  @private
			 */
		    Tone.Transport.prototype._ticksToSeconds = function (ticks, bpm, timeSignature) {
		        ticks = Math.floor(ticks);
		        var quater = this.notationToSeconds('4n', bpm, timeSignature);
		        return quater * ticks / tatum;
		    };
		    /**
			 *  Returns the time of the next beat.
			 *  @param  {string} [subdivision="4n"]
			 *  @return {number} 	the time in seconds of the next subdivision
			 */
		    Tone.Transport.prototype.nextBeat = function (subdivision) {
		        subdivision = this.defaultArg(subdivision, '4n');
		        var tickNum = this._toTicks(subdivision);
		        var remainingTicks = transportTicks % tickNum;
		        var nextTick = remainingTicks;
		        if (remainingTicks > 0) {
		            nextTick = tickNum - remainingTicks;
		        }
		        return this._ticksToSeconds(nextTick);
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	START/STOP/PAUSE
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Start the transport and all sources synced to the transport.
			 *  @param  {Time} [time=now] The time when the transport should start.
			 *  @param  {Time=} offset The timeline offset to start the transport.
			 *  @returns {Tone.Transport} this
			 *  @example
			 * //start the transport in one second starting at beginning of the 5th measure. 
			 * Tone.Transport.start("+1", "4:0:0");
			 */
		    Tone.Transport.prototype.start = function (time, offset) {
		        if (this.state === Tone.State.Stopped || this.state === Tone.State.Paused) {
		            if (!this.isUndef(offset)) {
		                this._setTicks(this._toTicks(offset));
		            }
		            this.state = Tone.State.Started;
		            var startTime = this.toSeconds(time);
		            this._clock.start(startTime);
		            //call start on each of the synced sources
		            for (var i = 0; i < SyncedSources.length; i++) {
		                var source = SyncedSources[i].source;
		                var delay = SyncedSources[i].delay;
		                source.start(startTime + delay);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Stop the transport and all sources synced to the transport.
			 *  @param  {Time} [time=now] The time when the transport should stop. 
			 *  @returns {Tone.Transport} this
			 *  @example
			 * Tone.Transport.stop();
			 */
		    Tone.Transport.prototype.stop = function (time) {
		        if (this.state === Tone.State.Started || this.state === Tone.State.Paused) {
		            var stopTime = this.toSeconds(time);
		            this._clock.stop(stopTime);
		            //call start on each of the synced sources
		            for (var i = 0; i < SyncedSources.length; i++) {
		                var source = SyncedSources[i].source;
		                source.stop(stopTime);
		            }
		        } else {
		            this._onended();
		        }
		        return this;
		    };
		    /**
			 *  invoked when the transport is stopped
			 *  @private
			 */
		    Tone.Transport.prototype._onended = function () {
		        transportTicks = 0;
		        this._setTicks(0);
		        this.clearTimeouts();
		        this.state = Tone.State.Stopped;
		    };
		    /**
			 *  Pause the transport and all sources synced to the transport.
			 *  @param  {Time} [time=now]
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.pause = function (time) {
		        if (this.state === Tone.State.Started) {
		            this.state = Tone.State.Paused;
		            var stopTime = this.toSeconds(time);
		            this._clock.stop(stopTime);
		            //call pause on each of the synced sources
		            for (var i = 0; i < SyncedSources.length; i++) {
		                var source = SyncedSources[i].source;
		                source.pause(stopTime);
		            }
		        }
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	SETTERS/GETTERS
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  The time signature as just the numerator over 4. 
			 *  For example 4/4 would be just 4 and 6/8 would be 3.
			 *  @memberOf Tone.Transport#
			 *  @type {number}
			 *  @name timeSignature
			 *  @example
			 * //common time
			 * Tone.Transport.timeSignature = 4;
			 * // 7/8
			 * Tone.Transport.timeSignature = 3.5;
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'timeSignature', {
		        get: function () {
		            return transportTimeSignature;
		        },
		        set: function (numerator) {
		            transportTimeSignature = numerator;
		        }
		    });
		    /**
			 * When the Tone.Transport.loop = true, this is the starting position of the loop.
			 * @memberOf Tone.Transport#
			 * @type {Time}
			 * @name loopStart
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'loopStart', {
		        get: function () {
		            return this._ticksToSeconds(loopStart);
		        },
		        set: function (startPosition) {
		            loopStart = this._toTicks(startPosition);
		        }
		    });
		    /**
			 * When the Tone.Transport.loop = true, this is the ending position of the loop.
			 * @memberOf Tone.Transport#
			 * @type {Time}
			 * @name loopEnd
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'loopEnd', {
		        get: function () {
		            return this._ticksToSeconds(loopEnd);
		        },
		        set: function (endPosition) {
		            loopEnd = this._toTicks(endPosition);
		        }
		    });
		    /**
			 *  Set the loop start and stop at the same time. 
			 *  @param {Time} startPosition 
			 *  @param {Time} endPosition   
			 *  @returns {Tone.Transport} this
			 *  @example
			 * //loop over the first measure
			 * Tone.Transport.setLoopPoints(0, "1m");
			 * Tone.Transport.loop = true;
			 */
		    Tone.Transport.prototype.setLoopPoints = function (startPosition, endPosition) {
		        this.loopStart = startPosition;
		        this.loopEnd = endPosition;
		        return this;
		    };
		    /**
			 *  The swing value. Between 0-1 where 1 equal to 
			 *  the note + half the subdivision.
			 *  @memberOf Tone.Transport#
			 *  @type {NormalRange}
			 *  @name swing
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'swing', {
		        get: function () {
		            return swingAmount * 2;
		        },
		        set: function (amount) {
		            //scale the values to a normal range
		            swingAmount = amount * 0.5;
		        }
		    });
		    /**
			 *  Set the subdivision which the swing will be applied to. 
			 *  The default values is a 16th note. Value must be less 
			 *  than a quarter note.
			 *  
			 *  @memberOf Tone.Transport#
			 *  @type {Time}
			 *  @name swingSubdivision
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'swingSubdivision', {
		        get: function () {
		            return swingSubdivision;
		        },
		        set: function (subdivision) {
		            //scale the values to a normal range
		            swingSubdivision = subdivision;
		            swingTatum = this._toTicks(subdivision);
		        }
		    });
		    /**
			 *  The Transport's position in MEASURES:BEATS:SIXTEENTHS.
			 *  Setting the value will jump to that position right away. 
			 *  
			 *  @memberOf Tone.Transport#
			 *  @type {TransportTime}
			 *  @name position
			 */
		    Object.defineProperty(Tone.Transport.prototype, 'position', {
		        get: function () {
		            var quarters = timelineTicks / tatum;
		            var measures = Math.floor(quarters / transportTimeSignature);
		            var sixteenths = Math.floor(quarters % 1 * 4);
		            quarters = Math.floor(quarters) % transportTimeSignature;
		            var progress = [
		                measures,
		                quarters,
		                sixteenths
		            ];
		            return progress.join(':');
		        },
		        set: function (progress) {
		            var ticks = this._toTicks(progress);
		            this._setTicks(ticks);
		        }
		    });
		    ///////////////////////////////////////////////////////////////////////////////
		    //	SYNCING
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  Sync a source to the transport so that 
			 *  @param  {Tone.Source} source the source to sync to the transport
			 *  @param {Time} delay (optionally) start the source with a delay from the transport
			 *  @returns {Tone.Transport} this
			 *  @example
			 * Tone.Transport.syncSource(player, "1m");
			 * Tone.Transport.start();
			 * //the player will start 1 measure after the transport starts
			 */
		    Tone.Transport.prototype.syncSource = function (source, startDelay) {
		        SyncedSources.push({
		            source: source,
		            delay: this.toSeconds(this.defaultArg(startDelay, 0))
		        });
		        return this;
		    };
		    /**
			 *  Unsync the source from the transport. See Tone.Transport.syncSource. 
			 *  
			 *  @param  {Tone.Source} source [description]
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.unsyncSource = function (source) {
		        for (var i = 0; i < SyncedSources.length; i++) {
		            if (SyncedSources[i].source === source) {
		                SyncedSources.splice(i, 1);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Attaches the signal to the tempo control signal so that 
			 *  any changes in the tempo will change the signal in the same
			 *  ratio. 
			 *  
			 *  @param  {Tone.Signal} signal 
			 *  @param {number=} ratio Optionally pass in the ratio between
			 *                         the two signals. Otherwise it will be computed
			 *                         based on their current values. 
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.syncSignal = function (signal, ratio) {
		        if (!ratio) {
		            //get the sync ratio
		            if (signal._value.value !== 0) {
		                ratio = signal._value.value / this.bpm.value;
		            } else {
		                ratio = 0;
		            }
		        }
		        var ratioSignal = this.context.createGain();
		        ratioSignal.gain.value = ratio;
		        this.bpm.chain(ratioSignal, signal._value);
		        SyncedSignals.push({
		            'ratio': ratioSignal,
		            'signal': signal,
		            'initial': signal._value.value
		        });
		        signal._value.value = 0;
		        return this;
		    };
		    /**
			 *  Unsyncs a previously synced signal from the transport's control. 
			 *  See Tone.Transport.syncSignal.
			 *  @param  {Tone.Signal} signal 
			 *  @returns {Tone.Transport} this
			 */
		    Tone.Transport.prototype.unsyncSignal = function (signal) {
		        for (var i = 0; i < SyncedSignals.length; i++) {
		            var syncedSignal = SyncedSignals[i];
		            if (syncedSignal.signal === signal) {
		                syncedSignal.ratio.disconnect();
		                syncedSignal.signal._value.value = syncedSignal.initial;
		                SyncedSignals.splice(i, 1);
		            }
		        }
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Transport} this
			 *  @private
			 */
		    Tone.Transport.prototype.dispose = function () {
		        this._clock.dispose();
		        this._clock = null;
		        this.bpm.dispose();
		        this.bpm = null;
		        this._bpmMult.dispose();
		        this._bpmMult = null;
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	TIMELINE EVENT
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  @static
			 *  @type {number}
			 */
		    var TimelineEventIDCounter = 0;
		    /**
			 *  A Timeline event
			 *
			 *  @constructor
			 *  @private
			 *  @param {function(number)} callback   
			 *  @param {Object}   context    
			 *  @param {number}   tickTime
		 	 *  @param {number}   startTicks
			 */
		    var TimelineEvent = function (callback, context, tickTime, startTicks) {
		        this.startTicks = startTicks;
		        this.tickTime = tickTime;
		        this.callback = callback;
		        this.context = context;
		        this.id = TimelineEventIDCounter++;
		    };
		    /**
			 *  invoke the callback in the correct context
			 *  passes in the playback time
			 *  
			 *  @param  {number} playbackTime 
			 */
		    TimelineEvent.prototype.doCallback = function (playbackTime) {
		        this.callback.call(this.context, playbackTime);
		    };
		    /**
			 *  get the tick which the callback is supposed to occur on
			 *  
			 *  @return {number} 
			 */
		    TimelineEvent.prototype.callbackTick = function () {
		        return this.startTicks + this.tickTime;
		    };
		    /**
			 *  test if the tick occurs on the interval
			 *  
			 *  @param  {number} tick 
			 *  @return {boolean}      
			 */
		    TimelineEvent.prototype.testInterval = function (tick) {
		        return (tick - this.startTicks) % this.tickTime === 0;
		    };
		    ///////////////////////////////////////////////////////////////////////////////
		    //	AUGMENT TONE'S PROTOTYPE TO INCLUDE TRANSPORT TIMING
		    ///////////////////////////////////////////////////////////////////////////////
		    /**
			 *  tests if a string is musical notation
			 *  i.e.:
			 *  	4n = quarter note
			 *   	2m = two measures
			 *    	8t = eighth-note triplet
			 *  
			 *  @return {boolean} 
			 *  @method isNotation
			 *  @lends Tone.prototype.isNotation
			 */
		    Tone.prototype.isNotation = function () {
		        var notationFormat = new RegExp(/[0-9]+[mnt]$/i);
		        return function (note) {
		            return notationFormat.test(note);
		        };
		    }();
		    /**
			 *  tests if a string is transportTime
			 *  i.e. :
			 *  	1:2:0 = 1 measure + two quarter notes + 0 sixteenth notes
			 *  	
			 *  @return {boolean} 
			 *
			 *  @method isTransportTime
			 *  @lends Tone.prototype.isTransportTime
			 */
		    Tone.prototype.isTransportTime = function () {
		        var transportTimeFormat = new RegExp(/^\d+(\.\d+)?:\d+(\.\d+)?(:\d+(\.\d+)?)?$/i);
		        return function (transportTime) {
		            return transportTimeFormat.test(transportTime);
		        };
		    }();
		    /**
			 *
			 *  convert notation format strings to seconds
			 *  
			 *  @param  {string} notation     
			 *  @param {number=} bpm 
			 *  @param {number=} timeSignature 
			 *  @return {number} 
			 *                
			 */
		    Tone.prototype.notationToSeconds = function (notation, bpm, timeSignature) {
		        bpm = this.defaultArg(bpm, Tone.Transport.bpm.value);
		        timeSignature = this.defaultArg(timeSignature, transportTimeSignature);
		        var beatTime = 60 / bpm;
		        var subdivision = parseInt(notation, 10);
		        var beats = 0;
		        if (subdivision === 0) {
		            beats = 0;
		        }
		        var lastLetter = notation.slice(-1);
		        if (lastLetter === 't') {
		            beats = 4 / subdivision * 2 / 3;
		        } else if (lastLetter === 'n') {
		            beats = 4 / subdivision;
		        } else if (lastLetter === 'm') {
		            beats = subdivision * timeSignature;
		        } else {
		            beats = 0;
		        }
		        return beatTime * beats;
		    };
		    /**
			 *  convert transportTime into seconds.
			 *  
			 *  ie: 4:2:3 == 4 measures + 2 quarters + 3 sixteenths
			 *
			 *  @param  {string} transportTime 
			 *  @param {number=} bpm 
			 *  @param {number=} timeSignature
			 *  @return {number}               seconds
			 *
			 *  @lends Tone.prototype.transportTimeToSeconds
			 */
		    Tone.prototype.transportTimeToSeconds = function (transportTime, bpm, timeSignature) {
		        bpm = this.defaultArg(bpm, Tone.Transport.bpm.value);
		        timeSignature = this.defaultArg(timeSignature, transportTimeSignature);
		        var measures = 0;
		        var quarters = 0;
		        var sixteenths = 0;
		        var split = transportTime.split(':');
		        if (split.length === 2) {
		            measures = parseFloat(split[0]);
		            quarters = parseFloat(split[1]);
		        } else if (split.length === 1) {
		            quarters = parseFloat(split[0]);
		        } else if (split.length === 3) {
		            measures = parseFloat(split[0]);
		            quarters = parseFloat(split[1]);
		            sixteenths = parseFloat(split[2]);
		        }
		        var beats = measures * timeSignature + quarters + sixteenths / 4;
		        return beats * this.notationToSeconds('4n');
		    };
		    /**
			 *  Convert seconds to the closest transportTime in the form 
			 *  	measures:quarters:sixteenths
			 *
			 *  @method toTransportTime
			 *  
			 *  @param {Time} seconds 
			 *  @param {number=} bpm 
			 *  @param {number=} timeSignature
			 *  @return {string}  
			 *  
			 *  @lends Tone.prototype.toTransportTime
			 */
		    Tone.prototype.toTransportTime = function (time, bpm, timeSignature) {
		        var seconds = this.toSeconds(time, bpm, timeSignature);
		        bpm = this.defaultArg(bpm, Tone.Transport.bpm.value);
		        timeSignature = this.defaultArg(timeSignature, transportTimeSignature);
		        var quarterTime = this.notationToSeconds('4n');
		        var quarters = seconds / quarterTime;
		        var measures = Math.floor(quarters / timeSignature);
		        var sixteenths = Math.floor(quarters % 1 * 4);
		        quarters = Math.floor(quarters) % timeSignature;
		        var progress = [
		            measures,
		            quarters,
		            sixteenths
		        ];
		        return progress.join(':');
		    };
		    /**
			 *  Convert a frequency representation into a number.
			 *  	
			 *  @param  {Frequency} freq 
			 *  @param {number=} 	now 	if passed in, this number will be 
			 *                        		used for all 'now' relative timings
			 *  @return {number}      the frequency in hertz
			 */
		    Tone.prototype.toFrequency = function (freq, now) {
		        if (this.isFrequency(freq)) {
		            return parseFloat(freq);
		        } else if (this.isNotation(freq) || this.isTransportTime(freq)) {
		            return this.secondsToFrequency(this.toSeconds(freq, now));
		        } else {
		            return freq;
		        }
		    };
		    /**
			 *  Convert Time into seconds.
			 *  
			 *  Unlike the method which it overrides, this takes into account 
			 *  transporttime and musical notation.
			 *
			 *  Time : 1.40
			 *  Notation: 4n|1m|2t
			 *  TransportTime: 2:4:1 (measure:quarters:sixteens)
			 *  Now Relative: +3n
			 *  Math: 3n+16n or even very complicated expressions ((3n*2)/6 + 1)
			 *
			 *  @override
			 *  @param  {Time} time       
			 *  @param {number=} 	now 	if passed in, this number will be 
			 *                        		used for all 'now' relative timings
			 *  @return {number} 
			 */
		    Tone.prototype.toSeconds = function (time, now) {
		        now = this.defaultArg(now, this.now());
		        if (typeof time === 'number') {
		            return time;    //assuming that it's seconds
		        } else if (typeof time === 'string') {
		            var plusTime = 0;
		            if (time.charAt(0) === '+') {
		                plusTime = now;
		                time = time.slice(1);
		            }
		            var components = time.split(/[\(\)\-\+\/\*]/);
		            if (components.length > 1) {
		                var originalTime = time;
		                for (var i = 0; i < components.length; i++) {
		                    var symb = components[i].trim();
		                    if (symb !== '') {
		                        var val = this.toSeconds(symb);
		                        time = time.replace(symb, val);
		                    }
		                }
		                try {
		                    //i know eval is evil, but i think it's safe here
		                    time = eval(time);    // jshint ignore:line
		                } catch (e) {
		                    throw new EvalError('problem evaluating Tone.Type.Time: ' + originalTime);
		                }
		            } else if (this.isNotation(time)) {
		                time = this.notationToSeconds(time);
		            } else if (this.isTransportTime(time)) {
		                time = this.transportTimeToSeconds(time);
		            } else if (this.isFrequency(time)) {
		                time = this.frequencyToSeconds(time);
		            } else {
		                time = parseFloat(time);
		            }
		            return time + plusTime;
		        } else {
		            return now;
		        }
		    };
		    var TransportConstructor = Tone.Transport;
		    Tone._initAudioContext(function () {
		        if (typeof Tone.Transport === 'function') {
		            //a single transport object
		            Tone.Transport = new Tone.Transport();
		        } else {
		            //stop the clock
		            Tone.Transport.stop();
		            //get the previous bpm
		            var bpm = Tone.Transport.bpm.value;
		            //destory the old clock
		            Tone.Transport._clock.dispose();
		            //make new Transport insides
		            TransportConstructor.call(Tone.Transport);
		            //set the bpm
		            Tone.Transport.bpm.value = bpm;
		        }
		    });
		    return Tone.Transport;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A single master output which is connected to the
			 *          AudioDestinationNode (aka your speakers). 
			 *          It provides useful conveniences such as the ability 
			 *          to set the volume and mute the entire application. 
			 *          It also gives you the ability to apply master effects to your application. 
			 *          <br><br>
			 *          Like Tone.Transport, A single Tone.Master is created
			 *          on initialization and you do not need to explicitly construct one.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @singleton
			 *  @example
			 * //the audio will go from the oscillator to the speakers
			 * oscillator.connect(Tone.Master);
			 * //a convenience for connecting to the master output is also provided:
			 * oscillator.toMaster();
			 * //the above two examples are equivalent.
			 */
		    Tone.Master = function () {
		        Tone.call(this);
		        /**
				 * the unmuted volume
				 * @type {number}
				 * @private
				 */
		        this._unmutedVolume = 1;
		        /**
				 *  if the master is muted
				 *  @type {boolean}
				 *  @private
				 */
		        this._muted = false;
		        /**
				 * The volume of the master output.
				 * @type {Decibels}
				 * @signal
				 */
		        this.volume = new Tone.Signal(this.output.gain, Tone.Type.Decibels);
		        //connections
		        this.input.chain(this.output, this.context.destination);
		    };
		    Tone.extend(Tone.Master);
		    /**
			 *  @type {Object}
			 *  @const
			 */
		    Tone.Master.defaults = {
		        'volume': 0,
		        'mute': false
		    };
		    /**
			 * Mute the output. 
			 * @memberOf Tone.Master#
			 * @type {boolean}
			 * @name mute
			 * @example
			 * //mute the output
			 * Tone.Master.mute = true;
			 */
		    Object.defineProperty(Tone.Master.prototype, 'mute', {
		        get: function () {
		            return this._muted;
		        },
		        set: function (mute) {
		            if (!this._muted && mute) {
		                this._unmutedVolume = this.volume.value;
		                //maybe it should ramp here?
		                this.volume.value = -Infinity;
		            } else if (this._muted && !mute) {
		                this.volume.value = this._unmutedVolume;
		            }
		            this._muted = mute;
		        }
		    });
		    /**
			 *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously 
			 *  chained in the master effects chain. 
			 *  @param {AudioNode|Tone...} args All arguments will be connected in a row
			 *                                  and the Master will be routed through it.
			 *  @return  {Tone.Master}  this
			 *  @example
			 * //some overall compression to keep the levels in check
			 * var masterCompressor = new Tone.Compressor({
			 * 	"threshold" : -6,
			 * 	"ratio" : 3,
			 * 	"attack" : 0.5,
			 * 	"release" : 0.1
			 * });
			 * //give a little boost to the lows
			 * var lowBump = new Tone.Filter(200, "lowshelf");
			 * //route everything through the filter 
			 * //and compressor before going to the speakers
			 * Tone.Master.chain(lowBump, masterCompressor);
			 */
		    Tone.Master.prototype.chain = function () {
		        this.input.disconnect();
		        this.input.chain.apply(this.input, arguments);
		        arguments[arguments.length - 1].connect(this.output);
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	AUGMENT TONE's PROTOTYPE
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  Connect 'this' to the master output. Shorthand for this.connect(Tone.Master)
			 *  @returns {Tone} this
			 *  @example
			 * //connect an oscillator to the master output
			 * var osc = new Tone.Oscillator().toMaster();
			 */
		    Tone.prototype.toMaster = function () {
		        this.connect(Tone.Master);
		        return this;
		    };
		    /**
			 *  Also augment AudioNode's prototype to include toMaster
			 *  as a convenience
			 *  @returns {AudioNode} this
			 */
		    AudioNode.prototype.toMaster = function () {
		        this.connect(Tone.Master);
		        return this;
		    };
		    var MasterConstructor = Tone.Master;
		    /**
			 *  initialize the module and listen for new audio contexts
			 */
		    Tone._initAudioContext(function () {
		        //a single master output
		        if (!Tone.prototype.isUndef(Tone.Master)) {
		            Tone.Master = new MasterConstructor();
		        } else {
		            MasterConstructor.prototype.dispose.call(Tone.Master);
		            MasterConstructor.call(Tone.Master);
		        }
		    });
		    return Tone.Master;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Base class for sources. Sources have start/stop methods
			 *          and the ability to be synced to the 
			 *          start/stop of Tone.Transport.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 */
		    Tone.Source = function (options) {
		        //unlike most ToneNodes, Sources only have an output and no input
		        Tone.call(this, 0, 1);
		        options = this.defaultArg(options, Tone.Source.defaults);
		        /**
				 * Callback is invoked when the source is done playing.
				 * @type {function}
				 * @example
				 * source.onended = function(){
				 * 	console.log("the source is done playing");
				 * }
				 */
		        this.onended = options.onended;
		        /**
				 *  the next time the source is started
				 *  @type {number}
				 *  @private
				 */
		        this._nextStart = Infinity;
		        /**
				 *  the next time the source is stopped
				 *  @type {number}
				 *  @private
				 */
		        this._nextStop = Infinity;
		        /**
				 * The volume of the output in decibels.
				 * @type {Decibels}
				 * @signal
				 * @example
				 * source.volume.value = -6;
				 */
		        this.volume = new Tone.Signal({
		            'param': this.output.gain,
		            'value': options.volume,
		            'units': Tone.Type.Decibels
		        });
		        this._readOnly('volume');
		        /**
				 * 	keeps track of the timeout for chaning the state
				 * 	and calling the onended
				 *  @type {number}
				 *  @private
				 */
		        this._timeout = -1;
		        //make the output explicitly stereo
		        this.output.channelCount = 2;
		        this.output.channelCountMode = 'explicit';
		    };
		    Tone.extend(Tone.Source);
		    /**
			 *  The default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Source.defaults = {
		        'onended': Tone.noOp,
		        'volume': 0
		    };
		    /**
			 *  Returns the playback state of the source, either "started" or "stopped".
			 *  @type {Tone.State}
			 *  @readOnly
			 *  @memberOf Tone.Source#
			 *  @name state
			 */
		    Object.defineProperty(Tone.Source.prototype, 'state', {
		        get: function () {
		            return this._stateAtTime(this.now());
		        }
		    });
		    /**
			 *  Get the state of the source at the specified time.
			 *  @param  {Time}  time
			 *  @return  {Tone.State} 
			 *  @private
			 */
		    Tone.Source.prototype._stateAtTime = function (time) {
		        time = this.toSeconds(time);
		        if (this._nextStart <= time && this._nextStop > time) {
		            return Tone.State.Started;
		        } else if (this._nextStop <= time) {
		            return Tone.State.Stopped;
		        } else {
		            return Tone.State.Stopped;
		        }
		    };
		    /**
			 *  Start the source at the specified time. If no time is given, 
			 *  start the source now.
			 *  @param  {Time} [time=now] When the source should be started.
			 *  @returns {Tone.Source} this
			 *  @example
			 * source.start("+0.5"); //starts the source 0.5 seconds from now
			 */
		    Tone.Source.prototype.start = function (time) {
		        time = this.toSeconds(time);
		        if (this._stateAtTime(time) !== Tone.State.Started || this.retrigger) {
		            this._nextStart = time;
		            this._nextStop = Infinity;
		            this._start.apply(this, arguments);
		        }
		        return this;
		    };
		    /**
			 *  Stop the source at the specified time. If no time is given, 
			 *  stop the source now.
			 *  @param  {Time} [time=now] When the source should be stopped. 
			 *  @returns {Tone.Source} this
			 *  @example
			 * source.stop(); // stops the source immediately
			 */
		    Tone.Source.prototype.stop = function (time) {
		        var now = this.now();
		        time = this.toSeconds(time, now);
		        if (this._stateAtTime(time) === Tone.State.Started) {
		            this._nextStop = this.toSeconds(time);
		            clearTimeout(this._timeout);
		            var diff = time - now;
		            if (diff > 0) {
		                //add a small buffer before invoking the callback
		                this._timeout = setTimeout(this.onended, diff * 1000 + 20);
		            } else {
		                this.onended();
		            }
		            this._stop.apply(this, arguments);
		        }
		        return this;
		    };
		    /**
			 *  Not ready yet. 
		 	 *  @private
		 	 *  @abstract
			 *  @param  {Time} time 
			 *  @returns {Tone.Source} this
			 */
		    Tone.Source.prototype.pause = function (time) {
		        //if there is no pause, just stop it
		        this.stop(time);
		        return this;
		    };
		    /**
			 *  Sync the source to the Transport so that when the transport
			 *  is started, this source is started and when the transport is stopped
			 *  or paused, so is the source. 
			 *
			 *  @param {Time} [delay=0] Delay time before starting the source after the
			 *                               Transport has started. 
			 *  @returns {Tone.Source} this
			 *  @example
			 * //sync the source to start 1 measure after the transport starts
			 * source.sync("1m");
			 * //start the transport. the source will start 1 measure later. 
			 * Tone.Transport.start();
			 */
		    Tone.Source.prototype.sync = function (delay) {
		        Tone.Transport.syncSource(this, delay);
		        return this;
		    };
		    /**
			 *  Unsync the source to the Transport. See Tone.Source.sync
			 *  @returns {Tone.Source} this
			 */
		    Tone.Source.prototype.unsync = function () {
		        Tone.Transport.unsyncSource(this);
		        return this;
		    };
		    /**
			 *	Clean up.
			 *  @return {Tone.Source} this
			 */
		    Tone.Source.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.stop();
		        clearTimeout(this._timeout);
		        this.onended = Tone.noOp;
		        this._writable('volume');
		        this.volume.dispose();
		        this.volume = null;
		    };
		    return Tone.Source;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Oscillator supports a number of features including
			 *         phase rotation, multiple oscillator types (see Tone.Oscillator.type), 
			 *         and Transport syncing (see Tone.Oscillator.syncFrequency).
			 *
			 *  @constructor
			 *  @extends {Tone.Source}
			 *  @param {Frequency} [frequency] Starting frequency
			 *  @param {string} [type] The oscillator type. Read more about type below.
			 *  @example
			 * //make and start a 440hz sine tone
			 * var osc = new Tone.Oscillator(440, "sine").toMaster().start();
			 */
		    Tone.Oscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type'
		        ], Tone.Oscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  the main oscillator
				 *  @type {OscillatorNode}
				 *  @private
				 */
		        this._oscillator = null;
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune control signal.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
		        /**
				 *  the periodic wave
				 *  @type {PeriodicWave}
				 *  @private
				 */
		        this._wave = null;
		        /**
				 *  the phase of the oscillator
				 *  between 0 - 360
				 *  @type {number}
				 *  @private
				 */
		        this._phase = options.phase;
		        /**
				 *  the type of the oscillator
				 *  @type {string}
				 *  @private
				 */
		        this._type = null;
		        //setup
		        this.type = options.type;
		        this.phase = this._phase;
		        this._readOnly([
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.Oscillator, Tone.Source);
		    /**
			 *  the default parameters
			 *  @type {Object}
			 */
		    Tone.Oscillator.defaults = {
		        'type': 'sine',
		        'frequency': 440,
		        'detune': 0,
		        'phase': 0
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} [time=now] 
			 *  @private
			 */
		    Tone.Oscillator.prototype._start = function (time) {
		        //new oscillator with previous values
		        this._oscillator = this.context.createOscillator();
		        this._oscillator.setPeriodicWave(this._wave);
		        //connect the control signal to the oscillator frequency & detune
		        this._oscillator.connect(this.output);
		        this.frequency.connect(this._oscillator.frequency);
		        this.detune.connect(this._oscillator.detune);
		        //start the oscillator
		        this._oscillator.start(this.toSeconds(time));
		    };
		    /**
			 *  stop the oscillator
			 *  @private
			 *  @param  {Time} [time=now] (optional) timing parameter
			 *  @returns {Tone.Oscillator} this
			 */
		    Tone.Oscillator.prototype._stop = function (time) {
		        if (this._oscillator) {
		            this._oscillator.stop(this.toSeconds(time));
		            this._oscillator = null;
		        }
		        return this;
		    };
		    /**
			 *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,
			 *  will also affect the oscillators frequency. 
			 *  @returns {Tone.Oscillator} this
			 *  @example
			 * Tone.Transport.bpm.value = 120;
			 * osc.frequency.value = 440;
			 * //the ration between the bpm and the frequency will be maintained
			 * osc.syncFrequency();
			 * Tone.Transport.bpm.value = 240; 
			 * // the frequency of the oscillator is doubled to 880
			 */
		    Tone.Oscillator.prototype.syncFrequency = function () {
		        Tone.Transport.syncSignal(this.frequency);
		        return this;
		    };
		    /**
			 *  Unsync the oscillator's frequency from the Transport. 
			 *  See Tone.Oscillator.syncFrequency
			 *  @returns {Tone.Oscillator} this
			 */
		    Tone.Oscillator.prototype.unsyncFrequency = function () {
		        Tone.Transport.unsyncSignal(this.frequency);
		        return this;
		    };
		    /**
			 * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of
			 * setting the first x number of partials of the oscillator. For example: "sine4" would
			 * set be the first 4 partials of the sine wave and "triangle8" would set the first
			 * 8 partials of the triangle wave.
			 * <br><br> 
			 * Uses PeriodicWave internally even for native types so that it can set the phase. 
			 * PeriodicWave equations are from the 
			 * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).
			 *  
			 * @memberOf Tone.Oscillator#
			 * @type {string}
			 * @name type
			 * @example
			 * //set it to a square wave
			 * osc.type = "square";
			 * @example
			 * //set the first 6 partials of a sawtooth wave
			 * osc.type = "sawtooth6";
			 */
		    Object.defineProperty(Tone.Oscillator.prototype, 'type', {
		        get: function () {
		            return this._type;
		        },
		        set: function (type) {
		            var originalType = type;
		            var fftSize = 4096;
		            var periodicWaveSize = fftSize / 2;
		            var real = new Float32Array(periodicWaveSize);
		            var imag = new Float32Array(periodicWaveSize);
		            var partialCount = 1;
		            var partial = /(sine|triangle|square|sawtooth)(\d+)$/.exec(type);
		            if (partial) {
		                partialCount = parseInt(partial[2]);
		                type = partial[1];
		                partialCount = Math.max(partialCount, 2);
		                periodicWaveSize = partialCount;
		            }
		            var shift = this._phase;
		            for (var n = 1; n < periodicWaveSize; ++n) {
		                var piFactor = 2 / (n * Math.PI);
		                var b;
		                switch (type) {
		                case 'sine':
		                    b = n <= partialCount ? 1 : 0;
		                    break;
		                case 'square':
		                    b = n & 1 ? 2 * piFactor : 0;
		                    break;
		                case 'sawtooth':
		                    b = piFactor * (n & 1 ? 1 : -1);
		                    break;
		                case 'triangle':
		                    if (n & 1) {
		                        b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);
		                    } else {
		                        b = 0;
		                    }
		                    break;
		                default:
		                    throw new TypeError('invalid oscillator type: ' + type);
		                }
		                if (b !== 0) {
		                    real[n] = -b * Math.sin(shift * n);
		                    imag[n] = b * Math.cos(shift * n);
		                } else {
		                    real[n] = 0;
		                    imag[n] = 0;
		                }
		            }
		            var periodicWave = this.context.createPeriodicWave(real, imag);
		            this._wave = periodicWave;
		            if (this._oscillator !== null) {
		                this._oscillator.setPeriodicWave(this._wave);
		            }
		            this._type = originalType;
		        }
		    });
		    /**
			 * The phase of the oscillator in degrees. 
			 * @memberOf Tone.Oscillator#
			 * @type {Degrees}
			 * @name phase
			 * @example
			 * osc.phase = 180; //flips the phase of the oscillator
			 */
		    Object.defineProperty(Tone.Oscillator.prototype, 'phase', {
		        get: function () {
		            return this._phase * (180 / Math.PI);
		        },
		        set: function (phase) {
		            this._phase = phase * Math.PI / 180;
		            //reset the type
		            this.type = this._type;
		        }
		    });
		    /**
			 *  Dispose and disconnect.
			 *  @return {Tone.Oscillator} this
			 */
		    Tone.Oscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._oscillator !== null) {
		            this._oscillator.disconnect();
		            this._oscillator = null;
		        }
		        this._wave = null;
		        this._writable([
		            'frequency',
		            'detune'
		        ]);
		        this.frequency.dispose();
		        this.frequency = null;
		        this.detune.dispose();
		        this.detune = null;
		        return this;
		    };
		    return Tone.Oscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1]. 
			 *         See Tone.GainToAudio.
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 *  var a2g = new Tone.AudioToGain();
			 */
		    Tone.AudioToGain = function () {
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
		            return (x + 1) / 2;
		        });
		    };
		    Tone.extend(Tone.AudioToGain, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.AudioToGain} this
			 */
		    Tone.AudioToGain.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._norm.dispose();
		        this._norm = null;
		        return this;
		    };
		    return Tone.AudioToGain;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  LFO stands for low frequency oscillator. Tone.LFO produces an output signal 
			 *          which can be attached to an AudioParam or Tone.Signal 
			 *          in order to modulate that parameter with an oscillator. The LFO can 
			 *          also be synced to the transport to start/stop and change when the tempo changes.
			 *
			 *  @constructor
			 *  @extends {Tone.Oscillator}
			 *  @param {Frequency|Object} [frequency] The frequency of the oscillation. Typically, LFOs will be
			 *                               in the frequency range of 0.1 to 10 hertz. 
			 *  @param {number=} min The minimum output value of the LFO. The LFO starts 
			 *                      at it's minimum value. 
			 *  @param {number=} max The maximum value of the LFO. 
			 *  @example
			 * var lfo = new Tone.LFO("4n", 400, 4000);
			 * lfo.connect(filter.frequency);
			 */
		    Tone.LFO = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'min',
		            'max'
		        ], Tone.LFO.defaults);
		        /** 
				 *  The oscillator. 
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this.oscillator = new Tone.Oscillator({
		            'frequency': options.frequency,
		            'type': options.type,
		            'phase': options.phase + 90
		        });
		        /**
				 *  the lfo's frequency
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this.oscillator.frequency;
		        /**
				 * The amplitude of the LFO, which controls the output range between
				 * the min and max output. For example if the min is -10 and the max 
				 * is 10, setting the amplitude to 0.5 would make the LFO modulate
				 * between -5 and 5. 
				 * @type {Number}
				 * @signal
				 */
		        this.amplitude = this.oscillator.volume;
		        this.amplitude.units = Tone.Type.NormalRange;
		        this.amplitude.value = options.amplitude;
		        /**
				 *  @type {Tone.AudioToGain} 
				 *  @private
				 */
		        this._a2g = new Tone.AudioToGain();
		        /**
				 *  @type {Tone.Scale} 
				 *  @private
				 */
		        this._scaler = this.output = new Tone.Scale(options.min, options.max);
		        /**
				 *  the units of the LFO (used for converting)
				 *  @type {string} 
				 *  @private
				 */
		        this._units = Tone.Type.Default;
		        //connect it up
		        this.oscillator.chain(this._a2g, this._scaler);
		        this._readOnly([
		            'amplitude',
		            'frequency',
		            'oscillator'
		        ]);
		    };
		    Tone.extend(Tone.LFO, Tone.Oscillator);
		    /**
			 *  the default parameters
			 *
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.LFO.defaults = {
		        'type': 'sine',
		        'min': 0,
		        'max': 1,
		        'phase': 0,
		        'frequency': '4n',
		        'amplitude': 1
		    };
		    /**
			 *  Start the LFO. 
			 *  @param  {Time} [time=now] the time the LFO will start
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.start = function (time) {
		        this.oscillator.start(time);
		        return this;
		    };
		    /**
			 *  Stop the LFO. 
			 *  @param  {Time} [time=now] the time the LFO will stop
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.stop = function (time) {
		        this.oscillator.stop(time);
		        return this;
		    };
		    /**
			 *  Sync the start/stop/pause to the transport 
			 *  and the frequency to the bpm of the transport
			 *
			 *  @param {Time} [delay=0] the time to delay the start of the
			 *                                LFO from the start of the transport
			 *  @returns {Tone.LFO} this
			 *  @example
			 *  lfo.frequency.value = "8n";
			 *  lfo.sync();
			 *  //the rate of the LFO will always be an eighth note, 
			 *  //even as the tempo changes
			 */
		    Tone.LFO.prototype.sync = function (delay) {
		        this.oscillator.sync(delay);
		        this.oscillator.syncFrequency();
		        return this;
		    };
		    /**
			 *  unsync the LFO from transport control
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.unsync = function () {
		        this.oscillator.unsync();
		        this.oscillator.unsyncFrequency();
		        return this;
		    };
		    /**
			 * The miniumum output of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'min', {
		        get: function () {
		            return this._toUnits(this._scaler.min);
		        },
		        set: function (min) {
		            min = this._fromUnits(min);
		            this._scaler.min = min;
		        }
		    });
		    /**
			 * The maximum output of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'max', {
		        get: function () {
		            return this._toUnits(this._scaler.max);
		        },
		        set: function (max) {
		            max = this._fromUnits(max);
		            this._scaler.max = max;
		        }
		    });
		    /**
			 * The type of the oscillator: sine, square, sawtooth, triangle. 
			 * @memberOf Tone.LFO#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'type', {
		        get: function () {
		            return this.oscillator.type;
		        },
		        set: function (type) {
		            this.oscillator.type = type;
		        }
		    });
		    /**
			 * The phase of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {number}
			 * @name phase
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'phase', {
		        get: function () {
		            return this.oscillator.phase - 90;
		        },
		        set: function (phase) {
		            this.oscillator.phase = phase + 90;
		        }
		    });
		    /**
			 * The output units of the LFO.
			 * @memberOf Tone.LFO#
			 * @type {Tone.Type}
			 * @name units
			 */
		    Object.defineProperty(Tone.LFO.prototype, 'units', {
		        get: function () {
		            return this._units;
		        },
		        set: function (val) {
		            var currentMin = this.min;
		            var currentMax = this.max;
		            //convert the min and the max
		            this._units = val;
		            this.min = currentMin;
		            this.max = currentMax;
		        }
		    });
		    /**
			 *  Connect the output of a ToneNode to an AudioParam, AudioNode, or Tone Node. 
			 *  will get the units from the connected node.
			 *  @param  {Tone | AudioParam | AudioNode} node 
			 *  @param {number} [outputNum=0] optionally which output to connect from
			 *  @param {number} [inputNum=0] optionally which input to connect to
			 *  @returns {Tone.LFO} this
			 *  @private
			 */
		    Tone.LFO.prototype.connect = function (node) {
		        if (node.constructor === Tone.Signal) {
		            this.convert = node.convert;
		            this.units = node.units;
		        }
		        Tone.Signal.prototype.connect.apply(this, arguments);
		        return this;
		    };
		    /**
			 *  private method borroed from Signal converts 
			 *  units from their destination value
			 *  @function
			 *  @private
			 */
		    Tone.LFO.prototype._fromUnits = Tone.Signal.prototype._fromUnits;
		    /**
			 *  private method borroed from Signal converts 
			 *  units to their destination value
			 *  @function
			 *  @private
			 */
		    Tone.LFO.prototype._toUnits = Tone.Signal.prototype._toUnits;
		    /**
			 *  disconnect and dispose
			 *  @returns {Tone.LFO} this
			 */
		    Tone.LFO.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'amplitude',
		            'frequency',
		            'oscillator'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this._scaler.dispose();
		        this._scaler = null;
		        this._a2g.dispose();
		        this._a2g = null;
		        this.frequency = null;
		        this.amplitude = null;
		        return this;
		    };
		    return Tone.LFO;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Limiter will limit the loudness of an incoming signal. 
			 *         It is composed of a Tone.Compressor with a fast attack 
			 *         and release. Limiters are commonly used to safeguard against 
			 *         signal clipping. Unlike a compressor, limiters do not provide 
			 *         smooth gain reduction and almost completely prevent 
			 *         additional gain above the threshold.
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {number} threshold The theshold above which the limiting is applied. 
			 *  @example
			 *  var limiter = new Tone.Limiter(-6);
			 */
		    Tone.Limiter = function (threshold) {
		        /**
				 *  the compressor
				 *  @private
				 *  @type {Tone.Compressor}
				 */
		        this._compressor = this.input = this.output = new Tone.Compressor({
		            'attack': 0.001,
		            'decay': 0.001,
		            'threshold': threshold
		        });
		        /**
				 * The threshold of of the limiter
				 * @type {Decibel}
				 * @signal
				 */
		        this.threshold = this._compressor.threshold;
		        this._readOnly('threshold');
		    };
		    Tone.extend(Tone.Limiter);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Limiter} this
			 */
		    Tone.Limiter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._compressor.dispose();
		        this._compressor = null;
		        this._writable('threshold');
		        this.threshold = null;
		        return this;
		    };
		    return Tone.Limiter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Lowpass is a lowpass feedback comb filter. It is similar to 
			 *         Tone.FeedbackCombFilter, but includes a lowpass filter.
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Time|Object} [delayTime] The delay time of the comb filter
			 *  @param {NormalRange=} resonance The resonance (feedback) of the comb filter
			 *  @param {Frequency=} dampening The cutoff of the lowpass filter dampens the
			 *                                signal as it is fedback. 
			 */
		    Tone.LowpassCombFilter = function () {
		        Tone.call(this);
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'resonance',
		            'dampening'
		        ], Tone.LowpassCombFilter.defaults);
		        /**
				 *  the delay node
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delay = this.input = this.context.createDelay(1);
		        /**
				 *  The delayTime of the comb filter. 
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
		        /**
				 *  the lowpass filter
				 *  @type  {BiquadFilterNode}
				 *  @private
				 */
		        this._lowpass = this.output = this.context.createBiquadFilter();
		        this._lowpass.Q.value = 0;
		        this._lowpass.type = 'lowpass';
		        /**
				 *  The dampening control of the feedback
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.dampening = new Tone.Signal(this._lowpass.frequency, Tone.Type.Frequency);
		        this.dampening.value = options.dampening;
		        /**
				 *  the feedback gain
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedback = this.context.createGain();
		        /**
				 *  The amount of feedback of the delayed signal. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.resonance = new Tone.Signal(options.resonance, Tone.Type.NormalRange);
		        //connections
		        this._delay.chain(this._lowpass, this._feedback, this._delay);
		        this.delayTime.connect(this._delay.delayTime);
		        this.resonance.connect(this._feedback.gain);
		        this.dampening.connect(this._lowpass.frequency);
		        this._readOnly([
		            'dampening',
		            'resonance',
		            'delayTime'
		        ]);
		    };
		    Tone.extend(Tone.LowpassCombFilter);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.LowpassCombFilter.defaults = {
		        'delayTime': 0.1,
		        'resonance': 0.5,
		        'dampening': 3000
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.LowpassCombFilter} this
			 */
		    Tone.LowpassCombFilter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'dampening',
		            'resonance',
		            'delayTime'
		        ]);
		        this.dampening.dispose();
		        this.dampening = null;
		        this.resonance.dispose();
		        this.resonance = null;
		        this._delay.disconnect();
		        this._delay = null;
		        this._lowpass.disconnect();
		        this._lowpass = null;
		        this._feedback.disconnect();
		        this._feedback = null;
		        this.delayTime.dispose();
		        this.delayTime = null;
		        return this;
		    };
		    return Tone.LowpassCombFilter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Merge brings two signals into the left and right 
			 *          channels of a single stereo channel.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @example
			 * var merge = new Tone.Merge().toMaster();
			 * //routing a sine tone in the left channel
			 * //and noise in the right channel
			 * var osc = new Tone.Oscillator().connect(merge.left);
			 * var noise = new Tone.Noise().connect(merge.right);
			 * //starting our oscillators
			 * noise.start();
			 * osc.start();
			 */
		    Tone.Merge = function () {
		        Tone.call(this, 2, 0);
		        /**
				 *  The left input channel.
				 *  Alias for <code>input[0]</code>
				 *  @type {GainNode}
				 */
		        this.left = this.input[0] = this.context.createGain();
		        /**
				 *  The right input channel.
				 *  Alias for <code>input[1]</code>.
				 *  @type {GainNode}
				 */
		        this.right = this.input[1] = this.context.createGain();
		        /**
				 *  the merger node for the two channels
				 *  @type {ChannelMergerNode}
				 *  @private
				 */
		        this._merger = this.output = this.context.createChannelMerger(2);
		        //connections
		        this.left.connect(this._merger, 0, 0);
		        this.right.connect(this._merger, 0, 1);
		    };
		    Tone.extend(Tone.Merge);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Merge} this
			 */
		    Tone.Merge.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.left.disconnect();
		        this.left = null;
		        this.right.disconnect();
		        this.right = null;
		        this._merger.disconnect();
		        this._merger = null;
		        return this;
		    };
		    return Tone.Merge;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)
			 *          of an input signal with some averaging applied. 
			 *          It can also get the raw value of the signal or the value in dB. For signal 
			 *          processing, it's better to use Tone.Follower which will produce an audio-rate 
			 *          envelope follower instead of needing to poll the Meter to get the output.
			 *          <br><br>
			 *          Meter was inspired by [Chris Wilsons Volume Meter](https://github.com/cwilso/volume-meter/blob/master/volume-meter.js).
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {number} [channels=1] number of channels being metered
			 *  @param {number} [smoothing=0.8] amount of smoothing applied to the volume
			 *  @param {number} [clipMemory=0.5] number in seconds that a "clip" should be remembered
			 *  @example
			 * var meter = new Tone.Meter();
			 * var mic = new Tone.Microphone().start();
			 * //connect mic to the meter
			 * mic.connect(meter);
			 * //use getLevel or getDb 
			 * //to access meter level
			 * meter.getLevel();
			 */
		    Tone.Meter = function (channels, smoothing, clipMemory) {
		        //extends Unit
		        Tone.call(this);
		        /** 
				 *  The channel count
				 *  @type  {number}
				 *  @private
				 */
		        this._channels = this.defaultArg(channels, 1);
		        /** 
				 *  the smoothing value
				 *  @type  {number}
				 *  @private
				 */
		        this._smoothing = this.defaultArg(smoothing, 0.8);
		        /** 
				 *  the amount of time a clip is remember for. 
				 *  @type  {number}
				 *  @private
				 */
		        this._clipMemory = this.defaultArg(clipMemory, 0.5) * 1000;
		        /** 
				 *  the rms for each of the channels
				 *  @private
				 *  @type {Array}
				 */
		        this._volume = new Array(this._channels);
		        /** 
				 *  the raw values for each of the channels
				 *  @private
				 *  @type {Array}
				 */
		        this._values = new Array(this._channels);
		        //zero out the volume array
		        for (var i = 0; i < this._channels; i++) {
		            this._volume[i] = 0;
		            this._values[i] = 0;
		        }
		        /** 
				 *  last time the values clipped
				 *  @private
				 *  @type {number}
				 */
		        this._lastClip = 0;
		        /** 
				 *  @private
				 *  @type {ScriptProcessorNode}
				 */
		        this._jsNode = this.context.createScriptProcessor(this.bufferSize, this._channels, 1);
		        this._jsNode.onaudioprocess = this._onprocess.bind(this);
		        //so it doesn't get garbage collected
		        this._jsNode.noGC();
		        //signal just passes
		        this.input.connect(this.output);
		        this.input.connect(this._jsNode);
		    };
		    Tone.extend(Tone.Meter);
		    /**
			 *  called on each processing frame
			 *  @private
			 *  @param  {AudioProcessingEvent} event 
			 */
		    Tone.Meter.prototype._onprocess = function (event) {
		        var bufferSize = this._jsNode.bufferSize;
		        var smoothing = this._smoothing;
		        for (var channel = 0; channel < this._channels; channel++) {
		            var input = event.inputBuffer.getChannelData(channel);
		            var sum = 0;
		            var total = 0;
		            var x;
		            var clipped = false;
		            for (var i = 0; i < bufferSize; i++) {
		                x = input[i];
		                if (!clipped && x > 0.95) {
		                    clipped = true;
		                    this._lastClip = Date.now();
		                }
		                total += x;
		                sum += x * x;
		            }
		            var average = total / bufferSize;
		            var rms = Math.sqrt(sum / bufferSize);
		            this._volume[channel] = Math.max(rms, this._volume[channel] * smoothing);
		            this._values[channel] = average;
		        }
		    };
		    /**
			 *  Get the rms of the signal.
			 *  @param  {number} [channel=0] which channel
			 *  @return {number}         the value
			 */
		    Tone.Meter.prototype.getLevel = function (channel) {
		        channel = this.defaultArg(channel, 0);
		        var vol = this._volume[channel];
		        if (vol < 0.00001) {
		            return 0;
		        } else {
		            return vol;
		        }
		    };
		    /**
			 *  Get the raw value of the signal. 
			 *  @param  {number=} channel 
			 *  @return {number}         
			 */
		    Tone.Meter.prototype.getValue = function (channel) {
		        channel = this.defaultArg(channel, 0);
		        return this._values[channel];
		    };
		    /**
			 *  Get the volume of the signal in dB
			 *  @param  {number=} channel 
			 *  @return {Decibels}         
			 */
		    Tone.Meter.prototype.getDb = function (channel) {
		        return this.gainToDb(this.getLevel(channel));
		    };
		    /**
			 * @returns {boolean} if the audio has clipped. The value resets
			 *                       based on the clipMemory defined. 
			 */
		    Tone.Meter.prototype.isClipped = function () {
		        return Date.now() - this._lastClip < this._clipMemory;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Meter} this
			 */
		    Tone.Meter.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._jsNode.disconnect();
		        this._jsNode.onaudioprocess = null;
		        this._volume = null;
		        this._values = null;
		        return this;
		    };
		    return Tone.Meter;
		});
		Module(function (Tone) {
		    
		    /**
			 *	@class  Tone.Split splits an incoming signal into left and right channels.
			 *	
			 *  @constructor
			 *  @extends {Tone}
			 *  @example
			 * var split = new Tone.Split();
			 * stereoSignal.connect(split);
			 */
		    Tone.Split = function () {
		        Tone.call(this, 0, 2);
		        /** 
				 *  @type {ChannelSplitterNode}
				 *  @private
				 */
		        this._splitter = this.input = this.context.createChannelSplitter(2);
		        /** 
				 *  Left channel output. 
				 *  Alias for <code>output[0]</code>
				 *  @type {GainNode}
				 */
		        this.left = this.output[0] = this.context.createGain();
		        /**
				 *  Right channel output.
				 *  Alias for <code>output[1]</code>
				 *  @type {GainNode}
				 */
		        this.right = this.output[1] = this.context.createGain();
		        //connections
		        this._splitter.connect(this.left, 0, 0);
		        this._splitter.connect(this.right, 1, 0);
		    };
		    Tone.extend(Tone.Split);
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Split} this
			 */
		    Tone.Split.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._splitter.disconnect();
		        this.left.disconnect();
		        this.right.disconnect();
		        this.left = null;
		        this.right = null;
		        this._splitter = null;
		        return this;
		    };
		    return Tone.Split;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Mid/Side processing separates the the 'mid' signal 
			 *         (which comes out of both the left and the right channel) 
			 *         and the 'side' (which only comes out of the the side channels). <br><br>
			 *         <code>
			 *         Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right<br>
			 *         Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ<br>
			 *         </code>
			 *
			 *  @extends {Tone}
			 *  @constructor
			 */
		    Tone.MidSideSplit = function () {
		        Tone.call(this, 0, 2);
		        /**
				 *  split the incoming signal into left and right channels
				 *  @type  {Tone.Split}
				 *  @private
				 */
		        this._split = this.input = new Tone.Split();
		        /**
				 *  The mid send. Connect to mid processing. Alias for
				 *  <code>output[0]</code>
				 *  @type {Tone.Expr}
				 */
		        this.mid = this.output[0] = new Tone.Expr('($0 + $1) * $2');
		        /**
				 *  The side output. Connect to side processing. Alias for
				 *  <code>output[1]</code>
				 *  @type {Tone.Expr}
				 */
		        this.side = this.output[1] = new Tone.Expr('($0 - $1) * $2');
		        this._split.connect(this.mid, 0, 0);
		        this._split.connect(this.mid, 1, 1);
		        this._split.connect(this.side, 0, 0);
		        this._split.connect(this.side, 1, 1);
		        sqrtTwo.connect(this.mid, 0, 2);
		        sqrtTwo.connect(this.side, 0, 2);
		    };
		    Tone.extend(Tone.MidSideSplit);
		    /**
			 *  a constant signal equal to 1 / sqrt(2)
			 *  @type {Number}
			 *  @signal
			 *  @private
			 *  @static
			 */
		    var sqrtTwo = null;
		    Tone._initAudioContext(function () {
		        sqrtTwo = new Tone.Signal(1 / Math.sqrt(2));
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.MidSideSplit} this
			 */
		    Tone.MidSideSplit.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.mid.dispose();
		        this.mid = null;
		        this.side.dispose();
		        this.side = null;
		        this._split.dispose();
		        this._split = null;
		        return this;
		    };
		    return Tone.MidSideSplit;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Mid/Side processing separates the the 'mid' signal 
			 *         (which comes out of both the left and the right channel) 
			 *         and the 'side' (which only comes out of the the side channels). 
			 *         MidSideMerge merges the mid and side signal after they've been seperated
			 *         by Tone.MidSideSplit.<br><br>
			 *         <code>
			 *         Left = (Mid+Side)/sqrt(2);   // obtain left signal from mid and side<br>
			 *         Right = (Mid-Side)/sqrt(2);   // obtain right signal from mid and side<br>
			 *         </code>
			 *
			 *  @extends {Tone.StereoEffect}
			 *  @constructor
			 */
		    Tone.MidSideMerge = function () {
		        Tone.call(this, 2, 0);
		        /**
				 *  The mid signal input. Alias for
				 *  <code>input[0]</code>
				 *  @type  {GainNode}
				 */
		        this.mid = this.input[0] = this.context.createGain();
		        /**
				 *  recombine the mid/side into Left
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._left = new Tone.Expr('($0 + $1) * $2');
		        /**
				 *  The side signal input. Alias for
				 *  <code>input[1]</code>
				 *  @type  {GainNode}
				 */
		        this.side = this.input[1] = this.context.createGain();
		        /**
				 *  recombine the mid/side into Right
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._right = new Tone.Expr('($0 - $1) * $2');
		        /**
				 *  Merge the left/right signal back into a stereo signal.
				 *  @type {Tone.Merge}
				 *  @private
				 */
		        this._merge = this.output = new Tone.Merge();
		        this.mid.connect(this._left, 0, 0);
		        this.side.connect(this._left, 0, 1);
		        this.mid.connect(this._right, 0, 0);
		        this.side.connect(this._right, 0, 1);
		        this._left.connect(this._merge, 0, 0);
		        this._right.connect(this._merge, 0, 1);
		        sqrtTwo.connect(this._left, 0, 2);
		        sqrtTwo.connect(this._right, 0, 2);
		    };
		    Tone.extend(Tone.MidSideMerge);
		    /**
			 *  A constant signal equal to 1 / sqrt(2).
			 *  @type {Number}
			 *  @signal
			 *  @private
			 *  @static
			 */
		    var sqrtTwo = null;
		    Tone._initAudioContext(function () {
		        sqrtTwo = new Tone.Signal(1 / Math.sqrt(2));
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.MidSideMerge} this
			 */
		    Tone.MidSideMerge.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.mid.disconnect();
		        this.mid = null;
		        this.side.disconnect();
		        this.side = null;
		        this._left.dispose();
		        this._left = null;
		        this._right.dispose();
		        this._right = null;
		        this._merge.dispose();
		        this._merge = null;
		        return this;
		    };
		    return Tone.MidSideMerge;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.MidSideCompressor applies two different compressors to the mid
			 *         and side signal components. See Tone.MidSideSplit. 
			 *
			 *  @extends {Tone}
			 *  @param {Object} options The options that are passed to the mid and side
			 *                          compressors. 
			 *  @constructor
			 */
		    Tone.MidSideCompressor = function (options) {
		        options = this.defaultArg(options, Tone.MidSideCompressor.defaults);
		        /**
				 *  the mid/side split
				 *  @type  {Tone.MidSideSplit}
				 *  @private
				 */
		        this._midSideSplit = this.input = new Tone.MidSideSplit();
		        /**
				 *  the mid/side recombination
				 *  @type  {Tone.MidSideMerge}
				 *  @private
				 */
		        this._midSideMerge = this.output = new Tone.MidSideMerge();
		        /**
				 *  The compressor applied to the mid signal
				 *  @type  {Tone.Compressor}
				 */
		        this.mid = new Tone.Compressor(options.mid);
		        /**
				 *  The compressor applied to the side signal
				 *  @type  {Tone.Compressor}
				 */
		        this.side = new Tone.Compressor(options.side);
		        this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);
		        this._midSideSplit.side.chain(this.side, this._midSideMerge.side);
		        this._readOnly([
		            'mid',
		            'side'
		        ]);
		    };
		    Tone.extend(Tone.MidSideCompressor);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MidSideCompressor.defaults = {
		        'mid': {
		            'ratio': 3,
		            'threshold': -24,
		            'release': 0.03,
		            'attack': 0.02,
		            'knee': 16
		        },
		        'side': {
		            'ratio': 6,
		            'threshold': -30,
		            'release': 0.25,
		            'attack': 0.03,
		            'knee': 10
		        }
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.MidSideCompressor} this
			 */
		    Tone.MidSideCompressor.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'mid',
		            'side'
		        ]);
		        this.mid.dispose();
		        this.mid = null;
		        this.side.dispose();
		        this.side = null;
		        this._midSideSplit.dispose();
		        this._midSideSplit = null;
		        this._midSideMerge.dispose();
		        this._midSideMerge = null;
		        return this;
		    };
		    return Tone.MidSideCompressor;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Mono coerces the incoming mono or stereo signal into a mono signal
			 *         where both left and right channels have the same value. This can be useful 
			 *         for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).
			 *
			 *  @extends {Tone}
			 *  @constructor
			 */
		    Tone.Mono = function () {
		        Tone.call(this, 1, 0);
		        /**
				 *  merge the signal
				 *  @type {Tone.Merge}
				 *  @private
				 */
		        this._merge = this.output = new Tone.Merge();
		        this.input.connect(this._merge, 0, 0);
		        this.input.connect(this._merge, 0, 1);
		        this.input.gain.value = this.dbToGain(-10);
		    };
		    Tone.extend(Tone.Mono);
		    /**
			 *  clean up
			 *  @returns {Tone.Mono} this
			 */
		    Tone.Mono.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._merge.dispose();
		        this._merge = null;
		        return this;
		    };
		    return Tone.Mono;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class A compressor with seperate controls over low/mid/high dynamics
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Object} options The low/mid/high compressor settings.
			 *  @example
			 *  var multiband = new Tone.MultibandCompressor({
			 *  	"lowFrequency" : 200,
			 *  	"highFrequency" : 1300
			 *  	"low" : {
			 *  		"threshold" : -12
			 *  	}
			 *  })
			 */
		    Tone.MultibandCompressor = function (options) {
		        options = this.defaultArg(arguments, Tone.MultibandCompressor.defaults);
		        /**
				 *  split the incoming signal into high/mid/low
				 *  @type {Tone.MultibandSplit}
				 *  @private
				 */
		        this._splitter = this.input = new Tone.MultibandSplit({
		            'lowFrequency': options.lowFrequency,
		            'highFrequency': options.highFrequency
		        });
		        /**
				 *  low/mid crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.lowFrequency = this._splitter.lowFrequency;
		        /**
				 *  mid/high crossover frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.highFrequency = this._splitter.highFrequency;
		        /**
				 *  the output
				 *  @type {GainNode}
				 *  @private
				 */
		        this.output = this.context.createGain();
		        /**
				 *  The compressor applied to the low frequencies.
				 *  @type {Tone.Compressor}
				 */
		        this.low = new Tone.Compressor(options.low);
		        /**
				 *  The compressor applied to the mid frequencies.
				 *  @type {Tone.Compressor}
				 */
		        this.mid = new Tone.Compressor(options.mid);
		        /**
				 *  The compressor applied to the high frequencies.
				 *  @type {Tone.Compressor}
				 */
		        this.high = new Tone.Compressor(options.high);
		        //connect the compressor
		        this._splitter.low.chain(this.low, this.output);
		        this._splitter.mid.chain(this.mid, this.output);
		        this._splitter.high.chain(this.high, this.output);
		        this._readOnly([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		    };
		    Tone.extend(Tone.MultibandCompressor);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MultibandCompressor.defaults = {
		        'low': Tone.Compressor.defaults,
		        'mid': Tone.Compressor.defaults,
		        'high': Tone.Compressor.defaults,
		        'lowFrequency': 250,
		        'highFrequency': 2000
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.MultibandCompressor} this
			 */
		    Tone.MultibandCompressor.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._splitter.dispose();
		        this._writable([
		            'high',
		            'mid',
		            'low',
		            'highFrequency',
		            'lowFrequency'
		        ]);
		        this.low.dispose();
		        this.mid.dispose();
		        this.high.dispose();
		        this._splitter = null;
		        this.low = null;
		        this.mid = null;
		        this.high = null;
		        this.lowFrequency = null;
		        this.highFrequency = null;
		        return this;
		    };
		    return Tone.MultibandCompressor;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Maps a NormalRange [0, 1] to an AudioRange [-1, 1]. 
			 *         See also Tone.AudioToGain. 
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @example
			 * var g2a = new Tone.GainToAudio();
			 */
		    Tone.GainToAudio = function () {
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {
		            return Math.abs(x) * 2 - 1;
		        });
		    };
		    Tone.extend(Tone.GainToAudio, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.GainToAudio} this
			 */
		    Tone.GainToAudio.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._norm.dispose();
		        this._norm = null;
		        return this;
		    };
		    return Tone.GainToAudio;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Panner is an equal power Left/Right Panner and does not
			 *  support 3D. Panner uses the StereoPannerNode when available. 
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {NormalRange} [initialPan=0.5] The initail panner value (defaults to 0.5 = center)
			 *  @example
			 *  //pan the input signal hard right. 
			 *  var panner = new Tone.Panner(1);
			 */
		    Tone.Panner = function (initialPan) {
		        Tone.call(this);
		        /**
				 *  indicates if the panner is using the new StereoPannerNode internally
				 *  @type  {boolean}
				 *  @private
				 */
		        this._hasStereoPanner = this.isFunction(this.context.createStereoPanner);
		        if (this._hasStereoPanner) {
		            /**
					 *  the panner node
					 *  @type {StereoPannerNode}
					 *  @private
					 */
		            this._panner = this.input = this.output = this.context.createStereoPanner();
		            /**
					 *  The pan control. 0 = hard left, 1 = hard right. 
					 *  @type {NormalRange}
					 *  @signal
					 */
		            this.pan = new Tone.Signal(0, Tone.Type.NormalRange);
		            /**
					 *  scale the pan signal to between -1 and 1
					 *  @type {Tone.WaveShaper}
					 *  @private
					 */
		            this._scalePan = new Tone.GainToAudio();
		            //connections
		            this.pan.chain(this._scalePan, this._panner.pan);
		        } else {
		            /**
					 *  the dry/wet knob
					 *  @type {Tone.CrossFade}
					 *  @private
					 */
		            this._crossFade = new Tone.CrossFade();
		            /**
					 *  @type {Tone.Merge}
					 *  @private
					 */
		            this._merger = this.output = new Tone.Merge();
		            /**
					 *  @type {Tone.Split}
					 *  @private
					 */
		            this._splitter = this.input = new Tone.Split();
		            /**
					 *  The pan control. 0 = hard left, 1 = hard right. 
					 *  @type {NormalRange}
					 *  @signal
					 */
		            this.pan = this._crossFade.fade;
		            //CONNECTIONS:
		            //left channel is a, right channel is b
		            this._splitter.connect(this._crossFade, 0, 0);
		            this._splitter.connect(this._crossFade, 1, 1);
		            //merge it back together
		            this._crossFade.a.connect(this._merger, 0, 0);
		            this._crossFade.b.connect(this._merger, 0, 1);
		        }
		        //initial value
		        this.pan.value = this.defaultArg(initialPan, 0.5);
		        this._readOnly('pan');
		    };
		    Tone.extend(Tone.Panner);
		    /**
			 *  Clean up.
			 *  @returns {Tone.Panner} this
			 */
		    Tone.Panner.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('pan');
		        if (this._hasStereoPanner) {
		            this._panner.disconnect();
		            this._panner = null;
		            this.pan.dispose();
		            this.pan = null;
		            this._scalePan.dispose();
		            this._scalePan = null;
		        } else {
		            this._crossFade.dispose();
		            this._crossFade = null;
		            this._splitter.dispose();
		            this._splitter = null;
		            this._merger.dispose();
		            this._merger = null;
		            this.pan = null;
		        }
		        return this;
		    };
		    return Tone.Panner;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Volume is a simple volume node, useful for creating a volume fader. 
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {Decibels} [volume=0] the initial volume
			 *  @example
			 * var vol = new Tone.Volume(-12);
			 * instrument.chain(vol, Tone.Master);
			 */
		    Tone.Volume = function (volume) {
		        /**
				 * the output node
				 * @type {GainNode}
				 * @private
				 */
		        this.output = this.input = this.context.createGain();
		        /**
				 *  The volume control in decibels. 
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.volume = new Tone.Signal(this.output.gain, Tone.Type.Decibels);
		        this.volume.value = this.defaultArg(volume, 0);
		        this._readOnly('volume');
		    };
		    Tone.extend(Tone.Volume);
		    /**
			 *  clean up
			 *  @returns {Tone.Volume} this
			 */
		    Tone.Volume.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('volume');
		        this.volume.dispose();
		        this.volume = null;
		        return this;
		    };
		    return Tone.Volume;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.PanVol is a Tone.Panner and Tone.Volume in one.
			 *
			 *  @extends {Tone}
			 *  @constructor
			 *  @param {NormalRange} pan the initial pan
			 *  @param {number} volume The output volume. 
			 *  @example
			 * //pan the incoming signal left and drop the volume
			 * var panVol = new Tone.PanVol(0.25, -12);
			 */
		    Tone.PanVol = function (pan, volume) {
		        /**
				 *  The panning node
				 *  @type {Tone.Panner}
				 *  @private
				 */
		        this._panner = this.input = new Tone.Panner(pan);
		        /**
				 *  The L/R panning control.
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.pan = this._panner.pan;
		        /**
				 * The volume object. 
				 * @type {Tone.Volume}
				 * @signal
				 * @private
				 */
		        this._volume = this.output = new Tone.Volume(volume);
		        /**
				 *  The volume control in decibels. 
				 *  @type {Decibels}
				 *  @signal
				 */
		        this.volume = this._volume.volume;
		        //connections
		        this._panner.connect(this._volume);
		        this._readOnly([
		            'pan',
		            'volume'
		        ]);
		    };
		    Tone.extend(Tone.PanVol);
		    /**
			 *  clean up
			 *  @returns {Tone.PanVol} this
			 */
		    Tone.PanVol.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable([
		            'pan',
		            'volume'
		        ]);
		        this._panner.dispose();
		        this._panner = null;
		        this._volume.dispose();
		        this._volume = null;
		        this.pan = null;
		        this.volume = null;
		        return this;
		    };
		    return Tone.PanVol;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.ScaledEnvelop is an envelope which can be scaled 
			 *         to any range. It's useful for applying an envelope 
			 *         to a frequency or any other non-NormalRange signal 
			 *         parameter. 
			 *
			 *  @extends {Tone.Envelope}
			 *  @constructor
			 *  @param {Time|Object} [attack]	the attack time in seconds
			 *  @param {Time} [decay]	the decay time in seconds
			 *  @param {number} [sustain] 	a percentage (0-1) of the full amplitude
			 *  @param {Time} [release]	the release time in seconds
			 *  @example
			 *  var scaledEnv = new Tone.ScaledEnvelope({
			 *  	"attack" : 0.2,
			 *  	"min" : 200,
			 *  	"max" : 2000
			 *  });
			 *  scaledEnv.connect(oscillator.frequency);
			 */
		    Tone.ScaledEnvelope = function () {
		        //get all of the defaults
		        var options = this.optionsObject(arguments, [
		            'attack',
		            'decay',
		            'sustain',
		            'release'
		        ], Tone.Envelope.defaults);
		        Tone.Envelope.call(this, options);
		        options = this.defaultArg(options, Tone.ScaledEnvelope.defaults);
		        /** 
				 *  scale the incoming signal by an exponent
				 *  @type {Tone.Pow}
				 *  @private
				 */
		        this._exp = this.output = new Tone.Pow(options.exponent);
		        /**
				 *  scale the signal to the desired range
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = this.output = new Tone.Scale(options.min, options.max);
		        this._sig.chain(this._exp, this._scale);
		    };
		    Tone.extend(Tone.ScaledEnvelope, Tone.Envelope);
		    /**
			 *  the default parameters
			 *  @static
			 */
		    Tone.ScaledEnvelope.defaults = {
		        'min': 0,
		        'max': 1,
		        'exponent': 1
		    };
		    /**
			 * The envelope's min output value. This is the value which it
			 * starts at. 
			 * @memberOf Tone.ScaledEnvelope#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'min', {
		        get: function () {
		            return this._scale.min;
		        },
		        set: function (min) {
		            this._scale.min = min;
		        }
		    });
		    /**
			 * The envelope's max output value. In other words, the value
			 * at the peak of the attack portion of the envelope. 
			 * @memberOf Tone.ScaledEnvelope#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'max', {
		        get: function () {
		            return this._scale.max;
		        },
		        set: function (max) {
		            this._scale.max = max;
		        }
		    });
		    /**
			 * The envelope's exponent value. 
			 * @memberOf Tone.ScaledEnvelope#
			 * @type {number}
			 * @name exponent
			 */
		    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'exponent', {
		        get: function () {
		            return this._exp.value;
		        },
		        set: function (exp) {
		            this._exp.value = exp;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.ScaledEnvelope} this
			 */
		    Tone.ScaledEnvelope.prototype.dispose = function () {
		        Tone.Envelope.prototype.dispose.call(this);
		        this._scale.dispose();
		        this._scale = null;
		        this._exp.dispose();
		        this._exp = null;
		        return this;
		    };
		    return Tone.ScaledEnvelope;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Buffer loading and storage. Tone.Buffer is used internally by all 
			 *          classes that make requests for audio files such as Tone.Player,
			 *          Tone.Sampler and Tone.Convolver.
			 *          <br><br>
			 *          Aside from load callbacks from individual buffers, Tone.Buffer 
			 *  		provides static methods which keep track of the loading progress 
			 *  		of all of the buffers. These methods are Tone.Buffer.onload, Tone.Buffer.onprogress,
			 *  		and Tone.Buffer.onerror. 
			 *
			 *  @constructor 
			 *  @extends {Tone}
			 *  @param {AudioBuffer|string} url The url to load, or the audio buffer to set. 
			 *  @param {function=} onload A callback which is invoked after the buffer is loaded. 
			 *                            It's recommended to use Tone.Buffer.onload instead 
			 *                            since it will give you a callback when ALL buffers are loaded.
			 *  @example
			 * var buffer = new Tone.Buffer("path/to/sound.mp3", function(){
			 * 	//the buffer is now available.
			 * 	var buff = buffer.get();
			 * });
			 */
		    Tone.Buffer = function () {
		        var options = this.optionsObject(arguments, [
		            'url',
		            'onload'
		        ], Tone.Buffer.defaults);
		        /**
				 *  stores the loaded AudioBuffer
				 *  @type {AudioBuffer}
				 *  @private
				 */
		        this._buffer = null;
		        /**
				 *  indicates if the buffer should be reversed or not
				 *  @type {boolean}
				 *  @private
				 */
		        this._reversed = options.reverse;
		        /**
				 *  The url of the buffer. <code>undefined</code> if it was 
				 *  constructed with a buffer
				 *  @type {string}
				 *  @readOnly
				 */
		        this.url = undefined;
		        /**
				 *  Indicates if the buffer is loaded or not. 
				 *  @type {boolean}
				 *  @readOnly
				 */
		        this.loaded = false;
		        /**
				 *  The callback to invoke when everything is loaded. 
				 *  @type {function}
				 */
		        this.onload = options.onload.bind(this, this);
		        if (options.url instanceof AudioBuffer) {
		            this._buffer.set(options.url);
		            this.onload(this);
		        } else if (typeof options.url === 'string') {
		            this.url = options.url;
		            Tone.Buffer._addToQueue(options.url, this);
		        }
		    };
		    Tone.extend(Tone.Buffer);
		    /**
			 *  the default parameters
			 *  @type {Object}
			 */
		    Tone.Buffer.defaults = {
		        'url': undefined,
		        'onload': Tone.noOp,
		        'reverse': false
		    };
		    /**
			 *  Pass in an AudioBuffer or Tone.Buffer to set the value
			 *  of this buffer.
			 *  @param {AudioBuffer|Tone.Buffer} buffer the buffer
			 *  @returns {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype.set = function (buffer) {
		        if (buffer instanceof Tone.Buffer) {
		            this._buffer = buffer.get();
		        } else {
		            this._buffer = buffer;
		        }
		        this.loaded = true;
		        return this;
		    };
		    /**
			 *  @return {AudioBuffer} The audio buffer stored in the object.
			 */
		    Tone.Buffer.prototype.get = function () {
		        return this._buffer;
		    };
		    /**
			 *  Load url into the buffer. 
			 *  @param {String} url The url to load
			 *  @param {Function=} callback The callback to invoke on load. 
			 *                              don't need to set if `onload` is
			 *                              already set.
			 *  @returns {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype.load = function (url, callback) {
		        this.url = url;
		        this.onload = this.defaultArg(callback, this.onload);
		        Tone.Buffer._addToQueue(url, this);
		        return this;
		    };
		    /**
			 *  dispose and disconnect
			 *  @returns {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        Tone.Buffer._removeFromQueue(this);
		        this._buffer = null;
		        this.onload = Tone.Buffer.defaults.onload;
		        return this;
		    };
		    /**
			 * The duration of the buffer. 
			 * @memberOf Tone.Buffer#
			 * @type {number}
			 * @name duration
			 * @readOnly
			 */
		    Object.defineProperty(Tone.Buffer.prototype, 'duration', {
		        get: function () {
		            if (this._buffer) {
		                return this._buffer.duration;
		            } else {
		                return 0;
		            }
		        }
		    });
		    /**
			 *  Reverse the buffer.
			 *  @private
			 *  @return {Tone.Buffer} this
			 */
		    Tone.Buffer.prototype._reverse = function () {
		        if (this.loaded) {
		            for (var i = 0; i < this._buffer.numberOfChannels; i++) {
		                Array.prototype.reverse.call(this._buffer.getChannelData(i));
		            }
		        }
		        return this;
		    };
		    /**
			 * Reverse the buffer.
			 * @memberOf Tone.Buffer#
			 * @type {boolean}
			 * @name reverse
			 */
		    Object.defineProperty(Tone.Buffer.prototype, 'reverse', {
		        get: function () {
		            return this._reversed;
		        },
		        set: function (rev) {
		            if (this._reversed !== rev) {
		                this._reversed = rev;
		                this._reverse();
		            }
		        }
		    });
		    ///////////////////////////////////////////////////////////////////////////
		    // STATIC METHODS
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *  the static queue for all of the xhr requests
			 *  @type {Array}
			 *  @private
			 */
		    Tone.Buffer._queue = [];
		    /**
			 *  the array of current downloads
			 *  @type {Array}
			 *  @private
			 */
		    Tone.Buffer._currentDownloads = [];
		    /**
			 *  the total number of downloads
			 *  @type {number}
			 *  @private
			 */
		    Tone.Buffer._totalDownloads = 0;
		    /**
			 *  the maximum number of simultaneous downloads
			 *  @static
			 *  @type {number}
			 */
		    Tone.Buffer.MAX_SIMULTANEOUS_DOWNLOADS = 6;
		    /**
			 *  Adds a file to be loaded to the loading queue
			 *  @param   {string}   url      the url to load
			 *  @param   {function} callback the callback to invoke once it's loaded
			 *  @private
			 */
		    Tone.Buffer._addToQueue = function (url, buffer) {
		        Tone.Buffer._queue.push({
		            url: url,
		            Buffer: buffer,
		            progress: 0,
		            xhr: null
		        });
		        this._totalDownloads++;
		        Tone.Buffer._next();
		    };
		    /**
			 *  Remove an object from the queue's (if it's still there)
			 *  Abort the XHR if it's in progress
			 *  @param {Tone.Buffer} buffer the buffer to remove
			 *  @private
			 */
		    Tone.Buffer._removeFromQueue = function (buffer) {
		        var i;
		        for (i = 0; i < Tone.Buffer._queue.length; i++) {
		            var q = Tone.Buffer._queue[i];
		            if (q.Buffer === buffer) {
		                Tone.Buffer._queue.splice(i, 1);
		            }
		        }
		        for (i = 0; i < Tone.Buffer._currentDownloads.length; i++) {
		            var dl = Tone.Buffer._currentDownloads[i];
		            if (dl.Buffer === buffer) {
		                Tone.Buffer._currentDownloads.splice(i, 1);
		                dl.xhr.abort();
		                dl.xhr.onprogress = null;
		                dl.xhr.onload = null;
		                dl.xhr.onerror = null;
		            }
		        }
		    };
		    /**
			 *  load the next buffer in the queue
			 *  @private
			 */
		    Tone.Buffer._next = function () {
		        if (Tone.Buffer._queue.length > 0) {
		            if (Tone.Buffer._currentDownloads.length < Tone.Buffer.MAX_SIMULTANEOUS_DOWNLOADS) {
		                var next = Tone.Buffer._queue.shift();
		                Tone.Buffer._currentDownloads.push(next);
		                next.xhr = Tone.Buffer.load(next.url, function (buffer) {
		                    //remove this one from the queue
		                    var index = Tone.Buffer._currentDownloads.indexOf(next);
		                    Tone.Buffer._currentDownloads.splice(index, 1);
		                    next.Buffer.set(buffer);
		                    if (next.Buffer._reversed) {
		                        next.Buffer._reverse();
		                    }
		                    next.Buffer.onload(next.Buffer);
		                    Tone.Buffer._onprogress();
		                    Tone.Buffer._next();
		                });
		                next.xhr.onprogress = function (event) {
		                    next.progress = event.loaded / event.total;
		                    Tone.Buffer._onprogress();
		                };
		                next.xhr.onerror = Tone.Buffer.onerror;
		            }
		        } else if (Tone.Buffer._currentDownloads.length === 0) {
		            Tone.Buffer.onload();
		            //reset the downloads
		            Tone.Buffer._totalDownloads = 0;
		        }
		    };
		    /**
			 *  internal progress event handler
			 *  @private
			 */
		    Tone.Buffer._onprogress = function () {
		        var curretDownloadsProgress = 0;
		        var currentDLLen = Tone.Buffer._currentDownloads.length;
		        var inprogress = 0;
		        if (currentDLLen > 0) {
		            for (var i = 0; i < currentDLLen; i++) {
		                var dl = Tone.Buffer._currentDownloads[i];
		                curretDownloadsProgress += dl.progress;
		            }
		            inprogress = curretDownloadsProgress;
		        }
		        var currentDownloadProgress = currentDLLen - inprogress;
		        var completed = Tone.Buffer._totalDownloads - Tone.Buffer._queue.length - currentDownloadProgress;
		        Tone.Buffer.onprogress(completed / Tone.Buffer._totalDownloads);
		    };
		    /**
			 *  Makes an xhr reqest for the selected url then decodes
			 *  the file as an audio buffer. Invokes
			 *  the callback once the audio buffer loads.
			 *  @param {string} url The url of the buffer to load.
			 *                      filetype support depends on the
			 *                      browser.
			 *  @param {function} callback The function to invoke when the url is loaded. 
			 *  @returns {XMLHttpRequest} returns the XHR
			 */
		    Tone.Buffer.load = function (url, callback) {
		        var request = new XMLHttpRequest();
		        request.open('GET', url, true);
		        request.responseType = 'arraybuffer';
		        // decode asynchronously
		        request.onload = function () {
		            Tone.context.decodeAudioData(request.response, function (buff) {
		                if (!buff) {
		                    throw new Error('could not decode audio data:' + url);
		                }
		                callback(buff);
		            });
		        };
		        //send the request
		        request.send();
		        return request;
		    };
		    /**
			 *  Callback when all of the buffers in the queue have loaded
			 *  @static
			 *  @function
			 *  @example
			 * //invoked when all of the queued samples are done loading
			 * Tone.Buffer.onload = function(){
			 * 	console.log("everything is loaded");
			 * };
			 */
		    Tone.Buffer.onload = Tone.noOp;
		    /**
			 *  Callback function is invoked with the progress of all of the loads in the queue. 
			 *  The value passed to the callback is between 0-1.
			 *  @static
			 *  @param {Number} percent The progress between 0 and 1. 
			 *  @function
			 *  @example
			 * Tone.Buffer.onprogress = function(percent){
			 * 	console.log("progress:" + (percent * 100).toFixed(1) + "%");
			 * };
			 */
		    Tone.Buffer.onprogress = Tone.noOp;
		    /**
			 *  Callback if one of the buffers in the queue encounters an error. The error
			 *  is passed in as the argument. 
			 *  @static
			 *  @param {Error} err
			 *  @function
			 *  @example
			 * Tone.Buffer.onerror = function(e){
			 * 	console.log("there was an error while loading the buffers: "+e);
			 * }
			 */
		    Tone.Buffer.onerror = Tone.noOp;
		    return Tone.Buffer;
		});
		Module(function (Tone) {
		    
		    /**
			 *  buses are another way of routing audio
			 *
			 *  augments Tone.prototype to include send and recieve
			 */
		    /**
			  *  All of the routes
			  *  
			  *  @type {Object}
			  *  @static
			  *  @private
			  */
		    var Buses = {};
		    /**
			 *  Send this signal to the channel name. 
			 *  @param  {string} channelName A named channel to send the signal to.
			 *  @param  {Decibels} amount The amount of the source to send to the bus. 
			 *  @return {GainNode} The gain node which connects this node to the desired channel. 
			 *                     Can be used to adjust the levels of the send.
			 *  @example
			 * source.send("reverb", -12);
			 */
		    Tone.prototype.send = function (channelName, amount) {
		        if (!Buses.hasOwnProperty(channelName)) {
		            Buses[channelName] = this.context.createGain();
		        }
		        var sendKnob = this.context.createGain();
		        sendKnob.gain.value = this.dbToGain(this.defaultArg(amount, 1));
		        this.output.chain(sendKnob, Buses[channelName]);
		        return sendKnob;
		    };
		    /**
			 *  Recieve the input from the desired channelName to the input
			 *
			 *  @param  {string} channelName A named channel to send the signal to.
			 *  @param {AudioNode} [input] If no input is selected, the
			 *                                         input of the current node is
			 *                                         chosen. 
			 *  @returns {Tone} this
			 *  @example
			 * reverbEffect.receive("reverb");
			 */
		    Tone.prototype.receive = function (channelName, input) {
		        if (!Buses.hasOwnProperty(channelName)) {
		            Buses[channelName] = this.context.createGain();
		        }
		        if (this.isUndef(input)) {
		            input = this.input;
		        }
		        Buses[channelName].connect(input);
		        return this;
		    };
		    return Tone;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  A timed note. Creating a note will register a callback 
			 *          which will be invoked on the channel at the time with
			 *          whatever value was specified. 
			 *
			 *  @constructor
			 *  @param {number|string} channel the channel name of the note
			 *  @param {Time} time the time when the note will occur
			 *  @param {string|number|Object|Array} value the value of the note
			 */
		    Tone.Note = function (channel, time, value) {
		        /**
				 *  the value of the note. This value is returned
				 *  when the channel callback is invoked.
				 *  
				 *  @type {string|number|Object}
				 */
		        this.value = value;
		        /**
				 *  the channel name or number
				 *  
				 *  @type {string|number}
				 *  @private
				 */
		        this._channel = channel;
		        /**
				 *  an internal reference to the id of the timeline
				 *  callback which is set. 
				 *  
				 *  @type {number}
				 *  @private
				 */
		        this._timelineID = Tone.Transport.setTimeline(this._trigger.bind(this), time);
		    };
		    /**
			 *  invoked by the timeline
			 *  @private
			 *  @param {number} time the time at which the note should play
			 */
		    Tone.Note.prototype._trigger = function (time) {
		        //invoke the callback
		        channelCallbacks(this._channel, time, this.value);
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Note} this
			 */
		    Tone.Note.prototype.dispose = function () {
		        Tone.Tranport.clearTimeline(this._timelineID);
		        this.value = null;
		        return this;
		    };
		    /**
			 *  @private
			 *  @static
			 *  @type {Object}
			 */
		    var NoteChannels = {};
		    /**
			 *  invoke all of the callbacks on a specific channel
			 *  @private
			 */
		    function channelCallbacks(channel, time, value) {
		        if (NoteChannels.hasOwnProperty(channel)) {
		            var callbacks = NoteChannels[channel];
		            for (var i = 0, len = callbacks.length; i < len; i++) {
		                var callback = callbacks[i];
		                if (Array.isArray(value)) {
		                    callback.apply(window, [time].concat(value));
		                } else {
		                    callback(time, value);
		                }
		            }
		        }
		    }
		    /**
			 *  listen to a specific channel, get all of the note callbacks
			 *  @static
			 *  @param {string|number} channel the channel to route note events from
			 *  @param {function(*)} callback callback to be invoked when a note will occur
			 *                                        on the specified channel
			 */
		    Tone.Note.route = function (channel, callback) {
		        if (NoteChannels.hasOwnProperty(channel)) {
		            NoteChannels[channel].push(callback);
		        } else {
		            NoteChannels[channel] = [callback];
		        }
		    };
		    /**
			 *  Remove a previously routed callback from a channel. 
			 *  @static
			 *  @param {string|number} channel The channel to unroute note events from
			 *  @param {function(*)} callback Callback which was registered to the channel.
			 */
		    Tone.Note.unroute = function (channel, callback) {
		        if (NoteChannels.hasOwnProperty(channel)) {
		            var channelCallback = NoteChannels[channel];
		            var index = channelCallback.indexOf(callback);
		            if (index !== -1) {
		                NoteChannels[channel].splice(index, 1);
		            }
		        }
		    };
		    /**
			 *  Parses a score and registers all of the notes along the timeline. 
			 *  <br><br>
			 *  Scores are a JSON object with instruments at the top level
			 *  and an array of time and values. The value of a note can be 0 or more 
			 *  parameters. 
			 *  <br><br>
			 *  The only requirement for the score format is that the time is the first (or only)
			 *  value in the array. All other values are optional and will be passed into the callback
			 *  function registered using `Note.route(channelName, callback)`.
			 *  <br><br>
			 *  To convert MIDI files to score notation, take a look at utils/MidiToScore.js
			 *
			 *  @example
			 * //an example JSON score which sets up events on channels
			 * var score = { 
			 * 	"synth"  : [["0", "C3"], ["0:1", "D3"], ["0:2", "E3"], ... ],
			 * 	"bass"  : [["0", "C2"], ["1:0", "A2"], ["2:0", "C2"], ["3:0", "A2"], ... ],
			 * 	"kick"  : ["0", "0:2", "1:0", "1:2", "2:0", ... ],
			 * 	//...
			 * };
			 * //parse the score into Notes
			 * Tone.Note.parseScore(score);
			 * //route all notes on the "synth" channel
			 * Tone.Note.route("synth", function(time, note){
			 * 	//trigger synth
			 * });
			 *  @static
			 *  @param {Object} score
			 *  @return {Array} an array of all of the notes that were created
			 */
		    Tone.Note.parseScore = function (score) {
		        var notes = [];
		        for (var inst in score) {
		            var part = score[inst];
		            if (inst === 'tempo') {
		                Tone.Transport.bpm.value = part;
		            } else if (inst === 'timeSignature') {
		                Tone.Transport.timeSignature = part[0] / (part[1] / 4);
		            } else if (Array.isArray(part)) {
		                for (var i = 0; i < part.length; i++) {
		                    var noteDescription = part[i];
		                    var note;
		                    if (Array.isArray(noteDescription)) {
		                        var time = noteDescription[0];
		                        var value = noteDescription.slice(1);
		                        note = new Tone.Note(inst, time, value);
		                    } else {
		                        note = new Tone.Note(inst, noteDescription);
		                    }
		                    notes.push(note);
		                }
		            } else {
		                throw new TypeError('score parts must be Arrays');
		            }
		        }
		        return notes;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    //	MUSIC NOTES
		    //	
		    //	Augments Tone.prototype to include note methods
		    ///////////////////////////////////////////////////////////////////////////
		    var noteToIndex = {
		        'c': 0,
		        'c#': 1,
		        'db': 1,
		        'd': 2,
		        'd#': 3,
		        'eb': 3,
		        'e': 4,
		        'f': 5,
		        'f#': 6,
		        'gb': 6,
		        'g': 7,
		        'g#': 8,
		        'ab': 8,
		        'a': 9,
		        'a#': 10,
		        'bb': 10,
		        'b': 11
		    };
		    var noteIndexToNote = [
		        'C',
		        'C#',
		        'D',
		        'D#',
		        'E',
		        'F',
		        'F#',
		        'G',
		        'G#',
		        'A',
		        'A#',
		        'B'
		    ];
		    var middleC = 261.6255653005986;
		    /**
			 *  Convert a note name to frequency. 
			 *  @param  {string} note
			 *  @return {number}     
			 *  @example
			 * var freq = tone.noteToFrequency("A4"); //returns 440
			 */
		    Tone.prototype.noteToFrequency = function (note) {
		        //break apart the note by frequency and octave
		        var parts = note.split(/(\d+)/);
		        if (parts.length === 3) {
		            var index = noteToIndex[parts[0].toLowerCase()];
		            var octave = parts[1];
		            var noteNumber = index + parseInt(octave, 10) * 12;
		            return Math.pow(2, (noteNumber - 48) / 12) * middleC;
		        } else {
		            return 0;
		        }
		    };
		    /**
			 *  Test if a string is in note format: i.e. "C4". 
			 *  @param  {string|number}  note The note to test
			 *  @return {boolean}      true if it's in the form of a note
			 *  @method isNotation
			 *  @lends Tone.prototype.isNote
			 *  @function
			 */
		    Tone.prototype.isNote = function () {
		        var noteFormat = new RegExp(/[a-g]{1}([b#]{1}|[b#]{0})[0-9]+$/i);
		        return function (note) {
		            if (typeof note === 'string') {
		                note = note.toLowerCase();
		            }
		            return noteFormat.test(note);
		        };
		    }();
		    /**
			 *  A pointer to the previous toFrequency method
			 *  @private
			 *  @function
			 */
		    Tone.prototype._overwrittenToFrequency = Tone.prototype.toFrequency;
		    /**
			 *  A method which accepts frequencies in the form
			 *  of notes (`"C#4"`), frequencies as strings ("49hz"), frequency numbers,
			 *  or Time and converts them to their frequency as a number in hertz.
			 *  @param  {Frequency} note the note name or notation
			 *  @param {number=} 	now 	if passed in, this number will be 
			 *                        		used for all 'now' relative timings
			 *  @return {number}      the frequency as a number
			 */
		    Tone.prototype.toFrequency = function (note, now) {
		        if (this.isNote(note)) {
		            note = this.noteToFrequency(note);
		        }
		        return this._overwrittenToFrequency(note, now);
		    };
		    /**
			 *  Convert a frequency to a note name (i.e. A4, C#5).
			 *  @param  {number} freq
			 *  @return {string}         
			 */
		    Tone.prototype.frequencyToNote = function (freq) {
		        var log = Math.log(freq / middleC) / Math.LN2;
		        var noteNumber = Math.round(12 * log) + 48;
		        var octave = Math.floor(noteNumber / 12);
		        var noteName = noteIndexToNote[noteNumber % 12];
		        return noteName + octave.toString();
		    };
		    /**
			 *  Convert an interval (in semitones) to a frequency ratio.
			 *
			 *  @param  {Interval} interval the number of semitones above the base note
			 *  @return {number}          the frequency ratio
			 *  @example
			 * tone.intervalToFrequencyRatio(0); // returns 1
			 * tone.intervalToFrequencyRatio(12); // returns 2
			 */
		    Tone.prototype.intervalToFrequencyRatio = function (interval) {
		        return Math.pow(2, interval / 12);
		    };
		    /**
			 *  Convert a midi note number into a note name. 
			 *
			 *  @param  {MIDI} midiNumber the midi note number
			 *  @return {string}            the note's name and octave
			 *  @example
			 * tone.midiToNote(60); // returns "C3"
			 */
		    Tone.prototype.midiToNote = function (midiNumber) {
		        var octave = Math.floor(midiNumber / 12) - 2;
		        var note = midiNumber % 12;
		        return noteIndexToNote[note] + octave;
		    };
		    /**
			 *  Convert a note to it's midi value. 
			 *
			 *  @param  {string} note the note name (i.e. "C3")
			 *  @return {MIDI} the midi value of that note
			 *  @example
			 * tone.noteToMidi("C3"); // returns 60
			 */
		    Tone.prototype.noteToMidi = function (note) {
		        //break apart the note by frequency and octave
		        var parts = note.split(/(\d+)/);
		        if (parts.length === 3) {
		            var index = noteToIndex[parts[0].toLowerCase()];
		            var octave = parts[1];
		            return index + (parseInt(octave, 10) + 2) * 12;
		        } else {
		            return 0;
		        }
		    };
		    return Tone.Note;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.PulseOscillator is a pulse oscillator with control over pulse width,
			 *         also known as the duty cycle. At 50% duty cycle (width = 0.5) the wave is 
			 *         a square and only odd-numbered harmonics are present. At all other widths 
			 *         even-numbered harmonics are present. Read more 
			 *         [here](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).
			 *
			 *  @constructor
			 *  @extends {Tone.Oscillator}
			 *  @param {Frequency} [frequency] The frequency of the oscillator
			 *  @param {NormalRange} [width] The width of the pulse
			 *  @example
			 * var pulse = new Tone.PulseOscillator("E5", 0.4).toMaster().start();
			 */
		    Tone.PulseOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'width'
		        ], Tone.Oscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  The width of the pulse. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);
		        /**
				 *  gate the width amount
				 *  @type {GainNode}
				 *  @private
				 */
		        this._widthGate = this.context.createGain();
		        /**
				 *  the sawtooth oscillator
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this._sawtooth = new Tone.Oscillator({
		            frequency: options.frequency,
		            detune: options.detune,
		            type: 'sawtooth',
		            phase: options.phase
		        });
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this._sawtooth.frequency;
		        /**
				 *  The detune in cents. 
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this._sawtooth.detune;
		        /**
				 *  Threshold the signal to turn it into a square
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._thresh = new Tone.WaveShaper(function (val) {
		            if (val < 0) {
		                return -1;
		            } else {
		                return 1;
		            }
		        });
		        //connections
		        this._sawtooth.chain(this._thresh, this.output);
		        this.width.chain(this._widthGate, this._thresh);
		        this._readOnly([
		            'width',
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.PulseOscillator, Tone.Oscillator);
		    /**
			 *  The default parameters.
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.PulseOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'phase': 0,
		        'width': 0.2
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} time 
			 *  @private
			 */
		    Tone.PulseOscillator.prototype._start = function (time) {
		        time = this.toSeconds(time);
		        this._sawtooth.start(time);
		        this._widthGate.gain.setValueAtTime(1, time);
		    };
		    /**
			 *  stop the oscillator
			 *  @param  {Time} time 
			 *  @private
			 */
		    Tone.PulseOscillator.prototype._stop = function (time) {
		        time = this.toSeconds(time);
		        this._sawtooth.stop(time);
		        //the width is still connected to the output. 
		        //that needs to be stopped also
		        this._widthGate.gain.setValueAtTime(0, time);
		    };
		    /**
			 * The phase of the oscillator in degrees.
			 * @memberOf Tone.PulseOscillator#
			 * @type {Degrees}
			 * @name phase
			 */
		    Object.defineProperty(Tone.PulseOscillator.prototype, 'phase', {
		        get: function () {
		            return this._sawtooth.phase;
		        },
		        set: function (phase) {
		            this._sawtooth.phase = phase;
		        }
		    });
		    /**
			 * The type of the oscillator. Always returns "pulse".
			 * @readOnly
			 * @memberOf Tone.PulseOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.PulseOscillator.prototype, 'type', {
		        get: function () {
		            return 'pulse';
		        }
		    });
		    /**
			 *  Clean up method.
			 *  @return {Tone.PulseOscillator} this
			 */
		    Tone.PulseOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._sawtooth.dispose();
		        this._sawtooth = null;
		        this._writable([
		            'width',
		            'frequency',
		            'detune'
		        ]);
		        this.width.dispose();
		        this.width = null;
		        this._widthGate.disconnect();
		        this._widthGate = null;
		        this._widthGate = null;
		        this._thresh.disconnect();
		        this._thresh = null;
		        this.frequency = null;
		        this.detune = null;
		        return this;
		    };
		    return Tone.PulseOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.PWMOscillator modulates the width of a Tone.PulseOscillator 
			 *         at the modulationFrequency. This has the effect of continuously
			 *         changing the timbre of the oscillator by altering the harmonics 
			 *         generated.
			 *
			 *  @extends {Tone.Oscillator}
			 *  @constructor
			 *  @param {Frequency} frequency The starting frequency of the oscillator. 
			 *  @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse. 
			 *  @example
			 *  var pwm = new Tone.PWMOscillator("Ab3", 0.3).toMaster().start();
			 */
		    Tone.PWMOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'modulationFrequency'
		        ], Tone.PWMOscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  the pulse oscillator
				 *  @type {Tone.PulseOscillator}
				 *  @private
				 */
		        this._pulse = new Tone.PulseOscillator(options.modulationFrequency);
		        //change the pulse oscillator type
		        this._pulse._sawtooth.type = 'sine';
		        /**
				 *  the modulator
				 *  @type {Tone.Oscillator}
				 *  @private
				 */
		        this._modulator = new Tone.Oscillator({
		            'frequency': options.frequency,
		            'detune': options.detune
		        });
		        /**
				 *  Scale the oscillator so it doesn't go silent 
				 *  at the extreme values.
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._scale = new Tone.Multiply(1.01);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this._modulator.frequency;
		        /**
				 *  The detune of the oscillator.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this._modulator.detune;
		        /**
				 *  The modulation rate of the oscillator. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.modulationFrequency = this._pulse.frequency;
		        //connections
		        this._modulator.chain(this._scale, this._pulse.width);
		        this._pulse.connect(this.output);
		        this._readOnly([
		            'modulationFrequency',
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.PWMOscillator, Tone.Oscillator);
		    /**
			 *  default values
			 *  @static
			 *  @type {Object}
			 *  @const
			 */
		    Tone.PWMOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'modulationFrequency': 0.4
		    };
		    /**
			 *  start the oscillator
			 *  @param  {Time} [time=now]
			 *  @private
			 */
		    Tone.PWMOscillator.prototype._start = function (time) {
		        time = this.toSeconds(time);
		        this._modulator.start(time);
		        this._pulse.start(time);
		    };
		    /**
			 *  stop the oscillator
			 *  @param  {Time} time (optional) timing parameter
			 *  @private
			 */
		    Tone.PWMOscillator.prototype._stop = function (time) {
		        time = this.toSeconds(time);
		        this._modulator.stop(time);
		        this._pulse.stop(time);
		    };
		    /**
			 * The type of the oscillator. Always returns "pwm".
			 * @readOnly
			 * @memberOf Tone.PWMOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.PWMOscillator.prototype, 'type', {
		        get: function () {
		            return 'pwm';
		        }
		    });
		    /**
			 * The phase of the oscillator in degrees.
			 * @memberOf Tone.PWMOscillator#
			 * @type {number}
			 * @name phase
			 */
		    Object.defineProperty(Tone.PWMOscillator.prototype, 'phase', {
		        get: function () {
		            return this._modulator.phase;
		        },
		        set: function (phase) {
		            this._modulator.phase = phase;
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return {Tone.PWMOscillator} this
			 */
		    Tone.PWMOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._pulse.dispose();
		        this._pulse = null;
		        this._scale.dispose();
		        this._scale = null;
		        this._modulator.dispose();
		        this._modulator = null;
		        this._writable([
		            'modulationFrequency',
		            'frequency',
		            'detune'
		        ]);
		        this.frequency = null;
		        this.detune = null;
		        this.modulationFrequency = null;
		        return this;
		    };
		    return Tone.PWMOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,
			 *         and Tone.PWMOscillator into one class, allowing it to have the 
			 *         types: sine, square, triangle, sawtooth, pulse or pwm. Additionally,
			 *         OmniOscillator is capable of setting the first x number of partials 
			 *         of the oscillator. For example: "sine4" would set be the first 4 
			 *         partials of the sine wave and "triangle8" would set the first 
			 *         8 partials of the triangle wave. 
			 *
			 *  @extends {Tone.Oscillator}
			 *  @constructor
			 *  @param {Frequency} frequency The initial frequency of the oscillator.
			 *  @param {string} type The type of the oscillator.
			 *  @example
			 *  var omniOsc = new Tone.OmniOscillator("C#4", "pwm");
			 */
		    Tone.OmniOscillator = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'type'
		        ], Tone.OmniOscillator.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);
		        /**
				 *  The detune control
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);
		        /**
				 *  the type of the oscillator source
				 *  @type {string}
				 *  @private
				 */
		        this._sourceType = undefined;
		        /**
				 *  the oscillator
				 *  @type {Tone.Oscillator|Tone.PWMOscillator|Tone.PulseOscillator}
				 *  @private
				 */
		        this._oscillator = null;
		        //set the oscillator
		        this.type = options.type;
		        this._readOnly([
		            'frequency',
		            'detune'
		        ]);
		    };
		    Tone.extend(Tone.OmniOscillator, Tone.Oscillator);
		    /**
			 *  default values
			 *  @static
			 *  @type {Object}
			 *  @const
			 */
		    Tone.OmniOscillator.defaults = {
		        'frequency': 440,
		        'detune': 0,
		        'type': 'sine',
		        'width': 0.4,
		        //only applies if the oscillator is set to "pulse",
		        'modulationFrequency': 0.4
		    };
		    /**
			 *  @enum {string}
			 *  @private
			 */
		    var OmniOscType = {
		        PulseOscillator: 'PulseOscillator',
		        PWMOscillator: 'PWMOscillator',
		        Oscillator: 'Oscillator'
		    };
		    /**
			 *  start the oscillator
			 *  @param {Time} [time=now] the time to start the oscillator
			 *  @private
			 */
		    Tone.OmniOscillator.prototype._start = function (time) {
		        this._oscillator.start(time);
		    };
		    /**
			 *  start the oscillator
			 *  @param {Time} [time=now] the time to start the oscillator
			 *  @private
			 */
		    Tone.OmniOscillator.prototype._stop = function (time) {
		        this._oscillator.stop(time);
		    };
		    /**
			 * The type of the oscillator. sine, square, triangle, sawtooth, pwm, or pulse. 
			 * @memberOf Tone.OmniOscillator#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'type', {
		        get: function () {
		            return this._oscillator.type;
		        },
		        set: function (type) {
		            if (type.indexOf('sine') === 0 || type.indexOf('square') === 0 || type.indexOf('triangle') === 0 || type.indexOf('sawtooth') === 0) {
		                if (this._sourceType !== OmniOscType.Oscillator) {
		                    this._sourceType = OmniOscType.Oscillator;
		                    this._createNewOscillator(Tone.Oscillator);
		                }
		                this._oscillator.type = type;
		            } else if (type === 'pwm') {
		                if (this._sourceType !== OmniOscType.PWMOscillator) {
		                    this._sourceType = OmniOscType.PWMOscillator;
		                    this._createNewOscillator(Tone.PWMOscillator);
		                }
		            } else if (type === 'pulse') {
		                if (this._sourceType !== OmniOscType.PulseOscillator) {
		                    this._sourceType = OmniOscType.PulseOscillator;
		                    this._createNewOscillator(Tone.PulseOscillator);
		                }
		            } else {
		                throw new TypeError('Tone.OmniOscillator does not support type ' + type);
		            }
		        }
		    });
		    /**
			 *  connect the oscillator to the frequency and detune signals
			 *  @private
			 */
		    Tone.OmniOscillator.prototype._createNewOscillator = function (OscillatorConstructor) {
		        //short delay to avoid clicks on the change
		        var now = this.now() + this.bufferTime;
		        if (this._oscillator !== null) {
		            var oldOsc = this._oscillator;
		            oldOsc.stop(now);
		            oldOsc.onended = function () {
		                oldOsc.dispose();
		                oldOsc = null;
		            };
		        }
		        this._oscillator = new OscillatorConstructor();
		        this.frequency.connect(this._oscillator.frequency);
		        this.detune.connect(this._oscillator.detune);
		        this._oscillator.connect(this.output);
		        if (this.state === Tone.State.Started) {
		            this._oscillator.start(now);
		        }
		    };
		    /**
			 * The phase of the oscillator in degrees. 
			 * @memberOf Tone.OmniOscillator#
			 * @type {Degrees}
			 * @name phase
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'phase', {
		        get: function () {
		            return this._oscillator.phase;
		        },
		        set: function (phase) {
		            this._oscillator.phase = phase;
		        }
		    });
		    /**
			 * The width of the oscillator (only if the oscillator is set to pulse)
			 * @memberOf Tone.OmniOscillator#
			 * @type {NormalRange}
			 * @signal
			 * @name width
			 * @example
			 * var omniOsc = new Tone.OmniOscillator(440, "pulse");
			 * //can access the width attribute only if type === "pulse"
			 * omniOsc.width.value = 0.2; 
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'width', {
		        get: function () {
		            if (this._sourceType === OmniOscType.PulseOscillator) {
		                return this._oscillator.width;
		            }
		        }
		    });
		    /**
			 * The modulationFrequency Signal of the oscillator 
			 * (only if the oscillator type is set to pwm).
			 * @memberOf Tone.OmniOscillator#
			 * @type {Frequency}
			 * @signal
			 * @name modulationFrequency
			 * @example
			 * var omniOsc = new Tone.OmniOscillator(440, "pwm");
			 * //can access the modulationFrequency attribute only if type === "pwm"
			 * omniOsc.modulationFrequency.value = 0.2; 
			 */
		    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationFrequency', {
		        get: function () {
		            if (this._sourceType === OmniOscType.PWMOscillator) {
		                return this._oscillator.modulationFrequency;
		            }
		        }
		    });
		    /**
			 *  Clean up.
			 *  @return {Tone.OmniOscillator} this
			 */
		    Tone.OmniOscillator.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'detune'
		        ]);
		        this.detune.dispose();
		        this.detune = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this._oscillator.dispose();
		        this._oscillator = null;
		        this._sourceType = null;
		        return this;
		    };
		    return Tone.OmniOscillator;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Base-class for all instruments
			 *  
			 *  @constructor
			 *  @extends {Tone}
			 */
		    Tone.Instrument = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.Instrument.defaults);
		        /**
				 *  the output
				 *  @type {GainNode}
				 *  @private
				 */
		        this.output = this.context.createGain();
		        /**
				 * The volume of the instrument.
				 * @type {Decibels}
				 * @signal
				 */
		        this.volume = new Tone.Signal({
		            'param': this.output.gain,
		            'units': Tone.Type.Decibels,
		            'value': options.volume
		        });
		        this._readOnly(['volume']);
		    };
		    Tone.extend(Tone.Instrument);
		    /**
			 *  the default attributes
			 *  @type {object}
			 */
		    Tone.Instrument.defaults = {
		        /** the volume of the output in decibels */
		        'volume': 0
		    };
		    /**
			 *  @abstract
			 *  @param {string|number} note the note to trigger
			 *  @param {Time} [time=now] the time to trigger the ntoe
			 *  @param {number} [velocity=1] the velocity to trigger the note
			 */
		    Tone.Instrument.prototype.triggerAttack = Tone.noOp;
		    /**
			 *  @abstract
			 *  @param {Time} [time=now] when to trigger the release
			 */
		    Tone.Instrument.prototype.triggerRelease = Tone.noOp;
		    /**
			 *  Trigger the attack and then the release after the duration. 
			 *  @param  {Frequency} note     The note to trigger.
			 *  @param  {Time} duration How long the note should be held for before
			 *                          triggering the release.
			 *  @param {Time} [time=now]  When the note should be triggered.
			 *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.
			 *  @returns {Tone.Instrument} this
			 *  @example
			 * //trigger "C4" for the duration of an 8th note
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {
		        time = this.toSeconds(time);
		        duration = this.toSeconds(duration);
		        this.triggerAttack(note, time, velocity);
		        this.triggerRelease(time + duration);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Instrument} this
			 */
		    Tone.Instrument.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable(['volume']);
		        this.volume.dispose();
		        this.volume = null;
		        return this;
		    };
		    return Tone.Instrument;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  This is a base class for monophonic instruments. 
			 *
			 *  @constructor
			 *  @abstract
			 *  @extends {Tone.Instrument}
			 */
		    Tone.Monophonic = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.Monophonic.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The glide time between notes. 
				 *  @type {Time}
				 */
		        this.portamento = options.portamento;
		    };
		    Tone.extend(Tone.Monophonic, Tone.Instrument);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Monophonic.defaults = { 'portamento': 0 };
		    /**
			 *  Trigger the attack of the note optionally with a given velocity. 
			 *  
			 *  
			 *  @param  {Frequency} note     The note to trigger.
			 *  @param  {Time} [time=now]     When the note should start.
			 *  @param  {number} [velocity=1] velocity The velocity scaler 
			 *                                determines how "loud" the note 
			 *                                will be triggered.
			 *  @returns {Tone.Monophonic} this
			 *  @example
			 * synth.triggerAttack("C4");
			 *  @example
			 * //trigger the note a half second from now at half velocity
			 * synth.triggerAttack("C4", "+0.5", 0.5);
			 */
		    Tone.Monophonic.prototype.triggerAttack = function (note, time, velocity) {
		        time = this.toSeconds(time);
		        this._triggerEnvelopeAttack(time, velocity);
		        this.setNote(note, time);
		        return this;
		    };
		    /**
			 *  Trigger the release portion of the envelope
			 *  @param  {Time} [time=now] If no time is given, the release happens immediatly
			 *  @returns {Tone.Monophonic} this
			 *  @example
			 * synth.triggerRelease();
			 */
		    Tone.Monophonic.prototype.triggerRelease = function (time) {
		        this._triggerEnvelopeRelease(time);
		        return this;
		    };
		    /**
			 *  override this method with the actual method
			 *  @abstract
			 *  @private
			 */
		    Tone.Monophonic.prototype._triggerEnvelopeAttack = function () {
		    };
		    /**
			 *  override this method with the actual method
			 *  @abstract
			 *  @private
			 */
		    Tone.Monophonic.prototype._triggerEnvelopeRelease = function () {
		    };
		    /**
			 *  Set the note at the given time. If no time is given, the note
			 *  will set immediately. 
			 *  @param {Frequency} note The note to change to.
			 *  @param  {Time} [time=now] The time when the note should be set. 
			 *  @returns {Tone.Monophonic} this
			 * @example
			 * //change to F#6 in one quarter note from now.
			 * synth.setNote("F#6", "+4n");
			 * @example
			 * //change to Bb4 right now
			 * synth.setNote("Bb4");
			 */
		    Tone.Monophonic.prototype.setNote = function (note, time) {
		        time = this.toSeconds(time);
		        if (this.portamento > 0) {
		            var currentNote = this.frequency.value;
		            this.frequency.setValueAtTime(currentNote, time);
		            var portTime = this.toSeconds(this.portamento);
		            this.frequency.exponentialRampToValueAtTime(note, time + portTime);
		        } else {
		            this.frequency.setValueAtTime(note, time);
		        }
		        return this;
		    };
		    return Tone.Monophonic;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.MonoSynth is composed of one oscillator, one filter, and two envelopes.
			 *          The amplitude of the Tone.Oscillator and the cutoff frequency of the 
			 *          Tone.Filter are controlled by Tone.Envelopes. 
			 *          <img src="https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240">
			 *          
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.MonoSynth({
			 * 	"oscillator" : {
			 * 		"type" : "square"
			 *  },
			 *  "envelope" : {
			 *  	"attack" : 0.1
			 *  }
			 * }).toMaster();
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.MonoSynth = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.MonoSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The oscillator.
				 *  @type {Tone.OmniOscillator}
				 */
		        this.oscillator = new Tone.OmniOscillator(options.oscillator);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this.oscillator.frequency;
		        /**
				 *  The detune control.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this.oscillator.detune;
		        /**
				 *  The filter.
				 *  @type {Tone.Filter}
				 */
		        this.filter = new Tone.Filter(options.filter);
		        /**
				 *  The filter envelope.
				 *  @type {Tone.ScaledEnvelope}
				 */
		        this.filterEnvelope = new Tone.ScaledEnvelope(options.filterEnvelope);
		        /**
				 *  The amplitude envelope.
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        //connect the oscillators to the output
		        this.oscillator.chain(this.filter, this.envelope, this.output);
		        //start the oscillators
		        this.oscillator.start();
		        //connect the filter envelope
		        this.filterEnvelope.connect(this.filter.frequency);
		        this._readOnly([
		            'oscillator',
		            'frequency',
		            'detune',
		            'filter',
		            'filterEnvelope',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.MonoSynth, Tone.Monophonic);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.MonoSynth.defaults = {
		        'frequency': 'C4',
		        'detune': 0,
		        'oscillator': { 'type': 'square' },
		        'filter': {
		            'Q': 6,
		            'type': 'lowpass',
		            'rolloff': -24
		        },
		        'envelope': {
		            'attack': 0.005,
		            'decay': 0.1,
		            'sustain': 0.9,
		            'release': 1
		        },
		        'filterEnvelope': {
		            'attack': 0.06,
		            'decay': 0.2,
		            'sustain': 0.5,
		            'release': 2,
		            'min': 20,
		            'max': 4000,
		            'exponent': 2
		        }
		    };
		    /**
			 *  start the attack portion of the envelope
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.MonoSynth} this
			 *  @private
			 */
		    Tone.MonoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        this.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  start the release portion of the envelope
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.MonoSynth} this
			 *  @private
			 */
		    Tone.MonoSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        this.filterEnvelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.MonoSynth} this
			 */
		    Tone.MonoSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'oscillator',
		            'frequency',
		            'detune',
		            'filter',
		            'filterEnvelope',
		            'envelope'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        this.filterEnvelope.dispose();
		        this.filterEnvelope = null;
		        this.filter.dispose();
		        this.filter = null;
		        this.frequency = null;
		        this.detune = null;
		        return this;
		    };
		    return Tone.MonoSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  AMSynth uses the output of one Tone.MonoSynth to modulate the
			 *          amplitude of another Tone.MonoSynth. The harmonicity (the ratio between
			 *          the two signals) affects the timbre of the output signal the most.
			 *          Read more about Amplitude Modulation Synthesis on 
			 *          [SoundOnSound](http://www.soundonsound.com/sos/mar00/articles/synthsecrets.htm).
			 *          <img src="https://docs.google.com/drawings/d/1TQu8Ed4iFr1YTLKpB3U1_hur-UwBrh5gdBXc8BxfGKw/pub?w=1009&h=457">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                            see defaults below
			 *  @example
			 * var synth = new Tone.AMSynth().toMaster();
			 * synth.triggerAttackRelease("C4", "4n");
			 */
		    Tone.AMSynth = function (options) {
		        options = this.defaultArg(options, Tone.AMSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The carrier voice. 
				 *  @type {Tone.MonoSynth}
				 */
		        this.carrier = new Tone.MonoSynth(options.carrier);
		        this.carrier.volume.value = -10;
		        /**
				 *  The modulator voice. 
				 *  @type {Tone.MonoSynth}
				 */
		        this.modulator = new Tone.MonoSynth(options.modulator);
		        this.modulator.volume.value = -10;
		        /**
				 *  The frequency.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * synth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  convert the -1,1 output to 0,1
				 *  @type {Tone.AudioToGain}
				 *  @private
				 */
		        this._modulationScale = new Tone.AudioToGain();
		        /**
				 *  the node where the modulation happens
				 *  @type {GainNode}
				 *  @private
				 */
		        this._modulationNode = this.context.createGain();
		        //control the two voices frequency
		        this.frequency.connect(this.carrier.frequency);
		        this.frequency.chain(this.harmonicity, this.modulator.frequency);
		        this.modulator.chain(this._modulationScale, this._modulationNode.gain);
		        this.carrier.chain(this._modulationNode, this.output);
		        this._readOnly([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity'
		        ]);
		    };
		    Tone.extend(Tone.AMSynth, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AMSynth.defaults = {
		        'harmonicity': 3,
		        'carrier': {
		            'volume': -10,
		            'oscillator': { 'type': 'sine' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0.01,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5,
		                'min': 20000,
		                'max': 20000
		            },
		            'filter': {
		                'Q': 6,
		                'type': 'lowpass',
		                'rolloff': -24
		            }
		        },
		        'modulator': {
		            'volume': -10,
		            'oscillator': { 'type': 'square' },
		            'envelope': {
		                'attack': 2,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'filterEnvelope': {
		                'attack': 4,
		                'decay': 0.2,
		                'sustain': 0.5,
		                'release': 0.5,
		                'min': 20,
		                'max': 1500
		            },
		            'filter': {
		                'Q': 6,
		                'type': 'lowpass',
		                'rolloff': -24
		            }
		        }
		    };
		    /**
			 *  trigger the attack portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will occur
			 *  @param {NormalRange} [velocity=1] the velocity of the note
			 *  @private
			 *  @returns {Tone.AMSynth} this
			 */
		    Tone.AMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the port glide
		        time = this.toSeconds(time);
		        //the envelopes
		        this.carrier.envelope.triggerAttack(time, velocity);
		        this.modulator.envelope.triggerAttack(time);
		        this.carrier.filterEnvelope.triggerAttack(time);
		        this.modulator.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  trigger the release portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @private
			 *  @returns {Tone.AMSynth} this
			 */
		    Tone.AMSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.carrier.triggerRelease(time);
		        this.modulator.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.AMSynth} this
			 */
		    Tone.AMSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity'
		        ]);
		        this.carrier.dispose();
		        this.carrier = null;
		        this.modulator.dispose();
		        this.modulator = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._modulationScale.dispose();
		        this._modulationScale = null;
		        this._modulationNode.disconnect();
		        this._modulationNode = null;
		        return this;
		    };
		    return Tone.AMSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.DrumSynth makes kick and tom sounds using a single oscillator
			 *          with an amplitude envelope and frequency ramp. A Tone.Oscillator
			 *          is routed through a Tone.AmplitudeEnvelope to the output. The drum
			 *          quality of the sound comes from the frequency envelope applied
			 *          during during Tone.DrumSynth.triggerAttack(note). The frequency
			 *          envelope starts at <code>note * .octaves</code> and ramps to 
			 *          <code>note</code> over the duration of <code>.pitchDecay</code>. 
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.DrumSynth().toMaster();
			 * synth.triggerAttackRelease("C2", "8n");
			 */
		    Tone.DrumSynth = function (options) {
		        options = this.defaultArg(options, Tone.DrumSynth.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The oscillator.
				 *  @type {Tone.Oscillator}
				 */
		        this.oscillator = new Tone.Oscillator(options.oscillator).start();
		        /**
				 *  The amplitude envelope.
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        /**
				 *  The number of octaves the pitch envelope ramps.
				 *  @type {Positive}
				 */
		        this.octaves = options.octaves;
		        /**
				 *  The amount of time the frequency envelope takes. 
				 *  @type {Time}
				 */
		        this.pitchDecay = options.pitchDecay;
		        this.oscillator.chain(this.envelope, this.output);
		        this._readOnly([
		            'oscillator',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.DrumSynth, Tone.Instrument);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.DrumSynth.defaults = {
		        'pitchDecay': 0.05,
		        'octaves': 10,
		        'oscillator': { 'type': 'sine' },
		        'envelope': {
		            'attack': 0.001,
		            'decay': 0.4,
		            'sustain': 0.01,
		            'release': 1.4,
		            'attackCurve': 'exponential'
		        }
		    };
		    /**
			 *  Trigger the note at the given time with the given velocity. 
			 *  
			 *  @param  {Frequency} note     the note
			 *  @param  {Time} [time=now]     the time, if not given is now
			 *  @param  {number} [velocity=1] velocity defaults to 1
			 *  @returns {Tone.DrumSynth} this
			 *  @example
			 *  kick.triggerAttack(60);
			 */
		    Tone.DrumSynth.prototype.triggerAttack = function (note, time, velocity) {
		        time = this.toSeconds(time);
		        note = this.toFrequency(note);
		        var maxNote = note * this.octaves;
		        this.oscillator.frequency.setValueAtTime(maxNote, time);
		        this.oscillator.frequency.exponentialRampToValueAtTime(note, time + this.toSeconds(this.pitchDecay));
		        this.envelope.triggerAttack(time, velocity);
		        return this;
		    };
		    /**
			 *  Trigger the release portion of the note.
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @returns {Tone.DrumSynth} this
			 */
		    Tone.DrumSynth.prototype.triggerRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.DrumSynth} this
			 */
		    Tone.DrumSynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._writable([
		            'oscillator',
		            'envelope'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        return this;
		    };
		    return Tone.DrumSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.DuoSynth is a monophonic synth composed of two 
			 *          MonoSynths run in parallel with control over the 
			 *          frequency ratio between the two voices and vibrato effect.
			 *          <img src="https://docs.google.com/drawings/d/1bL4GXvfRMMlqS7XyBm9CjL9KJPSUKbcdBNpqOlkFLxk/pub?w=1012&h=448">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var duoSynth = new Tone.DuoSynth().toMaster();
			 * duoSynth.triggerAttackRelease("C4", "2n");
			 */
		    Tone.DuoSynth = function (options) {
		        options = this.defaultArg(options, Tone.DuoSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  the first voice
				 *  @type {Tone.MonoSynth}
				 */
		        this.voice0 = new Tone.MonoSynth(options.voice0);
		        this.voice0.volume.value = -10;
		        /**
				 *  the second voice
				 *  @type {Tone.MonoSynth}
				 */
		        this.voice1 = new Tone.MonoSynth(options.voice1);
		        this.voice1.volume.value = -10;
		        /**
				 *  The vibrato LFO. 
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._vibrato = new Tone.LFO(options.vibratoRate, -50, 50);
		        this._vibrato.start();
		        /**
				 * the vibrato frequency
				 * @type {Frequency}
				 * @signal
				 */
		        this.vibratoRate = this._vibrato.frequency;
		        /**
				 *  the vibrato gain
				 *  @type {GainNode}
				 *  @private
				 */
		        this._vibratoGain = this.context.createGain();
		        /**
				 * The amount of vibrato
				 * @type {Gain}
				 * @signal
				 */
		        this.vibratoAmount = new Tone.Signal(this._vibratoGain.gain, Tone.Type.Gain);
		        this.vibratoAmount.value = options.vibratoAmount;
		        /**
				 *  the delay before the vibrato starts
				 *  @type {number}
				 *  @private
				 */
		        this._vibratoDelay = this.toSeconds(options.vibratoDelay);
		        /**
				 *  the frequency control
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * duoSynth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        //control the two voices frequency
		        this.frequency.connect(this.voice0.frequency);
		        this.frequency.chain(this.harmonicity, this.voice1.frequency);
		        this._vibrato.connect(this._vibratoGain);
		        this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);
		        this.voice0.connect(this.output);
		        this.voice1.connect(this.output);
		        this._readOnly([
		            'voice0',
		            'voice1',
		            'frequency',
		            'vibratoAmount',
		            'vibratoRate'
		        ]);
		    };
		    Tone.extend(Tone.DuoSynth, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.DuoSynth.defaults = {
		        'vibratoAmount': 0.5,
		        'vibratoRate': 5,
		        'vibratoDelay': 1,
		        'harmonicity': 1.5,
		        'voice0': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            }
		        },
		        'voice1': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            }
		        }
		    };
		    /**
			 *  start the attack portion of the envelopes
			 *  
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.DuoSynth} this
			 *  @private
			 */
		    Tone.DuoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        time = this.toSeconds(time);
		        this.voice0.envelope.triggerAttack(time, velocity);
		        this.voice1.envelope.triggerAttack(time, velocity);
		        this.voice0.filterEnvelope.triggerAttack(time);
		        this.voice1.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  start the release portion of the envelopes
			 *  
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.DuoSynth} this
			 *  @private
			 */
		    Tone.DuoSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.voice0.triggerRelease(time);
		        this.voice1.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.DuoSynth} this
			 */
		    Tone.DuoSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'voice0',
		            'voice1',
		            'frequency',
		            'vibratoAmount',
		            'vibratoRate'
		        ]);
		        this.voice0.dispose();
		        this.voice0 = null;
		        this.voice1.dispose();
		        this.voice1 = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this._vibrato.dispose();
		        this._vibrato = null;
		        this._vibratoGain.disconnect();
		        this._vibratoGain = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this.vibratoAmount.dispose();
		        this.vibratoAmount = null;
		        this.vibratoRate = null;
		        return this;
		    };
		    return Tone.DuoSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  FMSynth is composed of two Tone.MonoSynths where one Tone.MonoSynth modulates
			 *          the frequency of a second Tone.MonoSynth. A lot of spectral content 
			 *          can be explored using the modulationIndex parameter. Read more about
			 *          frequency modulation synthesis on [SoundOnSound](http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm).
			 *          <img src="https://docs.google.com/drawings/d/1h0PUDZXPgi4Ikx6bVT6oncrYPLluFKy7lj53puxj-DM/pub?w=902&h=462">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var fmSynth = new Tone.FMSynth().toMaster();
			 * fmSynth.triggerAttackRelease("C5", "4n");
			 */
		    Tone.FMSynth = function (options) {
		        options = this.defaultArg(options, Tone.FMSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The carrier voice.
				 *  @type {Tone.MonoSynth}
				 */
		        this.carrier = new Tone.MonoSynth(options.carrier);
		        this.carrier.volume.value = -10;
		        /**
				 *  The modulator voice.
				 *  @type {Tone.MonoSynth}
				 */
		        this.modulator = new Tone.MonoSynth(options.modulator);
		        this.modulator.volume.value = -10;
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * synth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  The modulation index which essentially the depth or amount of the modulation. It is the 
				 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the 
				 *  modulating signal (ma) -- as in ma/mf. 
				 *	@type {Positive}
				 *	@signal
				 */
		        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
		        this.modulationIndex.units = Tone.Type.Positive;
		        /**
				 *  the node where the modulation happens
				 *  @type {GainNode}
				 *  @private
				 */
		        this._modulationNode = this.context.createGain();
		        //control the two voices frequency
		        this.frequency.connect(this.carrier.frequency);
		        this.frequency.chain(this.harmonicity, this.modulator.frequency);
		        this.frequency.chain(this.modulationIndex, this._modulationNode);
		        this.modulator.connect(this._modulationNode.gain);
		        this._modulationNode.gain.value = 0;
		        this._modulationNode.connect(this.carrier.frequency);
		        this.carrier.connect(this.output);
		        this._readOnly([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity',
		            'modulationIndex'
		        ]);
		    };
		    Tone.extend(Tone.FMSynth, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.FMSynth.defaults = {
		        'harmonicity': 3,
		        'modulationIndex': 10,
		        'carrier': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5,
		                'min': 20000,
		                'max': 20000
		            }
		        },
		        'modulator': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'triangle' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            },
		            'filterEnvelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5,
		                'min': 20000,
		                'max': 20000
		            }
		        }
		    };
		    /**
			 * 	trigger the attack portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will occur
			 *  @param {number} [velocity=1] the velocity of the note
			 *  @returns {Tone.FMSynth} this
			 *  @private
			 */
		    Tone.FMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the port glide
		        time = this.toSeconds(time);
		        //the envelopes
		        this.carrier.envelope.triggerAttack(time, velocity);
		        this.modulator.envelope.triggerAttack(time);
		        this.carrier.filterEnvelope.triggerAttack(time);
		        this.modulator.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  trigger the release portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @returns {Tone.FMSynth} this
			 *  @private
			 */
		    Tone.FMSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.carrier.triggerRelease(time);
		        this.modulator.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.FMSynth} this
			 */
		    Tone.FMSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity',
		            'modulationIndex'
		        ]);
		        this.carrier.dispose();
		        this.carrier = null;
		        this.modulator.dispose();
		        this.modulator = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this.modulationIndex.dispose();
		        this.modulationIndex = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._modulationNode.disconnect();
		        this._modulationNode = null;
		        return this;
		    };
		    return Tone.FMSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Noise is a noise generator. It uses looped noise buffers to save on performance.
			 *          Tone.Noise supports the noise types: "pink", "white", and "brown". Read more about
			 *          colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).
			 *
			 *  @constructor
			 *  @extends {Tone.Source}
			 *  @param {string} type the noise type (white|pink|brown)
			 *  @example
			 * //initialize the noise and start
			 * var noise = new Tone.Noise("pink").start();
			 * 
			 * //make an autofilter to shape the noise
			 * var autoFilter = new Tone.AutoFilter({
			 * 	"frequency" : "8m", 
			 * 	"min" : 800, 
			 * 	"max" : 15000
			 * }).connect(Tone.Master);
			 * 
			 * //connect the noise
			 * noise.connect(autoFilter);
			 * //start the autofilter LFO
			 * autoFilter.start()
			 */
		    Tone.Noise = function () {
		        var options = this.optionsObject(arguments, ['type'], Tone.Noise.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  @private
				 *  @type {AudioBufferSourceNode}
				 */
		        this._source = null;
		        /**
				 *  the buffer
				 *  @private
				 *  @type {AudioBuffer}
				 */
		        this._buffer = null;
		        this.type = options.type;
		    };
		    Tone.extend(Tone.Noise, Tone.Source);
		    /**
			 *  the default parameters
			 *
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Noise.defaults = { 'type': 'white' };
		    /**
			 * The type of the noise. Can be "white", "brown", or "pink". 
			 * @memberOf Tone.Noise#
			 * @type {string}
			 * @name type
			 * @example
			 * noise.type = "white";
			 */
		    Object.defineProperty(Tone.Noise.prototype, 'type', {
		        get: function () {
		            if (this._buffer === _whiteNoise) {
		                return 'white';
		            } else if (this._buffer === _brownNoise) {
		                return 'brown';
		            } else if (this._buffer === _pinkNoise) {
		                return 'pink';
		            }
		        },
		        set: function (type) {
		            if (this.type !== type) {
		                switch (type) {
		                case 'white':
		                    this._buffer = _whiteNoise;
		                    break;
		                case 'pink':
		                    this._buffer = _pinkNoise;
		                    break;
		                case 'brown':
		                    this._buffer = _brownNoise;
		                    break;
		                default:
		                    this._buffer = _whiteNoise;
		                }
		                //if it's playing, stop and restart it
		                if (this.state === Tone.State.Started) {
		                    var now = this.now() + this.bufferTime;
		                    //remove the listener
		                    this._source.onended = undefined;
		                    this._stop(now);
		                    this._start(now);
		                }
		            }
		        }
		    });
		    /**
			 *  internal start method
			 *
			 *  @param {Time} time
			 *  @private
			 */
		    Tone.Noise.prototype._start = function (time) {
		        this._source = this.context.createBufferSource();
		        this._source.buffer = this._buffer;
		        this._source.loop = true;
		        this.connectSeries(this._source, this.output);
		        this._source.start(this.toSeconds(time));
		        this._source.onended = this.onended;
		    };
		    /**
			 *  internal stop method
			 *
			 *  @param {Time} time
			 *  @private
			 */
		    Tone.Noise.prototype._stop = function (time) {
		        if (this._source) {
		            this._source.stop(this.toSeconds(time));
		        }
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Noise} this
			 */
		    Tone.Noise.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._source !== null) {
		            this._source.disconnect();
		            this._source = null;
		        }
		        this._buffer = null;
		        return this;
		    };
		    ///////////////////////////////////////////////////////////////////////////
		    // THE BUFFERS
		    // borrowed heavily from http://noisehack.com/generate-noise-web-audio-api/
		    ///////////////////////////////////////////////////////////////////////////
		    /**
			 *	static noise buffers
			 *
			 *  @static
			 *  @private
			 *  @type {AudioBuffer}
			 */
		    var _pinkNoise = null, _brownNoise = null, _whiteNoise = null;
		    Tone._initAudioContext(function (audioContext) {
		        var sampleRate = audioContext.sampleRate;
		        //four seconds per buffer
		        var bufferLength = sampleRate * 4;
		        //fill the buffers
		        _pinkNoise = function () {
		            var buffer = audioContext.createBuffer(2, bufferLength, sampleRate);
		            for (var channelNum = 0; channelNum < buffer.numberOfChannels; channelNum++) {
		                var channel = buffer.getChannelData(channelNum);
		                var b0, b1, b2, b3, b4, b5, b6;
		                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;
		                for (var i = 0; i < bufferLength; i++) {
		                    var white = Math.random() * 2 - 1;
		                    b0 = 0.99886 * b0 + white * 0.0555179;
		                    b1 = 0.99332 * b1 + white * 0.0750759;
		                    b2 = 0.969 * b2 + white * 0.153852;
		                    b3 = 0.8665 * b3 + white * 0.3104856;
		                    b4 = 0.55 * b4 + white * 0.5329522;
		                    b5 = -0.7616 * b5 - white * 0.016898;
		                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
		                    channel[i] *= 0.11;
		                    // (roughly) compensate for gain
		                    b6 = white * 0.115926;
		                }
		            }
		            return buffer;
		        }();
		        _brownNoise = function () {
		            var buffer = audioContext.createBuffer(2, bufferLength, sampleRate);
		            for (var channelNum = 0; channelNum < buffer.numberOfChannels; channelNum++) {
		                var channel = buffer.getChannelData(channelNum);
		                var lastOut = 0;
		                for (var i = 0; i < bufferLength; i++) {
		                    var white = Math.random() * 2 - 1;
		                    channel[i] = (lastOut + 0.02 * white) / 1.02;
		                    lastOut = channel[i];
		                    channel[i] *= 3.5;    // (roughly) compensate for gain
		                }
		            }
		            return buffer;
		        }();
		        _whiteNoise = function () {
		            var buffer = audioContext.createBuffer(2, bufferLength, sampleRate);
		            for (var channelNum = 0; channelNum < buffer.numberOfChannels; channelNum++) {
		                var channel = buffer.getChannelData(channelNum);
		                for (var i = 0; i < bufferLength; i++) {
		                    channel[i] = Math.random() * 2 - 1;
		                }
		            }
		            return buffer;
		        }();
		    });
		    return Tone.Noise;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.NoiseSynth is composed of a noise generator (Tone.Noise), one filter (Tone.Filter), 
			 *          and two envelopes (Tone.Envelop). One envelope controls the amplitude
			 *          of the noise and the other is controls the cutoff frequency of the filter. 
			 *          <img src="https://docs.google.com/drawings/d/1rqzuX9rBlhT50MRvD2TKml9bnZhcZmzXF1rf_o7vdnE/pub?w=918&h=242">
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 * @example
			 * var noiseSynth = new Tone.NoiseSynth().toMaster();
			 * noiseSynth.triggerAttackRelease("8n");
			 */
		    Tone.NoiseSynth = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.NoiseSynth.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The noise source.
				 *  @type {Tone.Noise}
				 *  @example
				 * noiseSynth.set("noise.type", "brown");
				 */
		        this.noise = new Tone.Noise();
		        /**
				 *  The filter. 
				 *  @type {Tone.Filter}
				 */
		        this.filter = new Tone.Filter(options.filter);
		        /**
				 *  The filter envelope. 
				 *  @type {Tone.ScaledEnvelope}
				 */
		        this.filterEnvelope = new Tone.ScaledEnvelope(options.filterEnvelope);
		        /**
				 *  The amplitude envelope. 
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        //connect the noise to the output
		        this.noise.chain(this.filter, this.envelope, this.output);
		        //start the noise
		        this.noise.start();
		        //connect the filter envelope
		        this.filterEnvelope.connect(this.filter.frequency);
		        this._readOnly([
		            'noise',
		            'filter',
		            'filterEnvelope',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.NoiseSynth, Tone.Instrument);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.NoiseSynth.defaults = {
		        'noise': { 'type': 'white' },
		        'filter': {
		            'Q': 6,
		            'type': 'highpass',
		            'rolloff': -24
		        },
		        'envelope': {
		            'attack': 0.005,
		            'decay': 0.1,
		            'sustain': 0
		        },
		        'filterEnvelope': {
		            'attack': 0.06,
		            'decay': 0.2,
		            'sustain': 0,
		            'release': 2,
		            'min': 20,
		            'max': 4000,
		            'exponent': 2
		        }
		    };
		    /**
			 *  Start the attack portion of the envelopes. Unlike other 
			 *  instruments, Tone.NoiseSynth doesn't have a note. 
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {number} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.NoiseSynth} this
			 *  @example
			 * noiseSynth.triggerAttack();
			 */
		    Tone.NoiseSynth.prototype.triggerAttack = function (time, velocity) {
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        this.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  Start the release portion of the envelopes.
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.NoiseSynth} this
			 */
		    Tone.NoiseSynth.prototype.triggerRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        this.filterEnvelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  Trigger the attack and then the release. 
			 *  @param  {Time} duration the duration of the note
			 *  @param  {Time} [time=now]     the time of the attack
			 *  @param  {number} [velocity=1] the velocity
			 *  @returns {Tone.NoiseSynth} this
			 */
		    Tone.NoiseSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {
		        time = this.toSeconds(time);
		        duration = this.toSeconds(duration);
		        this.triggerAttack(time, velocity);
		        this.triggerRelease(time + duration);
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.NoiseSynth} this
			 */
		    Tone.NoiseSynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._writable([
		            'noise',
		            'filter',
		            'filterEnvelope',
		            'envelope'
		        ]);
		        this.noise.dispose();
		        this.noise = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        this.filterEnvelope.dispose();
		        this.filterEnvelope = null;
		        this.filter.dispose();
		        this.filter = null;
		        return this;
		    };
		    return Tone.NoiseSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Karplus-String string synthesis. Often out of tune. 
			 *         Will change when the AudioWorkerNode is available across
			 *         browsers. 
			 *  
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object} [options] see the defaults
			 *  @example
			 * var plucky = new Tone.PluckSynth().toMaster();
			 * plucky.triggerAttack("C4");
			 */
		    Tone.PluckSynth = function (options) {
		        options = this.defaultArg(options, Tone.PluckSynth.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  @type {Tone.Noise}
				 *  @private
				 */
		        this._noise = new Tone.Noise('pink');
		        /**
				 *  The amount of noise at the attack. 
				 *  Nominal range of [0.1, 20]
				 *  @type {number}
				 */
		        this.attackNoise = 1;
		        /**
				 *  the LFCF
				 *  @type {Tone.LowpassCombFilter}
				 *  @private
				 */
		        this._lfcf = new Tone.LowpassCombFilter({
		            'resonance': options.resonance,
		            'dampening': options.dampening
		        });
		        /**
				 *  The resonance control. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.resonance = this._lfcf.resonance;
		        /**
				 *  The dampening control. i.e. the lowpass filter frequency of the comb filter
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.dampening = this._lfcf.dampening;
		        //connections
		        this._noise.connect(this._lfcf);
		        this._lfcf.connect(this.output);
		        this._readOnly([
		            'resonance',
		            'dampening'
		        ]);
		    };
		    Tone.extend(Tone.PluckSynth, Tone.Instrument);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.PluckSynth.defaults = {
		        'attackNoise': 1,
		        'dampening': 4000,
		        'resonance': 0.9
		    };
		    /**
			 *  Trigger the note. 
			 *  @param {Frequency} note The note to trigger.
			 *  @param {Time} [time=now] When the note should be triggered.
			 *  @returns {Tone.PluckSynth} this
			 */
		    Tone.PluckSynth.prototype.triggerAttack = function (note, time) {
		        note = this.toFrequency(note);
		        time = this.toSeconds(time);
		        var delayAmount = 1 / note;
		        this._lfcf.delayTime.setValueAtTime(delayAmount, time);
		        this._noise.start(time);
		        this._noise.stop(time + delayAmount * this.attackNoise);
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.PluckSynth} this
			 */
		    Tone.PluckSynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._noise.dispose();
		        this._lfcf.dispose();
		        this._noise = null;
		        this._lfcf = null;
		        this._writable([
		            'resonance',
		            'dampening'
		        ]);
		        this.dampening = null;
		        this.resonance = null;
		        return this;
		    };
		    return Tone.PluckSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.PolySynth handles voice creation and allocation for any
			 *          instruments passed in as the second paramter. PolySynth is 
			 *          not a synthesizer by itself, it merely manages voices of 
			 *          one of the other types of synths, allowing any of the 
			 *          monophonic synthesizers to be polyphonic. 
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {number|Object} [polyphony=4] The number of voices to create
			 *  @param {function} [voice=Tone.MonoSynth] The constructor of the voices
			 *                                            uses Tone.MonoSynth by default. 
			 *  @example
			 * //a polysynth composed of 6 Voices of MonoSynth
			 * var synth = new Tone.PolySynth(6, Tone.MonoSynth).toMaster();
			 * //set the attributes using the set interface
			 * synth.set("detune", -1200);
			 * //play a chord
			 * synth.triggerAttackRelease(["C4", "E4", "A4"], "4n");
			 */
		    Tone.PolySynth = function () {
		        Tone.Instrument.call(this);
		        var options = this.optionsObject(arguments, [
		            'polyphony',
		            'voice'
		        ], Tone.PolySynth.defaults);
		        /**
				 *  the array of voices
				 *  @type {Array}
				 */
		        this.voices = new Array(options.polyphony);
		        /**
				 *  the queue of free voices
				 *  @private
				 *  @type {Array}
				 */
		        this._freeVoices = [];
		        /**
				 *  keeps track of which notes are down
				 *  @private
				 *  @type {Object}
				 */
		        this._activeVoices = {};
		        //create the voices
		        for (var i = 0; i < options.polyphony; i++) {
		            var v = new options.voice(arguments[2], arguments[3]);
		            this.voices[i] = v;
		            v.connect(this.output);
		        }
		        //make a copy of the voices
		        this._freeVoices = this.voices.slice(0);    //get the prototypes and properties
		    };
		    Tone.extend(Tone.PolySynth, Tone.Instrument);
		    /**
			 *  the defaults
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.PolySynth.defaults = {
		        'polyphony': 4,
		        'voice': Tone.MonoSynth
		    };
		    /**
			 *  Trigger the attack portion of the note
			 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
			 *                                  Frequency or an array of frequencies.
			 *  @param  {Time} [time=now]  The start time of the note.
			 *  @param {number} [velocity=1] The velocity of the note.
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * //trigger a chord immediately with a velocity of 0.2
			 * poly.triggerAttack(["Ab3", "C4", "F5"], undefined, 0.2);
			 */
		    Tone.PolySynth.prototype.triggerAttack = function (notes, time, velocity) {
		        if (!Array.isArray(notes)) {
		            notes = [notes];
		        }
		        for (var i = 0; i < notes.length; i++) {
		            var val = notes[i];
		            var stringified = JSON.stringify(val);
		            if (this._activeVoices[stringified]) {
		                this._activeVoices[stringified].triggerAttack(val, time, velocity);
		            } else if (this._freeVoices.length > 0) {
		                var voice = this._freeVoices.shift();
		                voice.triggerAttack(val, time, velocity);
		                this._activeVoices[stringified] = voice;
		            }
		        }
		        return this;
		    };
		    /**
			 *  Trigger the attack and release after the specified duration
			 *  
			 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
			 *                                  Frequency or an array of frequencies.
			 *  @param  {Time} duration the duration of the note
			 *  @param  {Time} [time=now]     if no time is given, defaults to now
			 *  @param  {number} [velocity=1] the velocity of the attack (0-1)
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * //trigger a chord for a duration of a half note 
			 * poly.triggerAttackRelease(["Eb3", "G4", "C5"], "2n");
			 */
		    Tone.PolySynth.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {
		        time = this.toSeconds(time);
		        this.triggerAttack(notes, time, velocity);
		        this.triggerRelease(notes, time + this.toSeconds(duration));
		        return this;
		    };
		    /**
			 *  Trigger the release of the note. Unlike monophonic instruments, 
			 *  a note (or array of notes) needs to be passed in as the first argument.
			 *  @param  {Frequency|Array} notes The notes to play. Accepts a single
			 *                                  Frequency or an array of frequencies.
			 *  @param  {Time} [time=now]  When the release will be triggered. 
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * poly.triggerAttack(["Ab3", "C4", "F5"]);
			 */
		    Tone.PolySynth.prototype.triggerRelease = function (notes, time) {
		        if (!Array.isArray(notes)) {
		            notes = [notes];
		        }
		        for (var i = 0; i < notes.length; i++) {
		            //get the voice
		            var stringified = JSON.stringify(notes[i]);
		            var voice = this._activeVoices[stringified];
		            if (voice) {
		                voice.triggerRelease(time);
		                this._freeVoices.push(voice);
		                delete this._activeVoices[stringified];
		                voice = null;
		            }
		        }
		        return this;
		    };
		    /**
			 *  Set a member/attribute of the voices. 
			 *  @param {Object|string} params
			 *  @param {number=} value
			 *  @param {Time=} rampTime
			 *  @returns {Tone.PolySynth} this
			 *  @example
			 * poly.set({
			 * 	"filter" : {
			 * 		"type" : "highpass"
			 * 	},
			 * 	"envelope" : {
			 * 		"attack" : 0.25
			 * 	}
			 * });
			 */
		    Tone.PolySynth.prototype.set = function (params, value, rampTime) {
		        for (var i = 0; i < this.voices.length; i++) {
		            this.voices[i].set(params, value, rampTime);
		        }
		        return this;
		    };
		    /**
			 *  Get the synth's attributes. Given no arguments get
			 *  will return all available object properties and their corresponding
			 *  values. Pass in a single attribute to retrieve or an array
			 *  of attributes. The attribute strings can also include a "."
			 *  to access deeper properties.
			 *  @param {Array=} params the parameters to get, otherwise will return 
			 *  					   all available.
			 */
		    Tone.PolySynth.prototype.get = function (params) {
		        return this.voices[0].get(params);
		    };
		    /**
			 *  @param {string} presetName the preset name
			 *  @returns {Tone.PolySynth} this
			 *  @private
			 */
		    Tone.PolySynth.prototype.setPreset = function (presetName) {
		        for (var i = 0; i < this.voices.length; i++) {
		            this.voices[i].setPreset(presetName);
		        }
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.PolySynth} this
			 */
		    Tone.PolySynth.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        for (var i = 0; i < this.voices.length; i++) {
		            this.voices[i].dispose();
		            this.voices[i] = null;
		        }
		        this.voices = null;
		        this._activeVoices = null;
		        this._freeVoices = null;
		        return this;
		    };
		    return Tone.PolySynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Player is an audio file player with start, loop, and stop functions.
			 *  
			 *  @constructor
			 *  @extends {Tone.Source} 
			 *  @param {string|AudioBuffer} url Either the AudioBuffer or the url from
			 *                                  which to load the AudioBuffer
			 *  @param {function=} onload The function to invoke when the buffer is loaded. 
			 *                            Recommended to use Tone.Buffer.onload instead.
			 *  @example
			 * var player = new Tone.Player("./path/to/sample.mp3").toMaster();
			 * Tone.Buffer.onload = function(){
			 * 	player.start();
			 * }
			 */
		    Tone.Player = function () {
		        var options = this.optionsObject(arguments, [
		            'url',
		            'onload'
		        ], Tone.Player.defaults);
		        Tone.Source.call(this, options);
		        /**
				 *  @private
				 *  @type {AudioBufferSourceNode}
				 */
		        this._source = null;
		        /**
				 *  If the file should play as soon
				 *  as the buffer is loaded. 
				 *  @type {boolean}
				 *  @example
				 * //will play as soon as it's loaded
				 * var player = new Tone.Player({
				 * 	"url" : "./path/to/sample.mp3",
				 * 	"autostart" : true,
				 * }).toMaster();
				 */
		        this.autostart = options.autostart;
		        /**
				 *  the buffer
				 *  @private
				 *  @type {Tone.Buffer}
				 */
		        this._buffer = new Tone.Buffer({
		            'url': options.url,
		            'onload': this._onload.bind(this, options.onload),
		            'reverse': options.reverse
		        });
		        /**
				 *  if the buffer should loop once it's over
				 *  @type {boolean}
				 *  @private
				 */
		        this._loop = options.loop;
		        /**
				 *  if 'loop' is true, the loop will start at this position
				 *  @type {Time}
				 *  @private
				 */
		        this._loopStart = options.loopStart;
		        /**
				 *  if 'loop' is true, the loop will end at this position
				 *  @type {Time}
				 *  @private
				 */
		        this._loopEnd = options.loopEnd;
		        /**
				 *  the playback rate
				 *  @private
				 *  @type {number}
				 */
		        this._playbackRate = options.playbackRate;
		        /**
				 *  Enabling retrigger will allow a player to be restarted
				 *  before the the previous 'start' is done playing. Otherwise, 
				 *  successive calls to Tone.Player.start will only start
				 *  the sample if it had played all the way through. 
				 *  @type {boolean}
				 */
		        this.retrigger = options.retrigger;
		    };
		    Tone.extend(Tone.Player, Tone.Source);
		    /**
			 *  the default parameters
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Player.defaults = {
		        'onload': Tone.noOp,
		        'playbackRate': 1,
		        'loop': false,
		        'autostart': false,
		        'loopStart': 0,
		        'loopEnd': 0,
		        'retrigger': false,
		        'reverse': false
		    };
		    /**
			 *  Load the audio file as an audio buffer.
			 *  Decodes the audio asynchronously and invokes
			 *  the callback once the audio buffer loads. 
			 *  Note: this does not need to be called, if a url
			 *  was passed in to the constructor. Only use this
			 *  if you want to manually load a new url. 
			 * @param {string} url The url of the buffer to load.
			 *                     Filetype support depends on the
			 *                     browser.
			 *  @param  {function=} callback The function to invoke once
			 *                               the sample is loaded.
			 *  @returns {Tone.Player} this
			 */
		    Tone.Player.prototype.load = function (url, callback) {
		        this._buffer.load(url, this._onload.bind(this, callback));
		        return this;
		    };
		    /**
			 * Internal callback when the buffer is loaded.
			 * @private
			 */
		    Tone.Player.prototype._onload = function (callback) {
		        callback(this);
		        if (this.autostart) {
		            this.start();
		        }
		    };
		    /**
			 *  play the buffer between the desired positions
			 *  
			 *  @private
			 *  @param  {Time} [startTime=now] when the player should start.
			 *  @param  {Time} [offset=0] the offset from the beginning of the sample
			 *                                 to start at. 
			 *  @param  {Time=} duration how long the sample should play. If no duration
			 *                                is given, it will default to the full length 
			 *                                of the sample (minus any offset)
			 *  @returns {Tone.Player} this
			 */
		    Tone.Player.prototype._start = function (startTime, offset, duration) {
		        if (this._buffer.loaded) {
		            //if it's a loop the default offset is the loopstart point
		            if (this._loop) {
		                offset = this.defaultArg(offset, this._loopStart);
		            } else {
		                //otherwise the default offset is 0
		                offset = this.defaultArg(offset, 0);
		            }
		            offset = this.toSeconds(offset);
		            duration = this.defaultArg(duration, this._buffer.duration - offset);
		            //the values in seconds
		            startTime = this.toSeconds(startTime);
		            duration = this.toSeconds(duration);
		            //make the source
		            this._source = this.context.createBufferSource();
		            this._source.buffer = this._buffer.get();
		            //set the looping properties
		            if (this._loop) {
		                this._source.loop = this._loop;
		                this._source.loopStart = this.toSeconds(this._loopStart);
		                this._source.loopEnd = this.toSeconds(this._loopEnd);
		                // this fixes a bug in chrome 42 that breaks looping
		                // https://code.google.com/p/chromium/issues/detail?id=457099
		                duration = 65536;
		            } else {
		                this._nextStop = startTime + duration;
		            }
		            //and other properties
		            this._source.playbackRate.value = this._playbackRate;
		            this._source.onended = this.onended;
		            this._source.connect(this.output);
		            //start it
		            this._source.start(startTime, offset, duration);
		        } else {
		            throw Error('tried to start Player before the buffer was loaded');
		        }
		        return this;
		    };
		    /**
			 *  Stop playback.
			 *  @private
			 *  @param  {Time} [time=now]
			 *  @returns {Tone.Player} this
			 */
		    Tone.Player.prototype._stop = function (time) {
		        if (this._source) {
		            this._source.stop(this.toSeconds(time));
		            this._source = null;
		        }
		        return this;
		    };
		    /**
			 *  Set the loop start and end. Will only loop if loop is 
			 *  set to true. 
			 *  @param {Time} loopStart The loop end time
			 *  @param {Time} loopEnd The loop end time
			 *  @returns {Tone.Player} this
			 *  @example
			 * //loop 0.1 seconds of the file. 
			 * player.setLoopPoints(0.2, 0.3);
			 * player.loop = true;
			 */
		    Tone.Player.prototype.setLoopPoints = function (loopStart, loopEnd) {
		        this.loopStart = loopStart;
		        this.loopEnd = loopEnd;
		        return this;
		    };
		    /**
			 * If loop is true, the loop will start at this position. 
			 * @memberOf Tone.Player#
			 * @type {Time}
			 * @name loopStart
			 */
		    Object.defineProperty(Tone.Player.prototype, 'loopStart', {
		        get: function () {
		            return this._loopStart;
		        },
		        set: function (loopStart) {
		            this._loopStart = loopStart;
		            if (this._source) {
		                this._source.loopStart = this.toSeconds(loopStart);
		            }
		        }
		    });
		    /**
			 * If loop is true, the loop will end at this position.
			 * @memberOf Tone.Player#
			 * @type {Time}
			 * @name loopEnd
			 */
		    Object.defineProperty(Tone.Player.prototype, 'loopEnd', {
		        get: function () {
		            return this._loopEnd;
		        },
		        set: function (loopEnd) {
		            this._loopEnd = loopEnd;
		            if (this._source) {
		                this._source.loopEnd = this.toSeconds(loopEnd);
		            }
		        }
		    });
		    /**
			 * The audio buffer belonging to the player. 
			 * @memberOf Tone.Player#
			 * @type {AudioBuffer}
			 * @name buffer
			 */
		    Object.defineProperty(Tone.Player.prototype, 'buffer', {
		        get: function () {
		            return this._buffer;
		        },
		        set: function (buffer) {
		            this._buffer.set(buffer);
		        }
		    });
		    /**
			 * If the buffer should loop once it's over. 
			 * @memberOf Tone.Player#
			 * @type {boolean}
			 * @name loop
			 */
		    Object.defineProperty(Tone.Player.prototype, 'loop', {
		        get: function () {
		            return this._loop;
		        },
		        set: function (loop) {
		            this._loop = loop;
		            if (this._source) {
		                this._source.loop = loop;
		            }
		        }
		    });
		    /**
			 * The playback speed. 1 is normal speed. 
			 * Note that this is not a Tone.Signal because of a bug in Blink. 
			 * Please star [this issue](https://code.google.com/p/chromium/issues/detail?id=311284)
			 * if this an important thing to you.
			 * @memberOf Tone.Player#
			 * @type {number}
			 * @name playbackRate
			 */
		    Object.defineProperty(Tone.Player.prototype, 'playbackRate', {
		        get: function () {
		            return this._playbackRate;
		        },
		        set: function (rate) {
		            this._playbackRate = rate;
		            if (this._source) {
		                this._source.playbackRate.value = rate;
		            }
		        }
		    });
		    /**
			 * The direction the buffer should play in
			 * @memberOf Tone.Player#
			 * @type {boolean}
			 * @name reverse
			 */
		    Object.defineProperty(Tone.Player.prototype, 'reverse', {
		        get: function () {
		            return this._buffer.reverse;
		        },
		        set: function (rev) {
		            this._buffer.reverse = rev;
		        }
		    });
		    /**
			 *  Dispose and disconnect.
			 *  @return {Tone.Player} this
			 */
		    Tone.Player.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._source !== null) {
		            this._source.disconnect();
		            this._source = null;
		        }
		        this._buffer.dispose();
		        this._buffer = null;
		        return this;
		    };
		    return Tone.Player;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class A sampler instrument which plays an audio buffer 
			 *         through an amplitude envelope and a filter envelope. The sampler takes
			 *         an Object in the constructor which maps a sample name to the URL 
			 *         of the sample. Nested Objects will be flattened and can be accessed using
			 *         a dot notation (see the example).
			 *         <img src="https://docs.google.com/drawings/d/1UK-gi_hxzKDz9Dh4ByyOptuagMOQxv52WxN12HwvtW8/pub?w=931&h=241">
			 *
			 *  @constructor
			 *  @extends {Tone.Instrument}
			 *  @param {Object|string} urls the urls of the audio file
			 *  @param {Object} [options] the options object for the synth
			 *  @example
			 * var sampler = new Sampler({
			 * 	A : {
			 * 		1 : {"./audio/casio/A1.mp3",
			 * 		2 : "./audio/casio/A2.mp3",
			 * 	},
			 * 	"B.1" : "./audio/casio/B1.mp3",
			 * }).toMaster();
			 * 
			 * //listen for when all the samples have loaded
			 * Tone.Buffer.onload = function(){
			 * 	sampler.triggerAttack("A.1", time, velocity);
			 * };
			 */
		    Tone.Sampler = function (urls, options) {
		        options = this.defaultArg(options, Tone.Sampler.defaults);
		        Tone.Instrument.call(this, options);
		        /**
				 *  The sample player.
				 *  @type {Tone.Player}
				 */
		        this.player = new Tone.Player(options.player);
		        this.player.retrigger = true;
		        /**
				 *  the buffers
				 *  @type {Object}
				 *  @private
				 */
		        this._buffers = {};
		        /**
				 *  The amplitude envelope. 
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        /**
				 *  The filter envelope. 
				 *  @type {Tone.ScaledEnvelope}
				 */
		        this.filterEnvelope = new Tone.ScaledEnvelope(options.filterEnvelope);
		        /**
				 *  The name of the current sample. 
				 *  @type {string}
				 *  @private
				 */
		        this._sample = options.sample;
		        /**
				 * the private reference to the pitch
				 * @type {number}
				 * @private
				 */
		        this._pitch = options.pitch;
		        /**
				 *  The filter.
				 *  @type {Tone.Filter}
				 */
		        this.filter = new Tone.Filter(options.filter);
		        //connections / setup
		        this._loadBuffers(urls);
		        this.pitch = options.pitch;
		        this.player.chain(this.filter, this.envelope, this.output);
		        this.filterEnvelope.connect(this.filter.frequency);
		        this._readOnly([
		            'player',
		            'filterEnvelope',
		            'envelope',
		            'filter'
		        ]);
		    };
		    Tone.extend(Tone.Sampler, Tone.Instrument);
		    /**
			 *  the default parameters
			 *  @static
			 */
		    Tone.Sampler.defaults = {
		        'sample': 0,
		        'pitch': 0,
		        'player': { 'loop': false },
		        'envelope': {
		            'attack': 0.001,
		            'decay': 0,
		            'sustain': 1,
		            'release': 0.1
		        },
		        'filterEnvelope': {
		            'attack': 0.001,
		            'decay': 0.001,
		            'sustain': 1,
		            'release': 0.5,
		            'min': 20,
		            'max': 20000,
		            'exponent': 2
		        },
		        'filter': { 'type': 'lowpass' }
		    };
		    /**
			 *  load the buffers
			 *  @param   {Object} urls   the urls
			 *  @private
			 */
		    Tone.Sampler.prototype._loadBuffers = function (urls) {
		        if (typeof urls === 'string') {
		            this._buffers['0'] = new Tone.Buffer(urls, function () {
		                this.sample = '0';
		            }.bind(this));
		        } else {
		            urls = this._flattenUrls(urls);
		            for (var buffName in urls) {
		                this._sample = buffName;
		                var urlString = urls[buffName];
		                this._buffers[buffName] = new Tone.Buffer(urlString);
		            }
		        }
		    };
		    /**
			 *  Flatten an object into a single depth object. 
			 *  thanks to https://gist.github.com/penguinboy/762197
			 *  @param   {Object} ob 	
			 *  @return  {Object}    
			 *  @private
			 */
		    Tone.Sampler.prototype._flattenUrls = function (ob) {
		        var toReturn = {};
		        for (var i in ob) {
		            if (!ob.hasOwnProperty(i))
		                continue;
		            if (typeof ob[i] == 'object') {
		                var flatObject = this._flattenUrls(ob[i]);
		                for (var x in flatObject) {
		                    if (!flatObject.hasOwnProperty(x))
		                        continue;
		                    toReturn[i + '.' + x] = flatObject[x];
		                }
		            } else {
		                toReturn[i] = ob[i];
		            }
		        }
		        return toReturn;
		    };
		    /**
			 *  Start the sample and simultaneously trigger the envelopes. 
			 *  @param {string=} sample The name of the sample to trigger, defaults to
			 *                          the last sample used. 
			 *  @param {Time} [time=now] The time when the sample should start
			 *  @param {number} [velocity=1] The velocity of the note
			 *  @returns {Tone.Sampler} this
			 *  @example
			 * sampler.triggerAttack("B.1");
			 */
		    Tone.Sampler.prototype.triggerAttack = function (name, time, velocity) {
		        time = this.toSeconds(time);
		        if (name) {
		            this.sample = name;
		        }
		        this.player.start(time);
		        this.envelope.triggerAttack(time, velocity);
		        this.filterEnvelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  Start the release portion of the sample. Will stop the sample once the 
			 *  envelope has fully released. 
			 *  
			 *  @param {Time} [time=now] The time when the note should release
			 *  @returns {Tone.Sampler} this
			 *  @example
			 * sampler.triggerRelease();
			 */
		    Tone.Sampler.prototype.triggerRelease = function (time) {
		        time = this.toSeconds(time);
		        this.filterEnvelope.triggerRelease(time);
		        this.envelope.triggerRelease(time);
		        this.player.stop(this.toSeconds(this.envelope.release) + time);
		        return this;
		    };
		    /**
			 * The name of the sample to trigger.
			 * @memberOf Tone.Sampler#
			 * @type {number|string}
			 * @name sample
			 * @example
			 * //set the sample to "A.2" for next time the sample is triggered
			 * sampler.sample = "A.2";
			 */
		    Object.defineProperty(Tone.Sampler.prototype, 'sample', {
		        get: function () {
		            return this._sample;
		        },
		        set: function (name) {
		            if (this._buffers.hasOwnProperty(name)) {
		                this._sample = name;
		                this.player.buffer = this._buffers[name];
		            } else {
		                throw new Error('Sampler does not have a sample named ' + name);
		            }
		        }
		    });
		    /**
			 * The direction the buffer should play in
			 * @memberOf Tone.Sampler#
			 * @type {boolean}
			 * @name reverse
			 */
		    Object.defineProperty(Tone.Sampler.prototype, 'reverse', {
		        get: function () {
		            for (var i in this._buffers) {
		                return this._buffers[i].reverse;
		            }
		        },
		        set: function (rev) {
		            for (var i in this._buffers) {
		                this._buffers[i].reverse = rev;
		            }
		        }
		    });
		    /**
			 * Repitch the sampled note by some interval (measured
			 * in semi-tones). 
			 * @memberOf Tone.Sampler#
			 * @type {Interval}
			 * @name pitch
			 * @example
			 * sampler.pitch = -12; //down one octave
			 * sampler.pitch = 7; //up a fifth
			 */
		    Object.defineProperty(Tone.Sampler.prototype, 'pitch', {
		        get: function () {
		            return this._pitch;
		        },
		        set: function (interval) {
		            this._pitch = interval;
		            this.player.playbackRate = this.intervalToFrequencyRatio(interval);
		        }
		    });
		    /**
			 *  Clean up.
			 *  @returns {Tone.Sampler} this
			 */
		    Tone.Sampler.prototype.dispose = function () {
		        Tone.Instrument.prototype.dispose.call(this);
		        this._writable([
		            'player',
		            'filterEnvelope',
		            'envelope',
		            'filter'
		        ]);
		        this.player.dispose();
		        this.filterEnvelope.dispose();
		        this.envelope.dispose();
		        this.filter.dispose();
		        this.player = null;
		        this.filterEnvelope = null;
		        this.envelope = null;
		        this.filter = null;
		        for (var sample in this._buffers) {
		            this._buffers[sample].dispose();
		            this._buffers[sample] = null;
		        }
		        this._buffers = null;
		        return this;
		    };
		    return Tone.Sampler;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.SimpleSynth is composed simply of a Tone.OmniOscillator
			 *          routed through a Tone.AmplitudeEnvelope. 
			 *          <img src="https://docs.google.com/drawings/d/1-1_0YW2Z1J2EPI36P8fNCMcZG7N1w1GZluPs4og4evo/pub?w=1163&h=231">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.SimpleSynth().toMaster();
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.SimpleSynth = function (options) {
		        //get the defaults
		        options = this.defaultArg(options, Tone.SimpleSynth.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The oscillator.
				 *  @type {Tone.OmniOscillator}
				 */
		        this.oscillator = new Tone.OmniOscillator(options.oscillator);
		        /**
				 *  The frequency control.
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = this.oscillator.frequency;
		        /**
				 *  The detune control.
				 *  @type {Cents}
				 *  @signal
				 */
		        this.detune = this.oscillator.detune;
		        /**
				 *  The amplitude envelope.
				 *  @type {Tone.AmplitudeEnvelope}
				 */
		        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);
		        //connect the oscillators to the output
		        this.oscillator.chain(this.envelope, this.output);
		        //start the oscillators
		        this.oscillator.start();
		        this._readOnly([
		            'oscillator',
		            'frequency',
		            'detune',
		            'envelope'
		        ]);
		    };
		    Tone.extend(Tone.SimpleSynth, Tone.Monophonic);
		    /**
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.SimpleSynth.defaults = {
		        'oscillator': { 'type': 'triangle' },
		        'envelope': {
		            'attack': 0.005,
		            'decay': 0.1,
		            'sustain': 0.3,
		            'release': 1
		        }
		    };
		    /**
			 *  start the attack portion of the envelope
			 *  @param {Time} [time=now] the time the attack should start
			 *  @param {number} [velocity=1] the velocity of the note (0-1)
			 *  @returns {Tone.SimpleSynth} this
			 *  @private
			 */
		    Tone.SimpleSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the envelopes
		        this.envelope.triggerAttack(time, velocity);
		        return this;
		    };
		    /**
			 *  start the release portion of the envelope
			 *  @param {Time} [time=now] the time the release should start
			 *  @returns {Tone.SimpleSynth} this
			 *  @private
			 */
		    Tone.SimpleSynth.prototype._triggerEnvelopeRelease = function (time) {
		        this.envelope.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.SimpleSynth} this
			 */
		    Tone.SimpleSynth.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'oscillator',
		            'frequency',
		            'detune',
		            'envelope'
		        ]);
		        this.oscillator.dispose();
		        this.oscillator = null;
		        this.envelope.dispose();
		        this.envelope = null;
		        this.frequency = null;
		        this.detune = null;
		        return this;
		    };
		    return Tone.SimpleSynth;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class   AMSynth uses the output of one Tone.SimpleSynth to modulate the
			 *          amplitude of another Tone.SimpleSynth. The harmonicity (the ratio between
			 *          the two signals) affects the timbre of the output signal the most.
			 *          Read more about Amplitude Modulation Synthesis on [SoundOnSound](http://www.soundonsound.com/sos/mar00/articles/synthsecrets.htm).
			 *          <img src="https://docs.google.com/drawings/d/1p_os_As-N1bpnK8u55gXlgVw3U7BfquLX0Wj57kSZXY/pub?w=1009&h=457">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var synth = new Tone.SimpleAM().toMaster();
			 * synth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.SimpleAM = function (options) {
		        options = this.defaultArg(options, Tone.SimpleAM.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The carrier voice. 
				 *  @type {Tone.SimpleSynth}
				 */
		        this.carrier = new Tone.SimpleSynth(options.carrier);
		        /**
				 *  The modulator voice. 
				 *  @type {Tone.SimpleSynth}
				 */
		        this.modulator = new Tone.SimpleSynth(options.modulator);
		        /**
				 *  the frequency control
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  The ratio between the carrier and the modulator frequencies. A value of 1
				 *  makes both voices in unison, a value of 0.5 puts the modulator an octave below
				 *  the carrier.
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //set the modulator an octave above the carrier frequency
				 * simpleAM.harmonicity.value = 2;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  convert the -1,1 output to 0,1
				 *  @type {Tone.AudioToGain}
				 *  @private
				 */
		        this._modulationScale = new Tone.AudioToGain();
		        /**
				 *  the node where the modulation happens
				 *  @type {GainNode}
				 *  @private
				 */
		        this._modulationNode = this.context.createGain();
		        //control the two voices frequency
		        this.frequency.connect(this.carrier.frequency);
		        this.frequency.chain(this.harmonicity, this.modulator.frequency);
		        this.modulator.chain(this._modulationScale, this._modulationNode.gain);
		        this.carrier.chain(this._modulationNode, this.output);
		        this._readOnly([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity'
		        ]);
		    };
		    Tone.extend(Tone.SimpleAM, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.SimpleAM.defaults = {
		        'harmonicity': 3,
		        'carrier': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0.01,
		                'sustain': 1,
		                'release': 0.5
		            }
		        },
		        'modulator': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'envelope': {
		                'attack': 0.5,
		                'decay': 0.1,
		                'sustain': 1,
		                'release': 0.5
		            }
		        }
		    };
		    /**
			 *  trigger the attack portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will occur
			 *  @param {number} [velocity=1] the velocity of the note
			 *  @returns {Tone.SimpleAM} this
			 *  @private
			 */
		    Tone.SimpleAM.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the port glide
		        time = this.toSeconds(time);
		        //the envelopes
		        this.carrier.envelope.triggerAttack(time, velocity);
		        this.modulator.envelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  trigger the release portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @returns {Tone.SimpleAM} this
			 *  @private
			 */
		    Tone.SimpleAM.prototype._triggerEnvelopeRelease = function (time) {
		        this.carrier.triggerRelease(time);
		        this.modulator.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.SimpleAM} this
			 */
		    Tone.SimpleAM.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity'
		        ]);
		        this.carrier.dispose();
		        this.carrier = null;
		        this.modulator.dispose();
		        this.modulator = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._modulationScale.dispose();
		        this._modulationScale = null;
		        this._modulationNode.disconnect();
		        this._modulationNode = null;
		        return this;
		    };
		    return Tone.SimpleAM;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  SimpleFM is composed of two Tone.SimpleSynths where one Tone.SimpleSynth modulates
			 *          the frequency of a second Tone.SimpleSynth. A lot of spectral content 
			 *          can be explored using the Tone.FMSynth.modulationIndex parameter. Read more about
			 *          frequency modulation synthesis on [SoundOnSound](http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm).
			 *          <img src="https://docs.google.com/drawings/d/1hSU25lLjDk_WJ59DSitQm6iCRpcMWVEAYqBjwmqtRVw/pub?w=902&h=462">
			 *
			 *  @constructor
			 *  @extends {Tone.Monophonic}
			 *  @param {Object} [options] the options available for the synth 
			 *                          see defaults below
			 *  @example
			 * var fmSynth = new Tone.SimpleFM().toMaster();
			 * fmSynth.triggerAttackRelease("C4", "8n");
			 */
		    Tone.SimpleFM = function (options) {
		        options = this.defaultArg(options, Tone.SimpleFM.defaults);
		        Tone.Monophonic.call(this, options);
		        /**
				 *  The carrier voice. 
				 *  @type {Tone.SimpleSynth}
				 */
		        this.carrier = new Tone.SimpleSynth(options.carrier);
		        this.carrier.volume.value = -10;
		        /**
				 *  The modulator voice. 
				 *  @type {Tone.SimpleSynth}
				 */
		        this.modulator = new Tone.SimpleSynth(options.modulator);
		        this.modulator.volume.value = -10;
		        /**
				 *  the frequency control
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);
		        /**
				 *  Harmonicity is the ratio between the two voices. A harmonicity of
				 *  1 is no change. Harmonicity = 2 means a change of an octave. 
				 *  @type {Positive}
				 *  @signal
				 *  @example
				 * //pitch voice1 an octave below voice0
				 * synth.harmonicity.value = 0.5;
				 */
		        this.harmonicity = new Tone.Multiply(options.harmonicity);
		        this.harmonicity.units = Tone.Type.Positive;
		        /**
				 *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the 
				 *  ratio of the frequency of the modulating signal (mf) to the amplitude of the 
				 *  modulating signal (ma) -- as in ma/mf. 
				 *	@type {Positive}
				 *	@signal
				 */
		        this.modulationIndex = new Tone.Multiply(options.modulationIndex);
		        this.modulationIndex.units = Tone.Type.Positive;
		        /**
				 *  the node where the modulation happens
				 *  @type {GainNode}
				 *  @private
				 */
		        this._modulationNode = this.context.createGain();
		        //control the two voices frequency
		        this.frequency.connect(this.carrier.frequency);
		        this.frequency.chain(this.harmonicity, this.modulator.frequency);
		        this.frequency.chain(this.modulationIndex, this._modulationNode);
		        this.modulator.connect(this._modulationNode.gain);
		        this._modulationNode.gain.value = 0;
		        this._modulationNode.connect(this.carrier.frequency);
		        this.carrier.connect(this.output);
		        this._readOnly([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity',
		            'modulationIndex'
		        ]);
		        ;
		    };
		    Tone.extend(Tone.SimpleFM, Tone.Monophonic);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.SimpleFM.defaults = {
		        'harmonicity': 3,
		        'modulationIndex': 10,
		        'carrier': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'sine' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            }
		        },
		        'modulator': {
		            'volume': -10,
		            'portamento': 0,
		            'oscillator': { 'type': 'triangle' },
		            'envelope': {
		                'attack': 0.01,
		                'decay': 0,
		                'sustain': 1,
		                'release': 0.5
		            }
		        }
		    };
		    /**
			 *  trigger the attack portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will occur
			 *  @param {number} [velocity=1] the velocity of the note
			 *  @returns {Tone.SimpleFM} this
			 *  @private
			 */
		    Tone.SimpleFM.prototype._triggerEnvelopeAttack = function (time, velocity) {
		        //the port glide
		        time = this.toSeconds(time);
		        //the envelopes
		        this.carrier.envelope.triggerAttack(time, velocity);
		        this.modulator.envelope.triggerAttack(time);
		        return this;
		    };
		    /**
			 *  trigger the release portion of the note
			 *  
			 *  @param  {Time} [time=now] the time the note will release
			 *  @returns {Tone.SimpleFM} this
			 *  @private
			 */
		    Tone.SimpleFM.prototype._triggerEnvelopeRelease = function (time) {
		        this.carrier.triggerRelease(time);
		        this.modulator.triggerRelease(time);
		        return this;
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.SimpleFM} this
			 */
		    Tone.SimpleFM.prototype.dispose = function () {
		        Tone.Monophonic.prototype.dispose.call(this);
		        this._writable([
		            'carrier',
		            'modulator',
		            'frequency',
		            'harmonicity',
		            'modulationIndex'
		        ]);
		        this.carrier.dispose();
		        this.carrier = null;
		        this.modulator.dispose();
		        this.modulator = null;
		        this.frequency.dispose();
		        this.frequency = null;
		        this.modulationIndex.dispose();
		        this.modulationIndex = null;
		        this.harmonicity.dispose();
		        this.harmonicity = null;
		        this._modulationNode.disconnect();
		        this._modulationNode = null;
		        return this;
		    };
		    return Tone.SimpleFM;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Tone.Effect is the base class for effects. Connect the effect between
			 * 	        the effectSend and effectReturn GainNodes, then control the amount of
			 * 	        effect which goes to the output using the wet control.
			 *
			 *  @constructor
			 *  @extends {Tone}
			 *  @param {NormalRange|Object} [wet] The starting wet value. 
			 */
		    Tone.Effect = function () {
		        Tone.call(this);
		        //get all of the defaults
		        var options = this.optionsObject(arguments, ['wet'], Tone.Effect.defaults);
		        /**
				 *  the drywet knob to control the amount of effect
				 *  @type {Tone.CrossFade}
				 *  @private
				 */
		        this._dryWet = new Tone.CrossFade(options.wet);
		        /**
				 *  The wet control is how much of the effected
				 *  will pass through to the output. 1 = 100% effected
				 *  signal, 0 = 100% dry signal. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.wet = this._dryWet.fade;
		        /**
				 *  connect the effectSend to the input of hte effect
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectSend = this.context.createGain();
		        /**
				 *  connect the output of the effect to the effectReturn
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectReturn = this.context.createGain();
		        //connections
		        this.input.connect(this._dryWet.a);
		        this.input.connect(this.effectSend);
		        this.effectReturn.connect(this._dryWet.b);
		        this._dryWet.connect(this.output);
		        this._readOnly(['wet']);
		    };
		    Tone.extend(Tone.Effect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Effect.defaults = { 'wet': 1 };
		    /**
			 *  chains the effect in between the effectSend and effectReturn
			 *  @param  {Tone} effect
			 *  @private
			 *  @returns {Tone.Effect} this
			 */
		    Tone.Effect.prototype.connectEffect = function (effect) {
		        this.effectSend.chain(effect, this.effectReturn);
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Effect} this
			 */
		    Tone.Effect.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._dryWet.dispose();
		        this._dryWet = null;
		        this.effectSend.disconnect();
		        this.effectSend = null;
		        this.effectReturn.disconnect();
		        this.effectReturn = null;
		        this._writable(['wet']);
		        this.wet = null;
		        return this;
		    };
		    return Tone.Effect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.
			 *         Setting the LFO rate and depth allows for control over the filter modulation rate 
			 *         and depth.
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Time|Object} [frequency] The rate of the LFO.
			 *  @param {Frequency} [min] The lower value of the LFOs oscillation
		 	 *  @param {Frequency} [max] The upper value of the LFOs oscillation. 
			 *  @example
			 * //create an autofilter and start it's LFO
			 * var autoFilter = new Tone.AutoFilter("4n").toMaster().start();
			 * //route an oscillator through the filter and start it
			 * var oscillator = new Tone.Oscillator().connect(autoFilter).start();
			 */
		    Tone.AutoFilter = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'min',
		            'max'
		        ], Tone.AutoFilter.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  the lfo which drives the filter cutoff
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfo = new Tone.LFO({
		            'frequency': options.frequency,
		            'amplitude': options.depth,
		            'min': options.min,
		            'max': options.max
		        });
		        /**
				 * The range of the filter modulating between the min and max frequency. 
				 * 0 = no modulation. 1 = full modulation.
				 * @type {NormalRange}
				 * @signal
				 */
		        this.depth = this._lfo.amplitude;
		        /**
				 * How fast the filter modulates between min and max. 
				 * @type {Frequency}
				 * @signal
				 */
		        this.frequency = this._lfo.frequency;
		        /**
				 *  The filter node
				 *  @type {Tone.Filter}
				 */
		        this.filter = new Tone.Filter(options.filter);
		        //connections
		        this.connectEffect(this.filter);
		        this._lfo.connect(this.filter.frequency);
		        this.type = options.type;
		        this._readOnly([
		            'frequency',
		            'depth'
		        ]);
		    };
		    //extend Effect
		    Tone.extend(Tone.AutoFilter, Tone.Effect);
		    /**
			 *  defaults
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AutoFilter.defaults = {
		        'frequency': 1,
		        'type': 'sine',
		        'depth': 1,
		        'min': 200,
		        'max': 1200,
		        'filter': {
		            'type': 'lowpass',
		            'rolloff': -12,
		            'Q': 1
		        }
		    };
		    /**
			 * Start the effect.
			 * @param {Time} [time=now] When the LFO will start. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.start = function (time) {
		        this._lfo.start(time);
		        return this;
		    };
		    /**
			 * Stop the effect.
			 * @param {Time} [time=now] When the LFO will stop. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.stop = function (time) {
		        this._lfo.stop(time);
		        return this;
		    };
		    /**
			 * Sync the filter to the transport.
			 * @param {Time} [delay=0] Delay time before starting the effect after the
			 *                               Transport has started. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.sync = function (delay) {
		        this._lfo.sync(delay);
		        return this;
		    };
		    /**
			 * Unsync the filter from the transport.
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.unsync = function () {
		        this._lfo.unsync();
		        return this;
		    };
		    /**
			 * Type of oscillator attached to the AutoFilter. 
			 * Possible values: "sine", "square", "triangle", "sawtooth".
			 * @memberOf Tone.AutoFilter#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.AutoFilter.prototype, 'type', {
		        get: function () {
		            return this._lfo.type;
		        },
		        set: function (type) {
		            this._lfo.type = type;
		        }
		    });
		    /**
			 * The minimum value of the LFO attached to the cutoff frequency of the filter.
			 * @memberOf Tone.AutoFilter#
			 * @type {Frequency}
			 * @name min
			 */
		    Object.defineProperty(Tone.AutoFilter.prototype, 'min', {
		        get: function () {
		            return this._lfo.min;
		        },
		        set: function (min) {
		            this._lfo.min = min;
		        }
		    });
		    /**
			 * The minimum value of the LFO attached to the cutoff frequency of the filter.
			 * @memberOf Tone.AutoFilter#
			 * @type {Frequency}
			 * @name max
			 */
		    Object.defineProperty(Tone.AutoFilter.prototype, 'max', {
		        get: function () {
		            return this._lfo.max;
		        },
		        set: function (max) {
		            this._lfo.max = max;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.AutoFilter} this
			 */
		    Tone.AutoFilter.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._lfo.dispose();
		        this._lfo = null;
		        this.filter.dispose();
		        this.filter = null;
		        this._writable([
		            'frequency',
		            'depth'
		        ]);
		        this.frequency = null;
		        this.depth = null;
		        return this;
		    };
		    return Tone.AutoFilter;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.AutoPanner is a Tone.Panner with an LFO connected to the pan amount. 
			 *         More on using autopanners [here](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Frequency|Object} [frequency] Rate of left-right oscillation. 
			 *  @example
			 * //create an autopanner and start it's LFO
			 * var autoPanner = new Tone.AutoPanner("4n").toMaster().start();
			 * //route an oscillator through the panner and start it
			 * var oscillator = new Tone.Oscillator().connect(autoPanner).start();
			 */
		    Tone.AutoPanner = function () {
		        var options = this.optionsObject(arguments, ['frequency'], Tone.AutoPanner.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  the lfo which drives the panning
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfo = new Tone.LFO({
		            'frequency': options.frequency,
		            'amplitude': options.depth,
		            'min': 0,
		            'max': 1,
		            //start at the middle of the cycle
		            'phase': 90
		        });
		        /**
				 * The amount of panning between left and right. 
				 * 0 = always center. 1 = full range between left and right. 
				 * @type {NormalRange}
				 * @signal
				 */
		        this.depth = this._lfo.amplitude;
		        /**
				 *  the panner node which does the panning
				 *  @type {Tone.Panner}
				 *  @private
				 */
		        this._panner = new Tone.Panner();
		        /**
				 * How fast the panner modulates between left and right. 
				 * @type {Frequency}
				 * @signal
				 */
		        this.frequency = this._lfo.frequency;
		        //connections
		        this.connectEffect(this._panner);
		        this._lfo.connect(this._panner.pan);
		        this.type = options.type;
		        this._readOnly([
		            'depth',
		            'frequency'
		        ]);
		    };
		    //extend Effect
		    Tone.extend(Tone.AutoPanner, Tone.Effect);
		    /**
			 *  defaults
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AutoPanner.defaults = {
		        'frequency': 1,
		        'type': 'sine',
		        'depth': 1
		    };
		    /**
			 * Start the effect.
			 * @param {Time} [time=now] When the LFO will start. 
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.start = function (time) {
		        this._lfo.start(time);
		        return this;
		    };
		    /**
			 * Stop the effect.
			 * @param {Time} [time=now] When the LFO will stop. 
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.stop = function (time) {
		        this._lfo.stop(time);
		        return this;
		    };
		    /**
			 * Sync the panner to the transport.
			 * @param {Time} [delay=0] Delay time before starting the effect after the
			 *                               Transport has started. 
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.sync = function (delay) {
		        this._lfo.sync(delay);
		        return this;
		    };
		    /**
			 * Unsync the panner from the transport
			 * @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.unsync = function () {
		        this._lfo.unsync();
		        return this;
		    };
		    /**
			 * Type of oscillator attached to the AutoFilter. 
			 * Possible values: "sine", "square", "triangle", "sawtooth".
			 * @memberOf Tone.AutoFilter#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.AutoPanner.prototype, 'type', {
		        get: function () {
		            return this._lfo.type;
		        },
		        set: function (type) {
		            this._lfo.type = type;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.AutoPanner} this
			 */
		    Tone.AutoPanner.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._lfo.dispose();
		        this._lfo = null;
		        this._panner.dispose();
		        this._panner = null;
		        this._writable([
		            'depth',
		            'frequency'
		        ]);
		        this.frequency = null;
		        this.depth = null;
		        return this;
		    };
		    return Tone.AutoPanner;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.AutoWah connects a Tone.Follower to a bandpass filter (Tone.Filter).
			 *          The frequency of the filter is adjusted proportionally to the 
			 *          incoming signal's amplitude. Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Frequency|Object} [baseFrequency] The frequency the filter is set 
			 *                                            to at the low point of the wah
			 *  @param {Positive} [octaves] The number of octaves above the baseFrequency
			 *                                the filter will sweep to when fully open
			 *  @param {Decibels} [sensitivity] The decibel threshold sensitivity for 
			 *                                   the incoming signal. Normal range of -40 to 0. 
			 *  @example
			 * var autoWah = new Tone.AutoWah(50, 6, -30).toMaster();
			 * //initialize the synth and connect to autowah
			 * var synth = new SimpleSynth.connect(autoWah);
			 * //Q value influences the effect of the wah - default is 2
			 * autoWah.Q.value = 6;
			 * //more audible on higher notes
			 * synth.triggerAttackRelease("C4", "8n")
			 */
		    Tone.AutoWah = function () {
		        var options = this.optionsObject(arguments, [
		            'baseFrequency',
		            'octaves',
		            'sensitivity'
		        ], Tone.AutoWah.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  The envelope follower. Set the attack/release
				 *  timing to adjust how the envelope is followed. 
				 *  @type {Tone.Follower}
				 *  @private
				 */
		        this.follower = new Tone.Follower(options.follower);
		        /**
				 *  scales the follower value to the frequency domain
				 *  @type {Tone}
				 *  @private
				 */
		        this._sweepRange = new Tone.ScaleExp(0, 1, 0.5);
		        /**
				 *  @type {number}
				 *  @private
				 */
		        this._baseFrequency = options.baseFrequency;
		        /**
				 *  @type {number}
				 *  @private
				 */
		        this._octaves = options.octaves;
		        /**
				 *  the input gain to adjust the sensitivity
				 *  @type {GainNode}
				 *  @private
				 */
		        this._inputBoost = this.context.createGain();
		        /**
				 *  @type {BiquadFilterNode}
				 *  @private
				 */
		        this._bandpass = new Tone.Filter({
		            'rolloff': -48,
		            'frequency': 0,
		            'Q': options.Q
		        });
		        /**
				 *  @type {Tone.Filter}
				 *  @private
				 */
		        this._peaking = new Tone.Filter(0, 'peaking');
		        this._peaking.gain.value = options.gain;
		        /**
				 * The gain of the filter.
				 * @type {Gain}
				 * @signal
				 */
		        this.gain = this._peaking.gain;
		        /**
				 * The quality of the filter.
				 * @type {Positive}
				 * @signal
				 */
		        this.Q = this._bandpass.Q;
		        //the control signal path
		        this.effectSend.chain(this._inputBoost, this.follower, this._sweepRange);
		        this._sweepRange.connect(this._bandpass.frequency);
		        this._sweepRange.connect(this._peaking.frequency);
		        //the filtered path
		        this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);
		        //set the initial value
		        this._setSweepRange();
		        this.sensitivity = options.sensitivity;
		        this._readOnly([
		            'gain',
		            'Q'
		        ]);
		    };
		    Tone.extend(Tone.AutoWah, Tone.Effect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.AutoWah.defaults = {
		        'baseFrequency': 100,
		        'octaves': 6,
		        'sensitivity': 0,
		        'Q': 2,
		        'gain': 2,
		        'follower': {
		            'attack': 0.3,
		            'release': 0.5
		        }
		    };
		    /**
			 * The number of octaves that the filter will sweep above the 
			 * baseFrequency. 
			 * @memberOf Tone.AutoWah#
			 * @type {Number}
			 * @name octaves
			 */
		    Object.defineProperty(Tone.AutoWah.prototype, 'octaves', {
		        get: function () {
		            return this._octaves;
		        },
		        set: function (octaves) {
		            this._octaves = octaves;
		            this._setSweepRange();
		        }
		    });
		    /**
			 * The base frequency from which the sweep will start from.
			 * @memberOf Tone.AutoWah#
			 * @type {Frequency}
			 * @name baseFrequency
			 */
		    Object.defineProperty(Tone.AutoWah.prototype, 'baseFrequency', {
		        get: function () {
		            return this._baseFrequency;
		        },
		        set: function (baseFreq) {
		            this._baseFrequency = baseFreq;
		            this._setSweepRange();
		        }
		    });
		    /**
			 * The sensitivity to control how responsive to the input signal the filter is. 
			 * @memberOf Tone.AutoWah#
			 * @type {Decibels}
			 * @name sensitivity
			 */
		    Object.defineProperty(Tone.AutoWah.prototype, 'sensitivity', {
		        get: function () {
		            return this.gainToDb(1 / this._inputBoost.gain.value);
		        },
		        set: function (sensitivy) {
		            this._inputBoost.gain.value = 1 / this.dbToGain(sensitivy);
		        }
		    });
		    /**
			 *  sets the sweep range of the scaler
			 *  @private
			 */
		    Tone.AutoWah.prototype._setSweepRange = function () {
		        this._sweepRange.min = this._baseFrequency;
		        this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.AutoWah} this
			 */
		    Tone.AutoWah.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this.follower.dispose();
		        this.follower = null;
		        this._sweepRange.dispose();
		        this._sweepRange = null;
		        this._bandpass.dispose();
		        this._bandpass = null;
		        this._peaking.dispose();
		        this._peaking = null;
		        this._inputBoost.disconnect();
		        this._inputBoost = null;
		        this._writable([
		            'gain',
		            'Q'
		        ]);
		        this.gain = null;
		        this.Q = null;
		        return this;
		    };
		    return Tone.AutoWah;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Bitcrusher downsamples the incoming signal to a different bitdepth. 
			 *         Lowering the bitdepth of the signal creates distortion. Read more about Bitcrushing
			 *         on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {Number} bits The number of bits to downsample the signal. Nominal range
			 *                       of 1 to 8. 
			 *  @example
			 * //initialize crusher and route a synth through it
			 * var crusher = new Tone.BitCrusher(4).toMaster();
			 * var synth = new Tone.MonoSynth().connect(crusher);
			 */
		    Tone.BitCrusher = function () {
		        var options = this.optionsObject(arguments, ['bits'], Tone.BitCrusher.defaults);
		        Tone.Effect.call(this, options);
		        var invStepSize = 1 / Math.pow(2, options.bits - 1);
		        /**
				 *  Subtract the input signal and the modulus of the input signal
				 *  @type {Tone.Subtract}
				 *  @private
				 */
		        this._subtract = new Tone.Subtract();
		        /**
				 *  The mod function
				 *  @type  {Tone.Modulo}
				 *  @private
				 */
		        this._modulo = new Tone.Modulo(invStepSize);
		        /**
				 *  keeps track of the bits
				 *  @type {number}
				 *  @private
				 */
		        this._bits = options.bits;
		        //connect it up
		        this.effectSend.fan(this._subtract, this._modulo);
		        this._modulo.connect(this._subtract, 0, 1);
		        this._subtract.connect(this.effectReturn);
		    };
		    Tone.extend(Tone.BitCrusher, Tone.Effect);
		    /**
			 *  the default values
			 *  @static
			 *  @type {Object}
			 */
		    Tone.BitCrusher.defaults = { 'bits': 4 };
		    /**
			 * The bit depth of the effect. Nominal range of 1-8. 
			 * @memberOf Tone.BitCrusher#
			 * @type {number}
			 * @name bits
			 */
		    Object.defineProperty(Tone.BitCrusher.prototype, 'bits', {
		        get: function () {
		            return this._bits;
		        },
		        set: function (bits) {
		            this._bits = bits;
		            var invStepSize = 1 / Math.pow(2, bits - 1);
		            this._modulo.value = invStepSize;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.BitCrusher} this
			 */
		    Tone.BitCrusher.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._subtract.dispose();
		        this._subtract = null;
		        this._modulo.dispose();
		        this._modulo = null;
		        return this;
		    };
		    return Tone.BitCrusher;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.ChebyShev is a Chebyshev waveshaper, an effect which is good 
			 *         for making different types of distortion sounds.
			 *         Note that odd orders sound very different from even ones, 
			 *         and order = 1 is no change. 
			 *         Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {Positive|Object} [order] The order of the chebyshev polynomial. Normal range between 1-100. 
			 *  @example
			 * //create a new cheby
			 * var cheby = new Tone.Chebyshev(50);
			 * //create a monosynth connected to our cheby
			 * synth = new Tone.MonoSynth().connect(cheby);
			 */
		    Tone.Chebyshev = function () {
		        var options = this.optionsObject(arguments, ['order'], Tone.Chebyshev.defaults);
		        Tone.Effect.call(this);
		        /**
				 *  @type {WaveShaperNode}
				 *  @private
				 */
		        this._shaper = new Tone.WaveShaper(4096);
		        /**
				 * holds onto the order of the filter
				 * @type {number}
				 * @private
				 */
		        this._order = options.order;
		        this.connectEffect(this._shaper);
		        this.order = options.order;
		        this.oversample = options.oversample;
		    };
		    Tone.extend(Tone.Chebyshev, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Chebyshev.defaults = {
		        'order': 1,
		        'oversample': 'none'
		    };
		    /**
			 *  get the coefficient for that degree
			 *  @param {number} x the x value
			 *  @param   {number} degree 
			 *  @param {Object} memo memoize the computed value. 
			 *                       this speeds up computation greatly. 
			 *  @return  {number}       the coefficient 
			 *  @private
			 */
		    Tone.Chebyshev.prototype._getCoefficient = function (x, degree, memo) {
		        if (memo.hasOwnProperty(degree)) {
		            return memo[degree];
		        } else if (degree === 0) {
		            memo[degree] = 0;
		        } else if (degree === 1) {
		            memo[degree] = x;
		        } else {
		            memo[degree] = 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo);
		        }
		        return memo[degree];
		    };
		    /**
			 * The order of the Chebyshev polynomial which creates
			 * the equation which is applied to the incoming 
			 * signal through a Tone.WaveShaper. The equations
			 * are in the form:<br>
			 * order 2: 2x^2 + 1<br>
			 * order 3: 4x^3 + 3x <br>
			 * @memberOf Tone.Chebyshev#
			 * @type {Positive}
			 * @name order
			 */
		    Object.defineProperty(Tone.Chebyshev.prototype, 'order', {
		        get: function () {
		            return this._order;
		        },
		        set: function (order) {
		            this._order = order;
		            var curve = new Array(4096);
		            var len = curve.length;
		            for (var i = 0; i < len; ++i) {
		                var x = i * 2 / len - 1;
		                if (x === 0) {
		                    //should output 0 when input is 0
		                    curve[i] = 0;
		                } else {
		                    curve[i] = this._getCoefficient(x, order, {});
		                }
		            }
		            this._shaper.curve = curve;
		        }
		    });
		    /**
			 * The oversampling of the effect. Can either be "none", "2x" or "4x".
			 * @memberOf Tone.Chebyshev#
			 * @type {string}
			 * @name oversample
			 */
		    Object.defineProperty(Tone.Chebyshev.prototype, 'oversample', {
		        get: function () {
		            return this._shaper.oversample;
		        },
		        set: function (oversampling) {
		            this._shaper.oversample = oversampling;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Chebyshev} this
			 */
		    Tone.Chebyshev.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._shaper.dispose();
		        this._shaper = null;
		        return this;
		    };
		    return Tone.Chebyshev;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Base class for Stereo effects. Provides effectSendL/R and effectReturnL/R. 
			 *
			 *	@constructor
			 *	@extends {Tone.Effect}
			 */
		    Tone.StereoEffect = function () {
		        Tone.call(this);
		        //get the defaults
		        var options = this.optionsObject(arguments, ['wet'], Tone.Effect.defaults);
		        /**
				 *  the drywet knob to control the amount of effect
				 *  @type {Tone.CrossFade}
				 *  @private
				 */
		        this._dryWet = new Tone.CrossFade(options.wet);
		        /**
				 *  The wet control, i.e. how much of the effected
				 *  will pass through to the output. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.wet = this._dryWet.fade;
		        /**
				 *  then split it
				 *  @type {Tone.Split}
				 *  @private
				 */
		        this._split = new Tone.Split();
		        /**
				 *  the effects send LEFT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectSendL = this._split.left;
		        /**
				 *  the effects send RIGHT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectSendR = this._split.right;
		        /**
				 *  the stereo effect merger
				 *  @type {Tone.Merge}
				 *  @private
				 */
		        this._merge = new Tone.Merge();
		        /**
				 *  the effect return LEFT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectReturnL = this._merge.left;
		        /**
				 *  the effect return RIGHT
				 *  @type {GainNode}
				 *  @private
				 */
		        this.effectReturnR = this._merge.right;
		        //connections
		        this.input.connect(this._split);
		        //dry wet connections
		        this.input.connect(this._dryWet, 0, 0);
		        this._merge.connect(this._dryWet, 0, 1);
		        this._dryWet.connect(this.output);
		        this._readOnly(['wet']);
		    };
		    Tone.extend(Tone.StereoEffect, Tone.Effect);
		    /**
			 *  Clean up. 
			 *  @returns {Tone.StereoEffect} this
			 */
		    Tone.StereoEffect.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._dryWet.dispose();
		        this._dryWet = null;
		        this._split.dispose();
		        this._split = null;
		        this._merge.dispose();
		        this._merge = null;
		        this.effectSendL = null;
		        this.effectSendR = null;
		        this.effectReturnL = null;
		        this.effectReturnR = null;
		        this._writable(['wet']);
		        this.wet = null;
		        return this;
		    };
		    return Tone.StereoEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Tone.FeedbackEffect provides a loop between an 
			 * 	        audio source and its own output. This is a base-class
			 * 	        for feedback effects. 
			 *
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {NormalRange|Object} [feedback] The initial feedback value.
			 */
		    Tone.FeedbackEffect = function () {
		        var options = this.optionsObject(arguments, ['feedback']);
		        options = this.defaultArg(options, Tone.FeedbackEffect.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  The amount of signal which is fed back into the effect input. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
		        /**
				 *  the gain which controls the feedback
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedbackGain = this.context.createGain();
		        //the feedback loop
		        this.effectReturn.chain(this._feedbackGain, this.effectSend);
		        this.feedback.connect(this._feedbackGain.gain);
		        this._readOnly(['feedback']);
		    };
		    Tone.extend(Tone.FeedbackEffect, Tone.Effect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.FeedbackEffect.defaults = { 'feedback': 0.125 };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.FeedbackEffect} this
			 */
		    Tone.FeedbackEffect.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._writable(['feedback']);
		        this.feedback.dispose();
		        this.feedback = null;
		        this._feedbackGain.disconnect();
		        this._feedbackGain = null;
		        return this;
		    };
		    return Tone.FeedbackEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Just like a stereo feedback effect, but the feedback is routed from left to right
			 *         and right to left instead of on the same channel.
			 *
			 *	@constructor
			 *	@extends {Tone.FeedbackEffect}
			 */
		    Tone.StereoXFeedbackEffect = function () {
		        var options = this.optionsObject(arguments, ['feedback'], Tone.FeedbackEffect.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  The amount of feedback from the output
				 *  back into the input of the effect (routed
				 *  across left and right channels).
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
		        /**
				 *  the left side feeback
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedbackLR = this.context.createGain();
		        /**
				 *  the right side feeback
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedbackRL = this.context.createGain();
		        //connect it up
		        this.effectReturnL.chain(this._feedbackLR, this.effectSendR);
		        this.effectReturnR.chain(this._feedbackRL, this.effectSendL);
		        this.feedback.fan(this._feedbackLR.gain, this._feedbackRL.gain);
		        this._readOnly(['feedback']);
		    };
		    Tone.extend(Tone.StereoXFeedbackEffect, Tone.FeedbackEffect);
		    /**
			 *  clean up
			 *  @returns {Tone.StereoXFeedbackEffect} this
			 */
		    Tone.StereoXFeedbackEffect.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        this._writable(['feedback']);
		        this.feedback.dispose();
		        this.feedback = null;
		        this._feedbackLR.disconnect();
		        this._feedbackLR = null;
		        this._feedbackRL.disconnect();
		        this._feedbackRL = null;
		        return this;
		    };
		    return Tone.StereoXFeedbackEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Chorus is a stereo chorus effect with feedback composed of 
			 *         a left and right delay with a Tone.LFO applied to the delayTime of each channel. 
			 *         Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).
			 *         Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).
			 *
			 *	@constructor
			 *	@extends {Tone.StereoXFeedbackEffect}
			 *	@param {Frequency|Object} [frequency] The frequency of the LFO.
			 *	@param {Number} [delayTime] The delay of the chorus effect in ms. 
			 *	@param {NormalRange} [depth] The depth of the chorus.
			 *	@example
			 * var chorus = new Tone.Chorus(4, 2.5, 0.5);
			 * var synth = new Tone.PolySynth(4, Tone.MonoSynth).connect(chorus);
			 * synth.triggerAttackRelease(["C3","E3","G3"], "8n");
			 */
		    Tone.Chorus = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'delayTime',
		            'depth'
		        ], Tone.Chorus.defaults);
		        Tone.StereoXFeedbackEffect.call(this, options);
		        /**
				 *  the depth of the chorus
				 *  @type {number}
				 *  @private
				 */
		        this._depth = options.depth;
		        /**
				 *  the delayTime
				 *  @type {number}
				 *  @private
				 */
		        this._delayTime = options.delayTime / 1000;
		        /**
				 *  the lfo which controls the delayTime
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoL = new Tone.LFO(options.rate, 0, 1);
		        /**
				 *  another LFO for the right side with a 180 degree phase diff
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoR = new Tone.LFO(options.rate, 0, 1);
		        this._lfoR.phase = 180;
		        /**
				 *  delay for left
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delayNodeL = this.context.createDelay();
		        /**
				 *  delay for right
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delayNodeR = this.context.createDelay();
		        /**
				 * The frequency of the LFO which modulates the delayTime. 
				 * @type {Frequency}
				 * @signal
				 */
		        this.frequency = this._lfoL.frequency;
		        //connections
		        this.connectSeries(this.effectSendL, this._delayNodeL, this.effectReturnL);
		        this.connectSeries(this.effectSendR, this._delayNodeR, this.effectReturnR);
		        //and pass through to make the detune apparent
		        this.input.connect(this.output);
		        //lfo setup
		        this._lfoL.connect(this._delayNodeL.delayTime);
		        this._lfoR.connect(this._delayNodeR.delayTime);
		        //start the lfo
		        this._lfoL.start();
		        this._lfoR.start();
		        //have one LFO frequency control the other
		        this._lfoL.frequency.connect(this._lfoR.frequency);
		        //set the initial values
		        this.depth = this._depth;
		        this.frequency.value = options.frequency;
		        this.type = options.type;
		        this._readOnly(['frequency']);
		    };
		    Tone.extend(Tone.Chorus, Tone.StereoXFeedbackEffect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Chorus.defaults = {
		        'frequency': 1.5,
		        'delayTime': 3.5,
		        'depth': 0.7,
		        'feedback': 0.1,
		        'type': 'sine'
		    };
		    /**
			 * The depth of the effect. A depth of 1 makes the delayTime
			 * modulate between 0 and 2*delayTime (centered around the delayTime). 
			 * @memberOf Tone.Chorus#
			 * @type {NormalRange}
			 * @name depth
			 */
		    Object.defineProperty(Tone.Chorus.prototype, 'depth', {
		        get: function () {
		            return this._depth;
		        },
		        set: function (depth) {
		            this._depth = depth;
		            var deviation = this._delayTime * depth;
		            this._lfoL.min = Math.max(this._delayTime - deviation, 0);
		            this._lfoL.max = this._delayTime + deviation;
		            this._lfoR.min = Math.max(this._delayTime - deviation, 0);
		            this._lfoR.max = this._delayTime + deviation;
		        }
		    });
		    /**
			 * The delayTime in milliseconds of the chorus. A larger delayTime
			 * will give a more pronounced effect. Nominal range a delayTime
			 * is between 2 and 20ms. 
			 * @memberOf Tone.Chorus#
			 * @type {Number}
			 * @name delayTime
			 */
		    Object.defineProperty(Tone.Chorus.prototype, 'delayTime', {
		        get: function () {
		            return this._delayTime * 1000;
		        },
		        set: function (delayTime) {
		            this._delayTime = delayTime / 1000;
		            this.depth = this._depth;
		        }
		    });
		    /**
			 * The oscillator type of the LFO. 
			 * @memberOf Tone.Chorus#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.Chorus.prototype, 'type', {
		        get: function () {
		            return this._lfoL.type;
		        },
		        set: function (type) {
		            this._lfoL.type = type;
		            this._lfoR.type = type;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Chorus} this
			 */
		    Tone.Chorus.prototype.dispose = function () {
		        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
		        this._lfoL.dispose();
		        this._lfoL = null;
		        this._lfoR.dispose();
		        this._lfoR = null;
		        this._delayNodeL.disconnect();
		        this._delayNodeL = null;
		        this._delayNodeR.disconnect();
		        this._delayNodeR = null;
		        this._writable('frequency');
		        this.frequency = null;
		        return this;
		    };
		    return Tone.Chorus;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Convolver is a wrapper around the Native Web Audio 
			 *          [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).
			 *          Convolution is useful for reverb and filter emulation. Read more about convolution reverb on
			 *          [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).
			 *  
			 *  @constructor
			 *  @extends {Tone.Effect}
			 *  @param {string|Tone.Buffer|Object} [url] The URL of the impulse response or the Tone.Buffer
			 *                                           contianing the impulse response. 
			 *  @example
			 * //initializing the convolver with an impulse response
			 * var convolver = new Tone.Convolver("./path/to/ir.wav");
			 * convolver.toMaster();
			 * //after the buffer has loaded
			 * Tone.Buffer.onload = function(){
			 * 	//testing out convolution with a noise burst
			 * 	var burst = new Tone.NoiseSynth().connect(convolver);
			 * 	burst.triggerAttackRelease("16n");
			 * };
			 */
		    Tone.Convolver = function () {
		        var options = this.optionsObject(arguments, ['url'], Tone.Convolver.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  convolver node
				 *  @type {ConvolverNode}
				 *  @private
				 */
		        this._convolver = this.context.createConvolver();
		        /**
				 *  the convolution buffer
				 *  @type {Tone.Buffer}
				 *  @private
				 */
		        this._buffer = new Tone.Buffer(options.url, function (buffer) {
		            this.buffer = buffer;
		            options.onload();
		        }.bind(this));
		        this.connectEffect(this._convolver);
		    };
		    Tone.extend(Tone.Convolver, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type  {Object}
			 */
		    Tone.Convolver.defaults = {
		        'url': '',
		        'onload': Tone.noOp
		    };
		    /**
			 *  The convolver's buffer
			 *  @memberOf Tone.Convolver#
			 *  @type {AudioBuffer}
			 *  @name buffer
			 */
		    Object.defineProperty(Tone.Convolver.prototype, 'buffer', {
		        get: function () {
		            return this._buffer.get();
		        },
		        set: function (buffer) {
		            this._buffer.set(buffer);
		            this._convolver.buffer = this._buffer.get();
		        }
		    });
		    /**
			 *  Load an impulse response url as an audio buffer.
			 *  Decodes the audio asynchronously and invokes
			 *  the callback once the audio buffer loads.
			 *  @param {string} url The url of the buffer to load.
			 *                      filetype support depends on the
			 *                      browser.
			 *  @param  {function=} callback
			 *  @returns {Tone.Convolver} this
			 */
		    Tone.Convolver.prototype.load = function (url, callback) {
		        this._buffer.load(url, function (buff) {
		            this.buffer = buff;
		            if (callback) {
		                callback();
		            }
		        }.bind(this));
		        return this;
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Convolver} this
			 */
		    Tone.Convolver.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._convolver.disconnect();
		        this._convolver = null;
		        this._buffer.dispose();
		        this._buffer = null;
		        return this;
		    };
		    return Tone.Convolver;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Distortion is a simple distortion effect using Tone.WaveShaper.
			 *         Algorithm from [a stackoverflow answer](http://stackoverflow.com/a/22313408).
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {Number|Object} [distortion] The amount of distortion (nominal range of 0-1)
			 *  @example
			 * var dist = new Tone.Distortion(0.8).toMaster();
			 * var fm = new Tone.SimpleFM().connect(dist);
			 * //this sounds good on bass notes
			 * fm.triggerAttackRelease("A1", "8n");
			 */
		    Tone.Distortion = function () {
		        var options = this.optionsObject(arguments, ['distortion'], Tone.Distortion.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  @type {Tone.WaveShaper}
				 *  @private
				 */
		        this._shaper = new Tone.WaveShaper(4096);
		        /**
				 * holds the distortion amount
				 * @type {number}
				 * @private
				 */
		        this._distortion = options.distortion;
		        this.connectEffect(this._shaper);
		        this.distortion = options.distortion;
		        this.oversample = options.oversample;
		    };
		    Tone.extend(Tone.Distortion, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Distortion.defaults = {
		        'distortion': 0.4,
		        'oversample': 'none'
		    };
		    /**
			 * The amount of distortion. Range between 0-1. 
			 * @memberOf Tone.Distortion#
			 * @type {number}
			 * @name distortion
			 */
		    Object.defineProperty(Tone.Distortion.prototype, 'distortion', {
		        get: function () {
		            return this._distortion;
		        },
		        set: function (amount) {
		            this._distortion = amount;
		            var k = amount * 100;
		            var deg = Math.PI / 180;
		            this._shaper.setMap(function (x) {
		                if (Math.abs(x) < 0.001) {
		                    //should output 0 when input is 0
		                    return 0;
		                } else {
		                    return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
		                }
		            });
		        }
		    });
		    /**
			 * The oversampling of the effect. Can either be "none", "2x" or "4x".
			 * @memberOf Tone.Distortion#
			 * @type {string}
			 * @name oversample
			 */
		    Object.defineProperty(Tone.Distortion.prototype, 'oversample', {
		        get: function () {
		            return this._shaper.oversample;
		        },
		        set: function (oversampling) {
		            this._shaper.oversample = oversampling;
		        }
		    });
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Distortion} this
			 */
		    Tone.Distortion.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._shaper.dispose();
		        this._shaper = null;
		        return this;
		    };
		    return Tone.Distortion;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.FeedbackDelay is a DelayNode in which part of output
			 *          signal is fed back into the delay. 
			 *
			 *  @constructor
			 *  @extends {Tone.FeedbackEffect}
			 *  @param {Time|Object} [delayTime] The delay applied to the incoming signal. 
			 *  @param {NormalRange=} feedback The amount of the effected signal which 
			 *                            is fed back through the delay.
			 *  @example
			 * var feedbackDelay = new Tone.FeedbackDelay("8n", 0.5).toMaster();
			 * var tom = new Tone.DrumSynth({
			 * 	"octaves" : 4,
			 * 	"pitchDecay" : 0.1
			 * }).connect(feedbackDelay);
			 * tom.triggerAttackRelease("A2","32n");
			 */
		    Tone.FeedbackDelay = function () {
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'feedback'
		        ], Tone.FeedbackDelay.defaults);
		        Tone.FeedbackEffect.call(this, options);
		        /**
				 *  The delayTime of the DelayNode. 
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
		        /**
				 *  the delay node
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._delayNode = this.context.createDelay(4);
		        // connect it up
		        this.connectEffect(this._delayNode);
		        this.delayTime.connect(this._delayNode.delayTime);
		        this._readOnly(['delayTime']);
		    };
		    Tone.extend(Tone.FeedbackDelay, Tone.FeedbackEffect);
		    /**
			 *  The default values. 
			 *  @const
			 *  @static
			 *  @type {Object}
			 */
		    Tone.FeedbackDelay.defaults = { 'delayTime': 0.25 };
		    /**
			 *  clean up
			 *  @returns {Tone.FeedbackDelay} this
			 */
		    Tone.FeedbackDelay.prototype.dispose = function () {
		        Tone.FeedbackEffect.prototype.dispose.call(this);
		        this.delayTime.dispose();
		        this._delayNode.disconnect();
		        this._delayNode = null;
		        this._writable(['delayTime']);
		        this.delayTime = null;
		        return this;
		    };
		    return Tone.FeedbackDelay;
		});
		Module(function (Tone) {
		    
		    /**
			 *  an array of comb filter delay values from Freeverb implementation
			 *  @static
			 *  @private
			 *  @type {Array}
			 */
		    var combFilterTunings = [
		        1557 / 44100,
		        1617 / 44100,
		        1491 / 44100,
		        1422 / 44100,
		        1277 / 44100,
		        1356 / 44100,
		        1188 / 44100,
		        1116 / 44100
		    ];
		    /**
			 *  an array of allpass filter frequency values from Freeverb implementation
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var allpassFilterFrequencies = [
		        225,
		        556,
		        441,
		        341
		    ];
		    /**
			 *  @class Tone.Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).
			 *         Read more on reverb on [SoundOnSound](http://www.soundonsound.com/sos/may00/articles/reverb.htm).
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {NormalRange|Object} [roomSize] Correlated to the decay time. 
			 *  @param {Frequency} [dampening] The cutoff frequency of a lowpass filter as part 
			 *                                 of the reverb. 
			 *  @example
			 * var freeverb = new Tone.Freeverb().toMaster();
			 * freeverb.dampening.value = 1000;
			 * //routing synth through the reverb
			 * var synth = new Tone.AMSynth().connect(freeverb);
			 */
		    Tone.Freeverb = function () {
		        var options = this.optionsObject(arguments, [
		            'roomSize',
		            'dampening'
		        ], Tone.Freeverb.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  The roomSize value between. A larger roomSize
				 *  will result in a longer decay. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
		        /**
				 *  The amount of dampening of the reverberant signal. 
				 *  @type {Frequency}
				 *  @signal
				 */
		        this.dampening = new Tone.Signal(options.dampening, Tone.Type.Frequency);
		        /**
				 *  the comb filters
				 *  @type {Array}
				 *  @private
				 */
		        this._combFilters = [];
		        /**
				 *  the allpass filters on the left
				 *  @type {Array}
				 *  @private
				 */
		        this._allpassFiltersL = [];
		        /**
				 *  the allpass filters on the right
				 *  @type {Array}
				 *  @private
				 */
		        this._allpassFiltersR = [];
		        //make the allpass filters on teh right
		        for (var l = 0; l < allpassFilterFrequencies.length; l++) {
		            var allpassL = this.context.createBiquadFilter();
		            allpassL.type = 'allpass';
		            allpassL.frequency.value = allpassFilterFrequencies[l];
		            this._allpassFiltersL.push(allpassL);
		        }
		        //make the allpass filters on the left
		        for (var r = 0; r < allpassFilterFrequencies.length; r++) {
		            var allpassR = this.context.createBiquadFilter();
		            allpassR.type = 'allpass';
		            allpassR.frequency.value = allpassFilterFrequencies[r];
		            this._allpassFiltersR.push(allpassR);
		        }
		        //make the comb filters
		        for (var c = 0; c < combFilterTunings.length; c++) {
		            var lfpf = new Tone.LowpassCombFilter(combFilterTunings[c]);
		            if (c < combFilterTunings.length / 2) {
		                this.effectSendL.chain(lfpf, this._allpassFiltersL[0]);
		            } else {
		                this.effectSendR.chain(lfpf, this._allpassFiltersR[0]);
		            }
		            this.roomSize.connect(lfpf.resonance);
		            this.dampening.connect(lfpf.dampening);
		            this._combFilters.push(lfpf);
		        }
		        //chain the allpass filters togetehr
		        this.connectSeries.apply(this, this._allpassFiltersL);
		        this.connectSeries.apply(this, this._allpassFiltersR);
		        this._allpassFiltersL[this._allpassFiltersL.length - 1].connect(this.effectReturnL);
		        this._allpassFiltersR[this._allpassFiltersR.length - 1].connect(this.effectReturnR);
		        this._readOnly([
		            'roomSize',
		            'dampening'
		        ]);
		    };
		    Tone.extend(Tone.Freeverb, Tone.StereoEffect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.Freeverb.defaults = {
		        'roomSize': 0.7,
		        'dampening': 3000
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.Freeverb} this
			 */
		    Tone.Freeverb.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        for (var al = 0; al < this._allpassFiltersL.length; al++) {
		            this._allpassFiltersL[al].disconnect();
		            this._allpassFiltersL[al] = null;
		        }
		        this._allpassFiltersL = null;
		        for (var ar = 0; ar < this._allpassFiltersR.length; ar++) {
		            this._allpassFiltersR[ar].disconnect();
		            this._allpassFiltersR[ar] = null;
		        }
		        this._allpassFiltersR = null;
		        for (var cf = 0; cf < this._combFilters.length; cf++) {
		            this._combFilters[cf].dispose();
		            this._combFilters[cf] = null;
		        }
		        this._combFilters = null;
		        this._writable([
		            'roomSize',
		            'dampening'
		        ]);
		        this.roomSize.dispose();
		        this.roomSize = null;
		        this.dampening.dispose();
		        this.dampening = null;
		        return this;
		    };
		    return Tone.Freeverb;
		});
		Module(function (Tone) {
		    
		    /**
			 *  an array of the comb filter delay time values
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var combFilterDelayTimes = [
		        1687 / 25000,
		        1601 / 25000,
		        2053 / 25000,
		        2251 / 25000
		    ];
		    /**
			 *  the resonances of each of the comb filters
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var combFilterResonances = [
		        0.773,
		        0.802,
		        0.753,
		        0.733
		    ];
		    /**
			 *  the allpass filter frequencies
			 *  @private
			 *  @static
			 *  @type {Array}
			 */
		    var allpassFilterFreqs = [
		        347,
		        113,
		        37
		    ];
		    /**
			 *  @class Tone.JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)
			 *         tuned by John Chowning in 1970.
			 *         It is made up of three allpass filters and four Tone.FeedbackCombFilter. 
			 *         
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {NormalRange|Object} [roomSize] Coorelates to the decay time.
			 *  @example
			 * var reverb = new Tone.JCReverb(0.4).connect(Tone.Master);
			 * var delay = new Tone.FeedbackDelay(0.5); 
			 * //connecting the synth to reverb through delay
			 * var synth = new Tone.DuoSynth().chain(delay, reverb);
			 * synth.triggerAttackRelease("A4","8n");
			 */
		    Tone.JCReverb = function () {
		        var options = this.optionsObject(arguments, ['roomSize'], Tone.JCReverb.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  room size control values between [0,1]
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);
		        /**
				 *  scale the room size
				 *  @type {Tone.Scale}
				 *  @private
				 */
		        this._scaleRoomSize = new Tone.Scale(-0.733, 0.197);
		        /**
				 *  a series of allpass filters
				 *  @type {Array}
				 *  @private
				 */
		        this._allpassFilters = [];
		        /**
				 *  parallel feedback comb filters
				 *  @type {Array}
				 *  @private
				 */
		        this._feedbackCombFilters = [];
		        //make the allpass filters
		        for (var af = 0; af < allpassFilterFreqs.length; af++) {
		            var allpass = this.context.createBiquadFilter();
		            allpass.type = 'allpass';
		            allpass.frequency.value = allpassFilterFreqs[af];
		            this._allpassFilters.push(allpass);
		        }
		        //and the comb filters
		        for (var cf = 0; cf < combFilterDelayTimes.length; cf++) {
		            var fbcf = new Tone.FeedbackCombFilter(combFilterDelayTimes[cf], 0.1);
		            this._scaleRoomSize.connect(fbcf.resonance);
		            fbcf.resonance.value = combFilterResonances[cf];
		            this._allpassFilters[this._allpassFilters.length - 1].connect(fbcf);
		            if (cf < combFilterDelayTimes.length / 2) {
		                fbcf.connect(this.effectReturnL);
		            } else {
		                fbcf.connect(this.effectReturnR);
		            }
		            this._feedbackCombFilters.push(fbcf);
		        }
		        //chain the allpass filters together
		        this.roomSize.connect(this._scaleRoomSize);
		        this.connectSeries.apply(this, this._allpassFilters);
		        this.effectSendL.connect(this._allpassFilters[0]);
		        this.effectSendR.connect(this._allpassFilters[0]);
		        this._readOnly(['roomSize']);
		    };
		    Tone.extend(Tone.JCReverb, Tone.StereoEffect);
		    /**
			 *  the default values
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.JCReverb.defaults = { 'roomSize': 0.5 };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.JCReverb} this
			 */
		    Tone.JCReverb.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        for (var apf = 0; apf < this._allpassFilters.length; apf++) {
		            this._allpassFilters[apf].disconnect();
		            this._allpassFilters[apf] = null;
		        }
		        this._allpassFilters = null;
		        for (var fbcf = 0; fbcf < this._feedbackCombFilters.length; fbcf++) {
		            this._feedbackCombFilters[fbcf].dispose();
		            this._feedbackCombFilters[fbcf] = null;
		        }
		        this._feedbackCombFilters = null;
		        this._writable(['roomSize']);
		        this.roomSize.dispose();
		        this.roomSize = null;
		        this._scaleRoomSize.dispose();
		        this._scaleRoomSize = null;
		        return this;
		    };
		    return Tone.JCReverb;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Mid/Side processing separates the the 'mid' signal 
			 *         (which comes out of both the left and the right channel) 
			 *         and the 'side' (which only comes out of the the side channels) 
			 *         and effects them separately before being recombined.
			 *         Applies a Mid/Side seperation and recombination.
			 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
			 *         <br><br>
			 *         This is a base-class for Mid/Side Effects. 
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 */
		    Tone.MidSideEffect = function () {
		        Tone.Effect.call(this);
		        /**
				 *  The mid/side split
				 *  @type  {Tone.MidSideSplit}
				 *  @private
				 */
		        this._midSideSplit = new Tone.MidSideSplit();
		        /**
				 *  The mid/side merge
				 *  @type  {Tone.MidSideMerge}
				 *  @private
				 */
		        this._midSideMerge = new Tone.MidSideMerge();
		        /**
				 *  The mid send. Connect to mid processing
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this.midSend = this._midSideSplit.mid;
		        /**
				 *  The side send. Connect to side processing
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this.sideSend = this._midSideSplit.side;
		        /**
				 *  The mid return connection
				 *  @type {GainNode}
				 *  @private
				 */
		        this.midReturn = this._midSideMerge.mid;
		        /**
				 *  The side return connection
				 *  @type {GainNode}
				 *  @private
				 */
		        this.sideReturn = this._midSideMerge.side;
		        //the connections
		        this.effectSend.connect(this._midSideSplit);
		        this._midSideMerge.connect(this.effectReturn);
		    };
		    Tone.extend(Tone.MidSideEffect, Tone.Effect);
		    /**
			 *  Clean up. 
			 *  @returns {Tone.MidSideEffect} this
			 */
		    Tone.MidSideEffect.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._midSideSplit.dispose();
		        this._midSideSplit = null;
		        this._midSideMerge.dispose();
		        this._midSideMerge = null;
		        this.midSend = null;
		        this.sideSend = null;
		        this.midReturn = null;
		        this.sideReturn = null;
		        return this;
		    };
		    return Tone.MidSideEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Phaser is a phaser effect. Phasers work by changing the phase
			 *         of different frequency components of an incoming signal. Read more on 
			 *         [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)). 
			 *         Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).
			 *
			 *	@extends {Tone.StereoEffect}
			 *	@constructor
			 *	@param {Frequency|Object} [frequency] The speed of the phasing. 
			 *	@param {number} [depth] The depth of the effect. 
			 *	@param {Frequency} [baseFrequency] The base frequency of the filters. 
			 *	@example
			 * var phaser = new Tone.Phaser({
			 * 	"frequency" : 15, 
			 * 	"depth" : 5, 
			 * 	"baseFrequency" : 1000
			 * }).toMaster();
			 * var synth = new Tone.FMSynth().connect(phaser);
			 * synth.triggerAttackRelease("E3", "2n");
			 */
		    Tone.Phaser = function () {
		        //set the defaults
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'depth',
		            'baseFrequency'
		        ], Tone.Phaser.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  the lfo which controls the frequency on the left side
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoL = new Tone.LFO(options.frequency, 0, 1);
		        /**
				 *  the lfo which controls the frequency on the right side
				 *  @type {Tone.LFO}
				 *  @private
				 */
		        this._lfoR = new Tone.LFO(options.frequency, 0, 1);
		        this._lfoR.phase = 180;
		        /**
				 *  the base modulation frequency
				 *  @type {number}
				 *  @private
				 */
		        this._baseFrequency = options.baseFrequency;
		        /**
				 *  the depth of the phasing
				 *  @type {number}
				 *  @private
				 */
		        this._depth = options.depth;
		        /**
				 *  The quality factor of the filters
				 *  @type {Positive}
				 *  @signal
				 */
		        this.Q = new Tone.Signal(options.Q, Tone.Type.Positive);
		        /**
				 *  the array of filters for the left side
				 *  @type {Array}
				 *  @private
				 */
		        this._filtersL = this._makeFilters(options.stages, this._lfoL, this.Q);
		        /**
				 *  the array of filters for the left side
				 *  @type {Array}
				 *  @private
				 */
		        this._filtersR = this._makeFilters(options.stages, this._lfoR, this.Q);
		        /**
				 * the frequency of the effect
				 * @type {Tone.Signal}
				 */
		        this.frequency = this._lfoL.frequency;
		        this.frequency.value = options.frequency;
		        //connect them up
		        this.effectSendL.connect(this._filtersL[0]);
		        this.effectSendR.connect(this._filtersR[0]);
		        this._filtersL[options.stages - 1].connect(this.effectReturnL);
		        this._filtersR[options.stages - 1].connect(this.effectReturnR);
		        //control the frequency with one LFO
		        this._lfoL.frequency.connect(this._lfoR.frequency);
		        //set the options
		        this.baseFrequency = options.baseFrequency;
		        this.depth = options.depth;
		        //start the lfo
		        this._lfoL.start();
		        this._lfoR.start();
		        this._readOnly([
		            'frequency',
		            'Q'
		        ]);
		    };
		    Tone.extend(Tone.Phaser, Tone.StereoEffect);
		    /**
			 *  defaults
			 *  @static
			 *  @type {object}
			 */
		    Tone.Phaser.defaults = {
		        'frequency': 0.5,
		        'depth': 10,
		        'stages': 10,
		        'Q': 10,
		        'baseFrequency': 350
		    };
		    /**
			 *  @param {number} stages
			 *  @returns {Array} the number of filters all connected together
			 *  @private
			 */
		    Tone.Phaser.prototype._makeFilters = function (stages, connectToFreq, Q) {
		        var filters = new Array(stages);
		        //make all the filters
		        for (var i = 0; i < stages; i++) {
		            var filter = this.context.createBiquadFilter();
		            filter.type = 'allpass';
		            Q.connect(filter.Q);
		            connectToFreq.connect(filter.frequency);
		            filters[i] = filter;
		        }
		        this.connectSeries.apply(this, filters);
		        return filters;
		    };
		    /**
			 * The depth of the effect. 
			 * @memberOf Tone.Phaser#
			 * @type {number}
			 * @name depth
			 */
		    Object.defineProperty(Tone.Phaser.prototype, 'depth', {
		        get: function () {
		            return this._depth;
		        },
		        set: function (depth) {
		            this._depth = depth;
		            var max = this._baseFrequency + this._baseFrequency * depth;
		            this._lfoL.max = max;
		            this._lfoR.max = max;
		        }
		    });
		    /**
			 * The the base frequency of the filters. 
			 * @memberOf Tone.Phaser#
			 * @type {number}
			 * @name baseFrequency
			 */
		    Object.defineProperty(Tone.Phaser.prototype, 'baseFrequency', {
		        get: function () {
		            return this._baseFrequency;
		        },
		        set: function (freq) {
		            this._baseFrequency = freq;
		            this._lfoL.min = freq;
		            this._lfoR.min = freq;
		            this.depth = this._depth;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.Phaser} this
			 */
		    Tone.Phaser.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'Q'
		        ]);
		        this.Q.dispose();
		        this.Q = null;
		        this._lfoL.dispose();
		        this._lfoL = null;
		        this._lfoR.dispose();
		        this._lfoR = null;
		        for (var i = 0; i < this._filtersL.length; i++) {
		            this._filtersL[i].disconnect();
		            this._filtersL[i] = null;
		        }
		        this._filtersL = null;
		        for (var j = 0; j < this._filtersR.length; j++) {
		            this._filtersR[j].disconnect();
		            this._filtersR[j] = null;
		        }
		        this._filtersR = null;
		        this.frequency = null;
		        return this;
		    };
		    return Tone.Phaser;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.PingPongDelay is a feedback delay effect where the echo is heard
			 *          first in one channel and next in the opposite channel. In a stereo
			 *          system these are the right and left channels.
			 *          PingPongDelay in more simplified terms is two Tone.FeedbackDelays 
			 *          with independent delay values. Each delay is routed to one channel
			 *          (left or right), and the channel triggered second will always 
			 *          trigger at the same interval after the first.
			 *
			 * 	@constructor
			 * 	@extends {Tone.StereoXFeedbackEffect}
			 *  @param {Time|Object} [delayTime] The delayTime between consecutive echos.
			 *  @param {NormalRange=} feedback The amount of the effected signal which 
			 *                                 is fed back through the delay.
			 *  @example
			 * var pingPong = new Tone.PingPongDelay("4n", 0.2).toMaster();
			 * var drum = new Tone.DrumSynth().connect(pingPong);
			 * drum.triggerAttackRelease("C4", "32n");
			 */
		    Tone.PingPongDelay = function () {
		        var options = this.optionsObject(arguments, [
		            'delayTime',
		            'feedback'
		        ], Tone.PingPongDelay.defaults);
		        Tone.StereoXFeedbackEffect.call(this, options);
		        /**
				 *  the delay node on the left side
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._leftDelay = this.context.createDelay(options.maxDelayTime);
		        /**
				 *  the delay node on the right side
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._rightDelay = this.context.createDelay(options.maxDelayTime);
		        /**
				 *  the predelay on the right side
				 *  @type {DelayNode}
				 *  @private
				 */
		        this._rightPreDelay = this.context.createDelay(options.maxDelayTime);
		        /**
				 *  the delay time signal
				 *  @type {Time}
				 *  @signal
				 */
		        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);
		        //connect it up
		        this.effectSendL.chain(this._leftDelay, this.effectReturnL);
		        this.effectSendR.chain(this._rightPreDelay, this._rightDelay, this.effectReturnR);
		        this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);
		        //rearranged the feedback to be after the rightPreDelay
		        this._feedbackLR.disconnect();
		        this._feedbackLR.connect(this._rightDelay);
		        this._readOnly(['delayTime']);
		    };
		    Tone.extend(Tone.PingPongDelay, Tone.StereoXFeedbackEffect);
		    /**
			 *  @static
			 *  @type {Object}
			 */
		    Tone.PingPongDelay.defaults = {
		        'delayTime': 0.25,
		        'maxDelayTime': 1
		    };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.PingPongDelay} this
			 */
		    Tone.PingPongDelay.prototype.dispose = function () {
		        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);
		        this._leftDelay.disconnect();
		        this._leftDelay = null;
		        this._rightDelay.disconnect();
		        this._rightDelay = null;
		        this._rightPreDelay.disconnect();
		        this._rightPreDelay = null;
		        this._writable(['delayTime']);
		        this.delayTime.dispose();
		        this.delayTime = null;
		        return this;
		    };
		    return Tone.PingPongDelay;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Base class for stereo feedback effects where the effectReturn
			 *         is fed back into the same channel. 
			 *
			 *	@constructor
			 *	@extends {Tone.FeedbackEffect}
			 */
		    Tone.StereoFeedbackEffect = function () {
		        var options = this.optionsObject(arguments, ['feedback'], Tone.FeedbackEffect.defaults);
		        Tone.StereoEffect.call(this, options);
		        /**
				 *  controls the amount of feedback
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);
		        /**
				 *  the left side feeback
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedbackL = this.context.createGain();
		        /**
				 *  the right side feeback
				 *  @type {GainNode}
				 *  @private
				 */
		        this._feedbackR = this.context.createGain();
		        //connect it up
		        this.effectReturnL.chain(this._feedbackL, this.effectSendL);
		        this.effectReturnR.chain(this._feedbackR, this.effectSendR);
		        this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);
		        this._readOnly(['feedback']);
		    };
		    Tone.extend(Tone.StereoFeedbackEffect, Tone.FeedbackEffect);
		    /**
			 *  clean up
			 *  @returns {Tone.StereoFeedbackEffect} this
			 */
		    Tone.StereoFeedbackEffect.prototype.dispose = function () {
		        Tone.StereoEffect.prototype.dispose.call(this);
		        this._writable(['feedback']);
		        this.feedback.dispose();
		        this.feedback = null;
		        this._feedbackL.disconnect();
		        this._feedbackL = null;
		        this._feedbackR.disconnect();
		        this._feedbackR = null;
		        return this;
		    };
		    return Tone.StereoFeedbackEffect;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Applies a width factor to the mid/side seperation. 
			 *         0 is all mid and 1 is all side.
			 *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).
			 *         <br><br>
			 *         <code>
			 *         Mid *= 2*(1-width)<br>
			 *         Side *= 2*width
			 *         </code>
			 *
			 *  @extends {Tone.MidSideEffect}
			 *  @constructor
			 *  @param {NormalRange|Object} [width] The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.
			 */
		    Tone.StereoWidener = function () {
		        var options = this.optionsObject(arguments, ['width'], Tone.StereoWidener.defaults);
		        Tone.MidSideEffect.call(this, options);
		        /**
				 *  The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change. 
				 *  @type {NormalRange}
				 *  @signal
				 */
		        this.width = new Tone.Signal(0.5, Tone.Type.NormalRange);
		        /**
				 *  Mid multiplier
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._midMult = new Tone.Expr('$0 * ($1 * (1 - $2))');
		        /**
				 *  Side multiplier
				 *  @type {Tone.Expr}
				 *  @private
				 */
		        this._sideMult = new Tone.Expr('$0 * ($1 * $2)');
		        /**
				 *  constant output of 2
				 *  @type {Tone}
				 *  @private
				 */
		        this._two = new Tone.Signal(2);
		        //the mid chain
		        this._two.connect(this._midMult, 0, 1);
		        this.width.connect(this._midMult, 0, 2);
		        //the side chain
		        this._two.connect(this._sideMult, 0, 1);
		        this.width.connect(this._sideMult, 0, 2);
		        //connect it to the effect send/return
		        this.midSend.chain(this._midMult, this.midReturn);
		        this.sideSend.chain(this._sideMult, this.sideReturn);
		        this._readOnly(['width']);
		    };
		    Tone.extend(Tone.StereoWidener, Tone.MidSideEffect);
		    /**
			 *  the default values
			 *  @static
			 *  @type {Object}
			 */
		    Tone.StereoWidener.defaults = { 'width': 0.5 };
		    /**
			 *  Clean up. 
			 *  @returns {Tone.StereoWidener} this
			 */
		    Tone.StereoWidener.prototype.dispose = function () {
		        Tone.MidSideEffect.prototype.dispose.call(this);
		        this._writable(['width']);
		        this.width.dispose();
		        this.width = null;
		        this._midMult.dispose();
		        this._midMult = null;
		        this._sideMult.dispose();
		        this._sideMult = null;
		        this._two.dispose();
		        this._two = null;
		        return this;
		    };
		    return Tone.StereoWidener;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Tone.Tremelo modulates the amplitude of an incoming signal using a Tone.LFO. 
			 *         The type, frequency, and depth of the LFO is controllable. 
			 *
			 *  @extends {Tone.Effect}
			 *  @constructor
			 *  @param {Frequency|Object} [frequency] The rate of the effect. 
			 *  @param {NormalRange} [depth] The depth of the wavering.
			 *  @example
			 * //create an tremolo and start it's LFO
			 * var tremolo = new Tone.Tremolo(9, 0.75).toMaster().start();
			 * //route an oscillator through the tremolo and start it
			 * var oscillator = new Tone.Oscillator().connect(tremolo).start();
			 */
		    Tone.Tremolo = function () {
		        var options = this.optionsObject(arguments, [
		            'frequency',
		            'depth'
		        ], Tone.Tremolo.defaults);
		        Tone.Effect.call(this, options);
		        /**
				 *  The tremelo LFO
				 *  @type  {Tone.LFO}
				 *  @private
				 */
		        this._lfo = new Tone.LFO({
		            'frequency': options.frequency,
		            'amplitude': options.depth,
		            'min': 1,
		            'max': 0
		        });
		        /**
				 *  Where the gain is multiplied
				 *  @type  {GainNode}
				 *  @private
				 */
		        this._amplitude = this.context.createGain();
		        /**
				 *  The frequency of the tremolo.	
				 *  @type  {Frequency}
				 *  @signal
				 */
		        this.frequency = this._lfo.frequency;
		        /**
				 *  The depth of the effect. A depth of 0, has no effect
				 *  on the amplitude, and a depth of 1 makes the amplitude
				 *  modulate fully between 0 and 1. 
				 *  @type  {NormalRange}
				 *  @signal
				 */
		        this.depth = this._lfo.amplitude;
		        this._readOnly([
		            'frequency',
		            'depth'
		        ]);
		        this.connectEffect(this._amplitude);
		        this._lfo.connect(this._amplitude.gain);
		        this.type = options.type;
		    };
		    Tone.extend(Tone.Tremolo, Tone.Effect);
		    /**
			 *  @static
			 *  @const
			 *  @type {Object}
			 */
		    Tone.Tremolo.defaults = {
		        'frequency': 10,
		        'type': 'sine',
		        'depth': 0.5
		    };
		    /**
			 * Start the tremolo.
			 * @param {Time} [time=now] When the tremolo begins.
			 * @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.start = function (time) {
		        this._lfo.start(time);
		        return this;
		    };
		    /**
			 * Stop the tremolo.
			 * @param {Time} [time=now] When the tremolo stops.
			 * @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.stop = function (time) {
		        this._lfo.stop(time);
		        return this;
		    };
		    /**
			 * Sync the effect to the transport.
			 * @param {Time} [delay=0] Delay time before starting the effect after the
			 *                              Transport has started. 
			 * @returns {Tone.AutoFilter} this
			 */
		    Tone.Tremolo.prototype.sync = function (delay) {
		        this._lfo.sync(delay);
		        return this;
		    };
		    /**
			 * Unsync the filter from the transport
			 * @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.unsync = function () {
		        this._lfo.unsync();
		        return this;
		    };
		    /**
			 * Type of oscillator attached to the Tremolo.
			 * @memberOf Tone.Tremolo#
			 * @type {string}
			 * @name type
			 */
		    Object.defineProperty(Tone.Tremolo.prototype, 'type', {
		        get: function () {
		            return this._lfo.type;
		        },
		        set: function (type) {
		            this._lfo.type = type;
		        }
		    });
		    /**
			 *  clean up
			 *  @returns {Tone.Tremolo} this
			 */
		    Tone.Tremolo.prototype.dispose = function () {
		        Tone.Effect.prototype.dispose.call(this);
		        this._writable([
		            'frequency',
		            'depth'
		        ]);
		        this._lfo.dispose();
		        this._lfo = null;
		        this._amplitude.disconnect();
		        this._amplitude = null;
		        this.frequency = null;
		        this.depth = null;
		        return this;
		    };
		    return Tone.Tremolo;
		});
		Module(function (Tone) {
		    
		    /**
			 * 	@class  Clip the incoming signal so that the output is always between min and max.
			 * 	
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} min the minimum value of the outgoing signal
			 *  @param {number} max the maximum value of the outgoing signal
			 *  @example
			 * var clip = new Tone.Clip(0.5, 1);
			 * var osc = new Tone.Oscillator().connect(clip);
			 * //clips the output of the oscillator to between 0.5 and 1.
			 */
		    Tone.Clip = function (min, max) {
		        //make sure the args are in the right order
		        if (min > max) {
		            var tmp = min;
		            min = max;
		            max = tmp;
		        }
		        /**
				 *  The min clip value
				 *  @type {Number}
				 *  @signal
				 */
		        this.min = this.input = new Tone.Min(max);
		        this._readOnly('min');
		        /**
				 *  The max clip value
				 *  @type {Number}
				 *  @signal
				 */
		        this.max = this.output = new Tone.Max(min);
		        this._readOnly('max');
		        this.min.connect(this.max);
		    };
		    Tone.extend(Tone.Clip, Tone.SignalBase);
		    /**
			 *  clean up
			 *  @returns {Tone.Clip} this
			 */
		    Tone.Clip.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('min');
		        this.min.dispose();
		        this.min = null;
		        this._writable('max');
		        this.max.dispose();
		        this.max = null;
		        return this;
		    };
		    return Tone.Clip;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Normalize takes an input min and max and maps it linearly to NormalRange [0,1]
			 *
			 *  @extends {Tone.SignalBase}
			 *  @constructor
			 *  @param {number} inputMin the min input value
			 *  @param {number} inputMax the max input value
			 *  @example
			 * var norm = new Tone.Normalize(2, 4);
			 * var sig = new Tone.Signal(3).connect(norm);
			 * //output of norm is 0.5. 
			 */
		    Tone.Normalize = function (inputMin, inputMax) {
		        /**
				 *  the min input value
				 *  @type {number}
				 *  @private
				 */
		        this._inputMin = this.defaultArg(inputMin, 0);
		        /**
				 *  the max input value
				 *  @type {number}
				 *  @private
				 */
		        this._inputMax = this.defaultArg(inputMax, 1);
		        /**
				 *  subtract the min from the input
				 *  @type {Tone.Add}
				 *  @private
				 */
		        this._sub = this.input = new Tone.Add(0);
		        /**
				 *  divide by the difference between the input and output
				 *  @type {Tone.Multiply}
				 *  @private
				 */
		        this._div = this.output = new Tone.Multiply(1);
		        this._sub.connect(this._div);
		        this._setRange();
		    };
		    Tone.extend(Tone.Normalize, Tone.SignalBase);
		    /**
			 * The minimum value the input signal will reach.
			 * @memberOf Tone.Normalize#
			 * @type {number}
			 * @name min
			 */
		    Object.defineProperty(Tone.Normalize.prototype, 'min', {
		        get: function () {
		            return this._inputMin;
		        },
		        set: function (min) {
		            this._inputMin = min;
		            this._setRange();
		        }
		    });
		    /**
			 * The maximum value the input signal will reach.
			 * @memberOf Tone.Normalize#
			 * @type {number}
			 * @name max
			 */
		    Object.defineProperty(Tone.Normalize.prototype, 'max', {
		        get: function () {
		            return this._inputMax;
		        },
		        set: function (max) {
		            this._inputMax = max;
		            this._setRange();
		        }
		    });
		    /**
			 *  set the values
			 *  @private
			 */
		    Tone.Normalize.prototype._setRange = function () {
		        this._sub.value = -this._inputMin;
		        this._div.value = 1 / (this._inputMax - this._inputMin);
		    };
		    /**
			 *  clean up
			 *  @returns {Tone.Normalize} this
			 */
		    Tone.Normalize.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._sub.dispose();
		        this._sub = null;
		        this._div.dispose();
		        this._div = null;
		        return this;
		    };
		    return Tone.Normalize;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class Route a single input to the specified output. 
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {number} [outputCount=2] the number of inputs the switch accepts
			 *  @example
			 * var route = new Tone.Route(4);
			 * var signal = new Tone.Signal(3).connect(route);
			 * route.select(0);
			 * //signal is routed through output 0
			 * route.select(3);
			 * //signal is now routed through output 3
			 */
		    Tone.Route = function (outputCount) {
		        outputCount = this.defaultArg(outputCount, 2);
		        Tone.call(this, 1, outputCount);
		        /**
				 *  The control signal.
				 *  @type {Number}
				 *  @signal
				 */
		        this.gate = new Tone.Signal(0);
		        this._readOnly('gate');
		        //make all the inputs and connect them
		        for (var i = 0; i < outputCount; i++) {
		            var routeGate = new RouteGate(i);
		            this.output[i] = routeGate;
		            this.gate.connect(routeGate.selecter);
		            this.input.connect(routeGate);
		        }
		    };
		    Tone.extend(Tone.Route, Tone.SignalBase);
		    /**
			 *  Routes the signal to one of the outputs and close the others.
			 *  @param {number} [which=0] Open one of the gates (closes the other).
			 *  @param {Time} [time=now] The time when the switch will open.
			 *  @returns {Tone.Route} this
			 */
		    Tone.Route.prototype.select = function (which, time) {
		        //make sure it's an integer
		        which = Math.floor(which);
		        this.gate.setValueAtTime(which, this.toSeconds(time));
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Route} this
			 */
		    Tone.Route.prototype.dispose = function () {
		        this._writable('gate');
		        this.gate.dispose();
		        this.gate = null;
		        for (var i = 0; i < this.output.length; i++) {
		            this.output[i].dispose();
		            this.output[i] = null;
		        }
		        Tone.prototype.dispose.call(this);
		        return this;
		    };
		    ////////////START HELPER////////////
		    /**
			 *  helper class for Tone.Route representing a single gate
			 *  @constructor
			 *  @extends {Tone}
			 *  @private
			 */
		    var RouteGate = function (num) {
		        /**
				 *  the selector
				 *  @type {Tone.Equal}
				 */
		        this.selecter = new Tone.Equal(num);
		        /**
				 *  the gate
				 *  @type {GainNode}
				 */
		        this.gate = this.input = this.output = this.context.createGain();
		        //connect the selecter to the gate gain
		        this.selecter.connect(this.gate.gain);
		    };
		    Tone.extend(RouteGate);
		    /**
			 *  clean up
			 *  @private
			 */
		    RouteGate.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this.selecter.dispose();
		        this.selecter = null;
		        this.gate.disconnect();
		        this.gate = null;
		    };
		    ////////////END HELPER////////////
		    //return Tone.Route
		    return Tone.Route;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  When the gate is set to 0, the input signal does not pass through to the output. 
			 *          If the gate is set to 1, the input signal passes through.
			 *          the gate is initially closed.
			 *
			 *  @constructor
			 *  @extends {Tone.SignalBase}
			 *  @param {Boolean} [open=false] If the gate is initially open or closed.
			 *  @example
			 * var sigSwitch = new Tone.Switch();
			 * var signal = new Tone.Signal(2).connect(sigSwitch);
			 * //initially no output from sigSwitch
			 * sigSwitch.gate.value = 1;
			 * //open the switch and allow the signal through
			 * //the output of sigSwitch is now 2. 
			 */
		    Tone.Switch = function (open) {
		        open = this.defaultArg(open, false);
		        Tone.call(this);
		        /**
				 *  The control signal for the switch.
				 *  When this value is 0, the input signal will NOT pass through,
				 *  when it is high (1), the input signal will pass through.
				 *  
				 *  @type {Number}
				 *  @signal
				 */
		        this.gate = new Tone.Signal(0);
		        this._readOnly('gate');
		        /**
				 *  thresh the control signal to either 0 or 1
				 *  @type {Tone.GreaterThan}
				 *  @private
				 */
		        this._thresh = new Tone.GreaterThan(0.5);
		        this.input.connect(this.output);
		        this.gate.chain(this._thresh, this.output.gain);
		        //initially open
		        if (open) {
		            this.open();
		        }
		    };
		    Tone.extend(Tone.Switch, Tone.SignalBase);
		    /**
			 *  Open the switch at a specific time. 
			 *
			 *  @param {Time} [time=now] The time when the switch will be open. 
			 *  @returns {Tone.Switch} this
			 *  @example
			 *  //open the switch to let the signal through
			 *  sigSwitch.open();
			 */
		    Tone.Switch.prototype.open = function (time) {
		        this.gate.setValueAtTime(1, this.toSeconds(time));
		        return this;
		    };
		    /**
			 *  Close the switch at a specific time. 
			 *
			 *  @param {Time} [time=now] The time when the switch will be closed.
			 *  @returns {Tone.Switch} this
			 *  @example
			 *  //close the switch a half second from now
			 *  sigSwitch.close("+0.5");
			 */
		    Tone.Switch.prototype.close = function (time) {
		        this.gate.setValueAtTime(0, this.toSeconds(time));
		        return this;
		    };
		    /**
			 *  Clean up.
			 *  @returns {Tone.Switch} this
			 */
		    Tone.Switch.prototype.dispose = function () {
		        Tone.prototype.dispose.call(this);
		        this._writable('gate');
		        this.gate.dispose();
		        this.gate = null;
		        this._thresh.dispose();
		        this._thresh = null;
		        return this;
		    };
		    return Tone.Switch;
		});
		Module(function (Tone) {
		    
		    /**
			 *  @class  Tone.Microphone is a WebRTC Microphone. Check 
			 *          [Media Stream API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaStream_API)
			 *          to see which browsers are supported. 
			 *
			 *  @constructor
			 *  @extends {Tone.Source}
			 *  @param {number} [inputNum=0] If multiple inputs are present, select the input number.
			 *  @example
			 * //mic will feedback if played through master
			 * var mic = new Tone.Microphone();
			 * mic.start();
			 */
		    Tone.Microphone = function (inputNum) {
		        Tone.Source.call(this);
		        /**
				 *  @type {MediaStreamAudioSourceNode}
				 *  @private
				 */
		        this._mediaStream = null;
		        /**
				 *  @type {LocalMediaStream}
				 *  @private
				 */
		        this._stream = null;
		        /**
				 *  @type {Object}
				 *  @private
				 */
		        this._constraints = { 'audio': true };
		        //get the option
		        var self = this;
		        MediaStreamTrack.getSources(function (media_sources) {
		            if (inputNum < media_sources.length) {
		                self.constraints.audio = { optional: [{ sourceId: media_sources[inputNum].id }] };
		            }
		        });
		    };
		    Tone.extend(Tone.Microphone, Tone.Source);
		    /**
			 *  start the stream. 
			 *  @private
			 */
		    Tone.Microphone.prototype._start = function () {
		        navigator.getUserMedia(this._constraints, this._onStream.bind(this), this._onStreamError.bind(this));
		    };
		    /**
			 *  stop the stream. 
			 *  @private
			 */
		    Tone.Microphone.prototype._stop = function () {
		        this._stream.stop();
		        return this;
		    };
		    /**
			 *  called when the stream is successfully setup
			 *  @param   {LocalMediaStream} stream 
			 *  @private
			 */
		    Tone.Microphone.prototype._onStream = function (stream) {
		        this._stream = stream;
		        // Wrap a MediaStreamSourceNode around the live input stream.
		        this._mediaStream = this.context.createMediaStreamSource(stream);
		        this._mediaStream.connect(this.output);
		    };
		    /**
			 *  called on error
			 *  @param   {Error} e 
			 *  @private
			 */
		    Tone.Microphone.prototype._onStreamError = function (e) {
		        console.error(e);
		    };
		    /**
			 *  Clean up.
			 *  @return {Tone.Microphone} this
			 */
		    Tone.Microphone.prototype.dispose = function () {
		        Tone.Source.prototype.dispose.call(this);
		        if (this._mediaStream) {
		            this._mediaStream.disconnect();
		            this._mediaStream = null;
		        }
		        this._stream = null;
		        this._constraints = null;
		        return this;
		    };
		    //polyfill
		    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
		    return Tone.Microphone;
		});

		//UMD
		if ( true ) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return Tone;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module === "object") {
			module.exports = Tone;
	 	} else {
			root.Tone = Tone;
		}
	} (this));

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(global) {(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	var manager = require('./lib/core/manager');
	var domUtils = require('./lib/utils/dom');
	var drawingUtils = require('./lib/utils/drawing');
	var mathUtils = require('./lib/utils/math');
	var extend = require('extend');

	/************************************************
	*  INSTANTIATE NX MANAGER AND CREATE ELEMENTS   *
	************************************************/

	window.nx = new manager();
	window.nx.onload = function() {};
	window.nx = extend(window.nx,domUtils)
	window.nx = extend(window.nx,drawingUtils)
	window.nx = extend(window.nx,mathUtils)

	/* this onload function turns canvases into nexus elements,
	 * using the canvas's id as its var name */

	window.onload = function() {

	  nx.addStylesheet();

	  // get all canvases on the page and add them to the manager
	  var allcanvi = document.getElementsByTagName("canvas");
	  for (i=0;i<allcanvi.length;i++) nx.transform(allcanvi[i]);

	  if (nx.isTouchDevice) {
	    document.addEventListener("touchmove", nx.blockMove, true);
	    document.addEventListener("touchstart", nx.blockMove, true);
	  }
	  
	  nx.onload();

	  nx.startPulse();
	  
	};
	},{"./lib/core/manager":2,"./lib/utils/dom":4,"./lib/utils/drawing":5,"./lib/utils/math":6,"extend":45}],2:[function(require,module,exports){

	/** 
	  @title NexusUI API
	  @overview NexusUI is a JavaScript toolkit for easily creating musical interfaces in web browsers. Interfaces are rendered on HTML5 canvases and are ideal for web audio projects, mobile apps, or for sending OSC to external audio applications like Max.
	  @author Ben Taylor, Jesse Allison, Yemin Oh, Sébastien Piquemal
	  @copyright &copy; 2011-2014
	  @license MIT
	 */ 
	 

	var timingUtils = require('../utils/timing');
	var EventEmitter = require('events').EventEmitter;
	var util = require('util');
	var transmit = require('../utils/transmit');


	var manager = module.exports = function() {

	/** 

	  @class nx
	  @description Central nexusUI manager with shared utility functions for all nexusUI objects
	  
	*/

	  EventEmitter.apply(this)
	  this.widgets = new Object();

	  /**  @property {integer} throttlePeriod Throttle time in ms (for nx.throttle). */
	  this.throttlePeriod = 20;
	  this.elemTypeArr = new Array();
	  this.aniItems = new Array();
	  /**  @property {boolean} showLabels Whether or not to draw an automatic text label on each interface component. */
	  this.showLabels = false;
	  this.starttime = new Date().getTime();
	  if (transmit) {
	    /**  
	    @method sendsTo 
	    @param {string or function} [destination] Protocol for transmitting data from interfaces (i.e. "js", "ajax", "ios", "max", or "node"). Also accepts custom functions.
	    ```js
	    nx.sendsTo("ajax")

	    // or

	    nx.sendsTo(function(data) {
	         //define a custom transmission function
	    })
	    ```
	    */
	    this.sendsTo = transmit.setGlobalTransmit;
	    /**  
	    @method setAjaxPath 
	    @param {string} [path] If sending via AJAX, define the path to ajax destination
	    */
	    this.setAjaxPath = transmit.setAjaxPath;
	    /**  @property {string} destination NexusUI's transmission protocol (i.e. "js" or "ajax"). Defaults to "js". We recommend setting this property using nx.sendsTo() which ensures that all widgets receive this setting. */
	    this.destination = "js";
	    /**  @property {string} ajaxPath If sending via AJAX, the destination path. Defaults to "lib/nexusOSCRelay.php". We recommend setting this property using nx.setAjaxPath() which ensures that all widgets receive this setting. */
	    this.ajaxPath = "lib/nexusOSCRelay.php";
	  }

	  /** @property {boolean} isTouchDevice Returns true if page is loaded on a touch device. */
	  this.isTouchDevice = ('ontouchstart' in document.documentElement)? true:false;
	  this.metas = document.getElementsByTagName('meta');

	  /**  @property {boolean} globalWidgets Whether or not to instantiate a global variable for each widget (i.e. button1). Defaults to true. Designers of other softwares who wish to keep nexusUI entirely encapsulated in the nx object may set this property to false. In that case, all widgets are accessible in nx.widgets */
	  this.globalWidgets = true;

	  this.font = "gill sans";
	  this.fontSize = 14;
	  this.fontWeight = "bold";
	}

	util.inherits(manager, EventEmitter)


	/** 
	  @method add 
	  Adds a NexusUI element to the webpage. This will create an HTML5 canvas and draw the interface on it.
	  @param {string} [type] NexusUI widget type (i.e. "dial").
	  @param {object} [settings] (Optional.) Extra settings for the new widget. This settings object may have any of the following properties: x (integer in px), y, w (width), h (height), name (widget's OSC name and canvas ID), parent (the ID of the element you wish to add the canvas into). If no settings are provided, the element will be at default size and appended to the body of the HTML document.
	  */
	manager.prototype.add = function(type, args) {
	  //args may have optional properties: x, y, w, h, name, parent

	  if(type) {
	      var canv = document.createElement("canvas");
	      canv.setAttribute('nx', type);
	      if (args) {
	        if (args.x || args.y) {
	           canv.style.position = "absolute";
	        }
	        if (args.x) {
	           canv.style.left = args.x + "px";
	        }
	        if (args.y) {
	           canv.style.top = args.y + "px";
	        }
	        if (args.w) {
	           canv.style.width = args.w;
	           canv.width = args.w;
	        }
	        if (args.h) {
	           canv.style.height = args.h;
	           canv.height = args.h;
	        }
	        if (args.parent) {
	          var parent;
	          if (typeof args.parent === "string") {
	            parent = document.getElementById(args.parent);
	          } else if (args.parent instanceof HTMLElement){
	            parent = args.parent;
	          } else if (args.parent instanceof jQuery){
	            parent = args.parent[0];            
	          }
	        }
	        if (args.name) {
	           canv.id = args.name
	        }
	      }
	      if (!parent) {
	        var parent = document.body
	      }
	      parent.appendChild(canv);
	      return this.transform(canv);
	  }
	}

	/** @method transform 
	Transform an existing canvas into a NexusUI widget.
	@param {string} [canvasID] The ID of the canvas to be transformed.
	@param {string} [type] (Optional.) Specify which type of widget the canvas will become. If no type is given, the canvas must have an nx attribute with a valid widget type.
	*/
	manager.prototype.transform = function(canvas, type) {
	  for (var key in nx.widgets) {
	    if (nx.widgets[key].canvasID == canvas.id) {
	      return;
	    }
	  }
	  if (type) {
	    var nxType = type;
	  } else {
	    var nxType = canvas.getAttribute("nx");
	  }

	  if (!nxType) {
	    return;
	  }
	  var elemCount = 0;
	  var newObj;

	  /* find out how many of the same elem type have come before
	    i.e. nx.elemTypeArr will look like [ dial, dial, toggle, toggle ]
	    allowing you to count how many dials already exist on the page
	    and give your new dial the appropriate index and id: dial3 */

	  for (j=0;j<this.elemTypeArr.length;j++) {
	    if (this.elemTypeArr[j] === nxType) {
	      elemCount++;
	    }
	  }

	  // add your new nexus element type to the element list
	  this.elemTypeArr.push(nxType);

	  // check to see if it has a pre-given ID
	  // and use that as its id if so
	  if (!canvas.id) {
	    var idNum = elemCount + 1;
	    canvas.id = nxType + idNum;
	  }

	  if(nxType) {
	    try {
	      var newObj = new (require('../widgets')[nxType])(canvas.id);
	    } catch (err) {
	      console.log(nxType);
	    }
	  }

	  this.widgets[newObj.canvasID] = newObj;
	  if (this.globalWidgets) {
	    window[newObj.canvasID] = this.widgets[newObj.canvasID]
	  }

	  newObj.init();
	  return newObj;
	}

	/** @method transmit 
	The "output" instructions for sending a widget's data to another application or to a JS callback. Inherited by each widget and executed when each widget is interacted with or its value changes. Set using nx.sendsTo() to ensure that all widgets inherit the new function correctly.
	@param {object} [data] The data to be transmitted. Each property of the object will become its own OSC message. (This works with objects nested to up to 2 levels).
	*/

	manager.prototype.transmit = function(data) {
	    this.makeOSC(this.emit, data);
	    this.emit('*',data);
	} 

	/** 
	  @method colorize
	  @param {string} [aspect] Which part of ui to change, i.e. "accent" "fill", "border"
	  @param {string} [color] Hex or rgb color code
	  Change the color of all nexus objects, by aspect ([fill, accent, border, accentborder]
	  
	  ```js
	  nx.colorize("#00ff00") // changes the accent color by default
	  nx.colorize("border", "#000000") // changes the border color
	  ```

	**/
	manager.prototype.colorize = function(aspect, newCol) {
	  
	  if (!newCol) {
	    // just sending in a color value colorizes the accent
	    newCol = aspect;
	    aspect = "accent";
	  }
	  
	  this.colors[aspect] = newCol;
	  
	  for (var key in this.widgets) {
	    this.widgets[key].colors[aspect] = newCol;
	    this.widgets[key].draw();
	  }
	}
	  

	/** @method setThrottlePeriod 
	Set throttle time of nx.throttle, which controls rapid network transmissions of widget data.
	@param {integer} [throttle time] Throttle time in milliseconds. 
	*/
	manager.prototype.setThrottlePeriod = function(newThrottle) {
	  this.throttlePeriod = newThrottle;
	  for (var key in this.widgets) {
	    this.widgets[key].throttlePeriod = this.throttlePeriod;
	  }
	}



	  /*  
	   *    GUI
	   */

	/**  @property {object} colors The interface's color settings. Set with nx.colorize(). */
	manager.prototype.colors = { 
	  "accent": "#ff5500", 
	  "fill": "#eee", 
	  "border": "#bbb",
	  "black": "#000",
	  "white": "#FFF"
	};
	  
	/**  @method startPulse 
	  Start an animation interval for animated widgets (calls nx.pulse() every 30 ms). Executed by default when NexusUI loads.
	*/
	manager.prototype.startPulse = function() {
	  this.pulseInt = setInterval("nx.pulse()", 30);
	}

	/**  @method stopPulse 
	  Stop the animation pulse interval.
	*/
	manager.prototype.stopPulse = function() {
	  clearInterval(this.pulseInt);
	}

	/**  @method pulse 
	  Animation pulse which executes all functions stored in the nx.aniItems array.
	*/
	manager.prototype.pulse = function() {
	  for (var i=0;i<this.aniItems.length;i++) {
	    this.aniItems[i]();
	  }
	} 

	manager.prototype.addAni = function(fn) {

	}

	manager.prototype.removeAni = function(fn) {
	  this.aniItems.splice(this.aniItems.indexOf(fn));
	}
	  
	manager.prototype.addStylesheet = function() {
	  var htmlstr = '<style>'
	    + 'select {'
	    + 'width: 150px;'
	    + 'padding: 5px 5px;'
	    + 'font-size: 16px;'
	    + 'color:#666666;'
	    + 'border: solid 0px #CCC;'
	    + 'border-radius: 5;'
	    + 'outline: black;'
	    + 'cursor:pointer;'
	    + 'background-color:#EEE;'
	    + 'font-family:gill sans;'
	    + '}'
	    + ''
	    + 'canvas { '
	    + 'cursor:pointer;'
	    + 'border-radius:5px;'
	    + 'moz-border-radius:5px;'
	    + 'webkit-border-radius:5px;'
	    + 'box-sizing:border-box;'
	    + '-moz-box-sizing:border-box;'
	    + '-webkit-box-sizing:border-box;'
	    + '}'
	    + '</style>';

	  document.head.innerHTML = document.head.innerHTML + htmlstr
	}

	/**  @method setViewport
	    Set mobile viewport scale (similar to a zoom)
	    @param {integer} [scale] Zoom ratio (i.e. 0.5, 1, 2) */
	manager.prototype.setViewport = function(scale) {
	  for (i=0; i<this.metas.length; i++) {
	    if (this.metas[i].name == "viewport") {
	      this.metas[i].content = "minimum-scale="+scale+", maximum-scale="+scale;
	    }
	  }
	}

	/**  @method setLabels
	    Tell all widgets whether or not draw text labels on widgets
	    @param {boolean} [on/off] true to add labels, false to remove labels
	 */
	manager.prototype.setLabels = function(onoff) {
	  if (onoff=="on") {
	    this.showLabels = true;
	  } else {
	    this.showLabels = false;
	  }
	  for (var key in this.widgets) {
	    this.widgets[key].draw()
	  }
	}

	manager.prototype.setProp = function(prop,val) {
	  if (prop && val) {
	    nx[prop] = val;
	    for (var key in this.widgets) {
	      this.widgets[key][prop] = val;
	      this.widgets[key].draw()
	    } 
	  }
	}

	manager.prototype.blockMove = function(e) {
	  if (e.target.tagName == 'CANVAS') {
	     e.preventDefault();
	     e.stopPropogation();
	  }
	}
	},{"../utils/timing":7,"../utils/transmit":8,"../widgets":17,"events":40,"util":44}],3:[function(require,module,exports){
	var EventEmitter = require('events').EventEmitter;
	var util = require('util');
	var domUtils = require('../utils/dom');
	var drawingUtils = require('../utils/drawing');
	var timingUtils = require('../utils/timing');
	var transmit = require('../utils/transmit');



	var widget = module.exports = function (target) {
	  EventEmitter.apply(this)
	  this.preClick = this.preClick.bind(this)
	  this.preMove = this.preMove.bind(this)
	  this.preRelease = this.preRelease.bind(this)
	  this.preTouch = this.preTouch.bind(this)
	  this.preTouchMove = this.preTouchMove.bind(this)
	  this.preTouchRelease = this.preTouchRelease.bind(this)

	/** 

	  @class widget
	  All NexusUI interface widgets inherit from the widget class. The properties and methods of the widget class are usable by any NexusUI interface.
	  
	*/

	  /**  @property {string} canvasID ID attribute of the interface's HTML5 canvas */
	  this.canvasID = target;
	  /**  @property {string} oscPath OSC prefix for this interface. By default this is populated using the canvas ID (i.e. an ID of dial1 has OSC path /dial1) */
	  this.oscPath = "/"+target;
	  if (!document.getElementById(target)) {
	    var newcanv = document.createElement("canvas")
	    newcanv.id = target;
	    document.body.appendChild(newcanv)
	  }
	  /**  @property {DOM element} canvas The widget's HTML5 canvas */
	  this.canvas = document.getElementById(target);
	  /**  @property {HTML5 drawing context} context The canvas's drawing context */
	  this.context = this.canvas.getContext("2d");

	  this.checkPercentage();

	  this.canvas.height = window.getComputedStyle(document.getElementById(target), null).getPropertyValue("height").replace("px","");
	  this.canvas.width = window.getComputedStyle(document.getElementById(target), null).getPropertyValue("width").replace("px","");
	  /**  @property {integer} height The widget canvas's computed height in pixels */
	  this.height = parseInt(window.getComputedStyle(document.getElementById(target), null).getPropertyValue("height").replace("px",""));
	  /**  @property {integer} width The widget canvas's computed width in pixels */
	  this.width = parseInt(window.getComputedStyle(document.getElementById(target), null).getPropertyValue("width").replace("px",""));
	  if (!this.defaultSize) {
	    /**  @property {object} defaultSize The widget's default size if not defined with HTML/CSS style. (Has properties 'width' and 'height', both in pixels) */
	    this.defaultSize = { width: 100, height: 100 };
	  }
	  if (this.width==300 && this.height==150) {
	    this.canvas.width = this.defaultSize.width*2;
	    this.canvas.height = this.defaultSize.height*2;
	    this.width = this.defaultSize.width;
	    this.height = this.defaultSize.height;
	  } else {
	  	var proxyw = this.width;
	  	var proxyh = this.height;
	  	this.canvas.width = proxyw*2;
	    this.canvas.height = proxyh*2;
	    this.width = proxyw;
	    this.height = proxyh;
	  }
	  this.canvas.style.width = this.canvas.width/2+"px";
	  this.canvas.style.height = this.canvas.height/2+"px";
	  this.context.scale(2,2)
	  /**  @property {object} offset The widget's computed offset from the top left of the document. (Has properties 'top' and 'left', both in pixels) */
	  this.offset = domUtils.findPosition(this.canvas);
	  /**  @property {object} center The center of the widget's canvas. A 100x100 widget would have a center at 50x50. (Has properties 'x' and 'y', both in pixels) */
	  this.center = {
	    x: this.width/2, 
	    y: this.height/2
	  };
	  //drawing
	  /**  @property {integer} lineWidth The default line width for drawing (default is 2 pixels). In many widgets, this is overwritten to suite the widget. However it does dictate the border width on most widgets. */
	  this.lineWidth = 2;
	  this.context.lineWidth = this.lineWidth;
	  /**  @property {object} colors A widget's individual color scheme. Inherited from nx.colors. (Has properties "accent", "fill", "border", "black", and "white") */
	  this.colors = new Object();
	  // define colors individually so they are not pointers to nx.colors
	  // this way each object can have its own color scheme
	  this.colors.accent = nx.colors.accent;
	  this.colors.fill = nx.colors.fill;
	  this.colors.border = nx.colors.border;
	  this.colors.accentborder = nx.colors.accentborder;
	  this.colors.black = nx.colors.black;
	  this.colors.white = nx.colors.white; 
	  this.colors.highlight = nx.colors.highlight;
	  //interaction
	  /**  @property {object} clickPos The most recent mouse/touch position when interating with a widget. (Has properties x and y) */
	  this.clickPos = {x: 0, y: 0};
	  /**  @property {array} clickPos.touches If multitouch, an array of touch positions  */
	  this.clickPos.touches = new Array();
	  /**  @property {boolean} clicked Whether or not the widget is currently clicked  */
	  this.clicked = false;
	  this.value = 0;
	    /**
	      @property {object} val An object containing the core interactive values of the widget, which are also the widget's data output. 
	    */
	  this.val = new Object();
	  this.pval = new Object();
	  this.nodePos = new Array();
	  /**  @property {object} deltaMove Difference between the current touch/mouse position and the previous touch/mouse position, in pixels.   */
	  this.deltaMove = new Object();
	  this.throttlePeriod = nx.throttlePeriod;
	  this.throttle = timingUtils.throttle;
	  /**  @property {boolean} label Whether or not to draw a text label this widget.   */
	  this.label = false;
	  this.hasMoved = false;
	  //recording
	  /**  @property {boolean} isRecording Whether or not this widget's output is being recorded to a "remix" widget */
	  this.isRecording = false;
	  this.tapeNum = 0;
	  this.recorder = null;
	  //transmission
	  if (transmit) {
	    /**  @method sendsTo
	    Set the transmission protocol for this widget individually 
	    @param {string or function} [destination] Protocol for transmitting data from this widget (i.e. "js", "ajax", "ios", "max", or "node"). Also accepts custom functions.
	    ```js
	    dial1.sendsTo("ajax")

	    // or

	    dial1.sendsTo(function(data) {
	         //define a custom transmission function
	    })
	    ```  
	    */
	    this.sendsTo = transmit.setWidgetTransmit;
	    this.destination = "js";
	  }
	  this.events = new Object();

	  // Setup interaction
	  if (nx.isTouchDevice) {
	    this.canvas.ontouchstart = this.preTouch;
	    this.canvas.ontouchmove = this.preTouchMove;
	    this.canvas.ontouchend = this.preTouchRelease;
	  } else {
	    this.canvas.addEventListener('mousedown', this.preClick, false);
	  }

	  this.fontSize = nx.fontSize;
	  this.fontWeight = nx.fontWeight;
	  this.font = nx.font;

	}
	util.inherits(widget, EventEmitter)

	/**  @method transmit
	    The "output" instructions for sending the widget's data to another application or to a JS callback. Inherited from nx.transmit and executed when each widget is interacted with or during animation. Set using .sendsTo() to use our built-in transmission defintions.
	    @param {object} [data] The data to be transmitted. Each property of the object will become its own OSC message if sending via "ajax" or "max7" protocols. (This works with objects nested to up to 2 levels).
	*/
	widget.prototype.transmit = nx.transmit;

	/**  @method makeOSC
	    Loops through an object (i.e. a widget's data), creates OSC path/value pairs, and executes a callback function with these two arguments.
	    @param {function} [callback] A function defining the action to be taken with each OSC path/value pair. This function should have two parameters, path (string) and data (type depends on widget data type).
	    @param {object} [data] The data as an object, to be broken into individual OSC messages.
	*/
	widget.prototype.makeOSC = function(action, data) {
	    this.action = action;
	    if ((typeof data == "object") && (data !== null)) {
	      for (var key in data) {
	        if ((typeof data[key] == "object") && (data[key] !== null)) {
	          for (var key2 in data[key]) {
	              this.action(key+"/"+key2, data[key][key2])
	          }
	        } else {
	            this.action(key, data[key])
	        }
	      }
	    } else if (typeof data == "number" || typeof data == "string") {
	        this.action('value', data)
	    }
	}

	// getoffset is useful as an API for others
	// otherwise they would have to write
	// dial1.offset = utils.findPosition()
	// now it is simply:
	// dial1.getOffset()

	/**  @method getOffset
	    Recalculate the computed offset of the widget's canvas and store it in widget.offset. This is useful if a widget has been moved after being created.
	    */
	widget.prototype.getOffset = function() {
	  this.offset = domUtils.findPosition(this.canvas)
	}

	widget.prototype.preClick = function(e) {
	  this.offset = domUtils.findPosition(this.canvas)
	  document.addEventListener("mousemove", this.preMove, false);
	  document.addEventListener("mouseup", this.preRelease, false);
	  this.clickPos = domUtils.getCursorPosition(e, this.offset);
	  this.clicked = true;
	  this.deltaMove.x = 0;
	  this.deltaMove.y = 0;
	  this.hasMoved = false;
	  this.click(e);
	  document.body.style.userSelect = "none";
	  document.body.style.mozUserSelect = "none";
	  document.body.style.webkitUserSelect = "none";
	}

	widget.prototype.preMove = function(e) {
	  var newClickPos = domUtils.getCursorPosition(e, this.offset);
	  this.deltaMove.y = newClickPos.y - this.clickPos.y;
	  this.deltaMove.x = newClickPos.x - this.clickPos.x;
	  this.clickPos = newClickPos;
	  this.hasMoved = true;
	  this.move(e);
	}

	widget.prototype.preRelease = function(e) {

	  document.removeEventListener("mousemove", this.preMove, false);
	  document.removeEventListener("mouseup", this.preRelease, false);
	  this.clicked = false;
	  this.release();
	  document.body.style.userSelect = "text";
	  document.body.style.mozUserSelect = "text";
	  document.body.style.webkitUserSelect = "text";
	}

	widget.prototype.preTouch = function(e) {
	  this.clickPos = domUtils.getTouchPosition(e, this.offset);
	  this.clicked = true;
	  this.deltaMove.x = 0;
	  this.deltaMove.y = 0;
	  this.touch(e);
	}

	widget.prototype.preTouchMove = function(e) {
	  if (this.clicked) {
	    var newClickPos = domUtils.getTouchPosition(e, this.offset);
	    this.deltaMove.y = newClickPos.y - this.clickPos.y;
	    this.deltaMove.x = newClickPos.x - this.clickPos.x;
	    this.clickPos = newClickPos;
	    this.touchMove(e);
	  }
	}

	widget.prototype.preTouchRelease = function(e) {
	  if (e.targetTouches.length>=1) {
	    var newClickPos = domUtils.getTouchPosition(e, this.offset);
	    this.clickPos = newClickPos;
	  } else {
	    this.clicked = false;
	  }
	  this.touchRelease();
	}


	/**  @method init
	     Initialize or re-initialize the widget. Defined separately within each widget.
	    */

	/**  @method draw
	    Draw the widget onto the canvas.
	    */
	widget.prototype.draw = function() {
	}


	/**  @method click
	    Executes when the widget is clicked on
	    */
	widget.prototype.click = function() {
	}


	/**  @method move
	    Executes on drag (mouse moves while clicked).
	    */
	widget.prototype.move = function() {
	}


	/**  @method release
	    Executes when the mouse releases after having clicked on the widget.
	    */
	widget.prototype.release = function() {
	}

	/**  @method touch
	    Executes when the widget is touched on a touch device.
	    */
	widget.prototype.touch = function() {
	  this.click();
	}

	/**  @method touchMove
	    Executes on drag (touch then move) on a touch device
	    */
	widget.prototype.touchMove = function() {
	  this.move();
	}

	/**  @method touchRelease
	    Executes when the touch releases after having touched the widget.
	    */
	widget.prototype.touchRelease = function() {
	  this.release();
	}

	widget.prototype.adjustSizeIfDefault = function() {
	  if (this.width==300 && this.height==150) {
	    this.canvas.width = this.defaultSize.width;
	    this.canvas.height = this.defaultSize.height;
	    this.width = this.defaultSize.width;
	    this.height = this.defaultSize.height;
	  }
	}

	widget.prototype.makeRoundedBG = function() {
	  this.bgLeft = this.lineWidth;
	  this.bgRight = this.width - this.lineWidth;
	  this.bgTop = this.lineWidth;
	  this.bgBottom = this.height - this.lineWidth;
	  this.bgHeight = this.bgBottom - this.lineWidth;
	  this.bgWidth = this.bgRight - this.lineWidth; 
	  
	  drawingUtils.makeRoundRect(this.context, this.bgLeft, this.bgTop, this.bgWidth, this.bgHeight);
	}

	/**  @method erase
	    Erase the widget's canvas.
	    */
	widget.prototype.erase = function() {
	  this.context.clearRect(0,0,this.width,this.height);
	}

	widget.prototype.hideCursor = function() {
	  this.canvas.style.cursor = "none";
	}

	widget.prototype.showCursor = function() {
	  this.canvas.style.cursor = "auto";
	}

	// allow us to get the constructor function name programatically
	//i.e. if element is a dial, this function will return "dial"

	/**  @method getName
	    Returns the widget's constructor function name (i.e. "dial")
	    */
	widget.prototype.getName = function() { 
	  var funcNameRegex = /function (.{1,})\(/;
	  var results = (funcNameRegex).exec((this).constructor.toString());
	  return (results && results.length > 1) ? results[1] : "";
	}

	/** @method set
	Manually set a widget's value (that is, set any properties of a widget's .val). See widget.val or the .val property of individual widgets for more info. 
	@param {object} [data] Parameter/value pairs in object notation.
	@param {boolean} [transmit] (optional) Whether or not to transmit new value after being set.
	Sets the value of an object. 

	```js
	  position1.set({
	  &nbsp;  x: 100,
	  &nbsp;  y: 250
	  })
	```

	An optional second argument decides whether the object then transmits its new value.
	```js
	  button1.set({
	  &nbsp;  press: 100
	  }, true)
	```
	*/
	widget.prototype.set = function(data, transmit) {

	  if (typeof this.val == "object" && this.val !== "null") {
	    if (typeof data == "object" && data !== "null") {
	      for (var key in data) {
	        this.val[key] = data[key];
	      }
	    }
	  } else if (typeof this.val == "string" || typeof this.val == "number") {
	    if (typeof data == "object" && data !== "null") {
	      this.val = data["value"];
	      this.draw();
	    } else if (typeof data == "string" || typeof data == "number") {
	      this.val = data;
	    }
	  }
	  this.draw();

	  if (transmit) {
	    this.transmit(this.val)
	  }
	}

	/**  @method destroy
	    Remove the widget object, canvas, and all related event listeners from the document.
	    */
	widget.prototype.destroy = function() {
	  var type = nx.elemTypeArr.indexOf(this.getName())
	  nx.elemTypeArr.splice(type,1)

	  this.canvas.ontouchmove = null;
	  this.canvas.ontouchend = null;
	  this.canvas.onclick = null;
	  this.canvas.onmousemove = null;
	  this.canvas.onmouseoff = null;
	  document.removeEventListener("mousemove", this.preMove, false);
	  document.removeEventListener("mouseup", this.preRelease, false);

	  var elemToKill = document.getElementById(this.canvasID)
	  if (elemToKill) {
	    elemToKill.parentNode.removeChild(elemToKill);
	  }

	  this.customDestroy();

	  var id = this.canvasID
	  delete nx.widgets[id];
	  delete window[id];

	}

	widget.prototype.customDestroy = function() {

	}

	widget.prototype.wrapText = function(text, x, y, maxWidth, lineHeight) {
	  if (text) {
	    var words = text.split(' ');
	    var line = '';

	    for(var n = 0; n < words.length; n++) {
	      var testLine = line + words[n] + ' ';
	      var metrics = this.context.measureText(testLine);
	      var testWidth = metrics.width;
	      if (testWidth > maxWidth && n > 0) {
	        this.context.fillText(line, x, y);
	        line = words[n] + ' ';
	        y += lineHeight;
	      }
	      else {
	        line = testLine;
	      }
	    }
	    this.context.fillText(line, x, y);
	  }
	}

	widget.prototype.drawLabel = function() {
	  if (this.showLabels) {
	    with(this.context) {
	      globalAlpha = 0.9;
	      fillStyle = this.colors.fill;
	      fillRect(this.width-100,this.height-20,100,20);
	      globalAlpha = 1;
	      beginPath();
	      fillStyle = this.colors.border;
	      font = "bold 15px courier";
	      textAlign = "center";
	      fillText(this.oscPath,this.width-50,this.height-5);
	      textAlign = "left";
	      closePath();
	    }
	  }
	}

	/**  @method saveCanv
	     Download the widget's current graphical state as an image (png).
	    */
	widget.prototype.saveCanv = function() {
	  var data = this.canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
	  window.location.href = data
	}

	widget.prototype.setFont = function() {
	  with (this.context) {
	        textAlign = "center";
	        textBaseline = "middle";
	        font = this.fontWeight+" "+this.fontSize+"px "+this.font;
	        fillStyle = this.colors.black;
	        globalAlpha = 0.7;
	  }
	}


	/* Percentage width support */


	widget.prototype.checkPercentage = function() {
	  var wstr = this.canvas.style.width;
	  var hstr = this.canvas.style.height;
	  if (wstr.indexOf("%") >= 0 || hstr.indexOf("%") >= 0) {
	    this.percent = {
	      w: (wstr.indexOf("%") >= 0) ? wstr.replace("%","") : false,
	      h: (hstr.indexOf("%") >= 0) ? hstr.replace("%","") : false
	    }
	    this.stretch();
	  }
	}

	widget.prototype.stretch = function() {
	  window.addEventListener("resize", function(e) {
	    if (this.percent.w) {
	      var newWidth = window.getComputedStyle(this.canvas.parentNode, null).getPropertyValue("width").replace("px","");
	      newWidth *= this.percent.w/100
	    } else {
	      var newWidth = false;
	    }
	    if (this.percent.h) {
	      var newHeight = window.getComputedStyle(this.canvas.parentNode, null).getPropertyValue("height").replace("px","");
	      newHeight *= this.percent.h/100 
	    } else {
	      var newHeight = false;
	    }
	    this.resize(newWidth,newHeight);
	  }.bind(this))
	}

	widget.prototype.resize = function(w,h) {

	  this.canvas.width = w ? w*2 : this.canvas.width;
	  this.canvas.height = h ? h*2 : this.canvas.height;
	  this.width =  w ? w : this.width;
	  this.height = h ? h : this.height;
	  this.canvas.style.width = this.width+"px";
	  this.canvas.style.height = this.height+"px";
	  this.context.scale(2,2)

	  this.center = {
	    x: this.width/2,
	    y: this.height/2
	  };

	  this.init();
	  this.draw();
	  
	}
	},{"../utils/dom":4,"../utils/drawing":5,"../utils/timing":7,"../utils/transmit":8,"events":40,"util":44}],4:[function(require,module,exports){

	/** @class utils 
	  Shared utility functions. These functions are exposed as methods of nx in NexusUI projects, i.e. .mtof() here can be accessed in your project with nx.mtof().
	*/


	/** @method findPosition 
	    Returns the offset of an HTML element. Returns an object with 'top' and 'left' properties.
	    @param {DOM element} [element] 
	    ```js
	    var button1Offset = nx.findPosition(button1.canvas)
	    ```
	*/
	exports.findPosition = function(element) {
	  var body = document.body,
	      win = document.defaultView,
	      docElem = document.documentElement,
	      box = document.createElement('div');
	  box.style.paddingLeft = box.style.width = "1px";
	  body.appendChild(box);
	  var isBoxModel = box.offsetWidth == 2;
	  body.removeChild(box);
	  box = element.getBoundingClientRect();
	  var clientTop  = docElem.clientTop  || body.clientTop  || 0,
	      clientLeft = docElem.clientLeft || body.clientLeft || 0,
	      scrollTop  = win.pageYOffset || isBoxModel && docElem.scrollTop  || body.scrollTop,
	      scrollLeft = win.pageXOffset || isBoxModel && docElem.scrollLeft || body.scrollLeft;
	  return {
	    top : box.top  + scrollTop  - clientTop,
	    left: box.left + scrollLeft - clientLeft
	  };
	}

	exports.getCursorPosition = function(e, canvas_offset) {
	  var x;
	  var y;
	  if (e.pageX != undefined && e.pageY != undefined) {
	    x = e.pageX;
	    y = e.pageY;
	  } else {
	    x = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
	    y = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
	  }
	  x -= canvas_offset.left;
	    y -= canvas_offset.top;
	  var click_position = {x: x, y: y};
	  click_position.touches = [ {x: x, y: y } ];
	  return click_position;
	}

	exports.getTouchPosition = function(e, canvas_offset) {
	  var x;
	  var y;
	  x = e.targetTouches[0].pageX;
	  y = e.targetTouches[0].pageY;
	  x -= canvas_offset.left;
	    y -= canvas_offset.top;
	  var click_position = {x: x, y: y};

	  click_position.touches = new Array();
	  for (var i=0;i<e.targetTouches.length;i++) {
	     click_position.touches.push({
	      x: e.targetTouches[i].pageX - canvas_offset.left,
	      y: e.targetTouches[i].pageY - canvas_offset.top
	    });
	  }
	  click_position.changed = new Array();
	  for (var i=0;i<e.changedTouches.length;i++) {
	     click_position.changed.push({
	      x: e.changedTouches[i].pageX - canvas_offset.left,
	      y: e.changedTouches[i].pageY - canvas_offset.top
	    });
	  }
	  return click_position;
	}
	},{}],5:[function(require,module,exports){
	var math = require('./math')

	/** @method randomColor
	    Returns a random color string in rgb format
	*/
	exports.randomColor = function() {
	  return "rgb(" + math.random(250) + "," + math.random(250) + "," + math.random(250) + ")";
	}

	/** @method hexToRgb
	    Converts a hex color code to rgb format
	    @param {color code} [hex] Input color code in hex format
	    @param {float} [alpha] Color alpha level
	*/
	exports.hexToRgb = function(hex, a) {
	  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
	  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
	  hex = hex.replace(shorthandRegex, function(m, r, g, b) {
	      return r + r + g + g + b + b;
	  });

	  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	  if (!a) {
	    a = 0.5;
	  }
	  
	  var r = parseInt(result[1], 16);
	  var g = parseInt(result[2], 16);
	  var b = parseInt(result[3], 16);

	  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
	}

	exports.isInside = function(clickedNode,currObject) {
	  if (clickedNode.x > currObject.x && clickedNode.x < (currObject.x+currObject.w) && clickedNode.y > currObject.y && clickedNode.y < (currObject.y+currObject.h)) {
	    return true;
	  } else {
	    return false; 
	  }
	}

	exports.makeRoundRect = function(ctx,xpos,ypos,wid,hgt,depth) {
	  var x1 = xpos;
	  var y1 = ypos;
	  var x2 = wid+x1;
	  var y2 = hgt+y1;
	  if (!depth) {
	    depth = 2;
	  }
	  
	  ctx.beginPath();
	  ctx.moveTo(x1+depth, y1); //TOP LEFT
	  ctx.lineTo(x2-depth, y1); //TOP RIGHT
	  ctx.quadraticCurveTo(x2, y1, x2, y1+depth);
	  ctx.lineTo(x2, y2-depth); //BOTTOM RIGHT
	  ctx.quadraticCurveTo(x2, y2, x2-depth, y2);
	  ctx.lineTo(x1+depth, y2); //BOTTOM LEFT
	  ctx.quadraticCurveTo(x1, y2, x1, y2-depth);
	  ctx.lineTo(x1, y1+depth); //TOP LEFT
	  ctx.quadraticCurveTo(x1, y1, x1+depth, y1);
	  ctx.closePath();
	}

	exports.text = function(context, text, position) {
	  if (!position) {
	    position = [10 , 10];
	  }
	  with(context) {
	    beginPath();
	    font = "bold 12px sans-serif";
	    fillText(text,position[0],position[1]);
	    closePath();
	  }
	}
	},{"./math":6}],6:[function(require,module,exports){


	/** @method toPolar 
	    Receives cartesian coordinates and returns polar coordinates as an object with 'radius' and 'angle' properties.
	    @param {float} [x] 
	    @param {float} [y] 
	    ```js
	    var ImOnACircle = nx.toPolar({ x: 20, y: 50 }})
	    ```
	*/
	exports.toPolar = function(x,y) {
	  var r = Math.sqrt(x*x + y*y);

	  var theta = Math.atan2(y,x);
	  if (theta < 0.) {
	    theta = theta + (2 * Math.PI);
	  }
	  return {radius: r, angle: theta};
	}

	/** @method toCartesian 
	    Receives polar coordinates and returns cartesian coordinates as an object with 'x' and 'y' properties.
	    @param {float} [radius] 
	    @param {float} [angle] 
	*/
	exports.toCartesian = function(radius, angle){
	  var cos = Math.cos(angle);
	  var sin = Math.sin(angle);
	  return {x: radius*cos, y: radius*sin*-1};
	}


	/** @method clip 
	    Limits a number to within low and high values.
	    @param {float} [input value] 
	    @param {float} [low limit] 
	    @param {float} [high limit] 
	    ```js
	    nx.clip(5,0,10) // returns 5
	    nx.clip(15,0,10) // returns 10
	    nx.clip(-1,0,10) // returns 0
	    ```
	*/
	exports.clip = function(value, low, high) {
	  return Math.min(high, Math.max(low, value));
	}

	/** @method prune 
	    Limits a float to within a certain number of decimal places
	    @param {float} [input value] 
	    @param {integer} [max decimal places] 
	    ```js
	    nx.prine(1.2345, 3) // returns 1.234
	    nx.prune(1.2345, 1) // returns 1.2
	    ```
	*/

	exports.prune = function(data, scale) {
	  if (typeof data === "number") {
	    data = parseFloat(data.toFixed(scale));
	  } else if (data instanceof Array) {
	    for (var i=0;i<data.length;i++) {
	      if (typeof data[i]=="number") {
	        data[i] = parseFloat(data[i].toFixed(scale));
	      }
	    }
	  }
	  return data;
	}


	/** @method scale 
	    Scales an input number to a new range of numbers
	    @param {float} [input value] 
	    @param {float} [low1]  input range (low)
	    @param {float} [high1] input range (high)
	    @param {float} [low2] output range (low)
	    @param {float} [high2] output range (high)
	    ```js
	    nx.scale(5,0,10,0,100) // returns 50
	    nx.scale(5,0,10,1,2) // returns 1.5
	    ```
	*/
	exports.scale = function(inNum, inMin, inMax, outMin, outMax) {
	  return (((inNum - inMin) * (outMax - outMin)) / (inMax - inMin)) + outMin;  
	}

	/** @method invert 
	    Equivalent to nx.scale(input,0,1,1,0). Inverts a normalized (0-1) number. 
	    @param {float} [input value]  
	    ```js
	    nx.invert(0.25) // returns 0.75
	    nx.invert(0) // returns 1
	    ```
	*/
	exports.invert = function (inNum) {
	  return exports.scale(inNum, 1, 0, 0, 1);
	}

	exports.bounce = function(posIn, borderMin, borderMax, delta) {
	  if (posIn > borderMin && posIn < borderMax) {
	    return delta;
	  } else if (posIn <= borderMin) {
	    return Math.abs(delta); 
	  } else if (posIn >= borderMax) {
	    return Math.abs(delta) * (-1);
	  }
	}


	/** @method mtof 
	    MIDI to frequency conversion. Returns frequency in Hz.
	    @param {float} [MIDI] MIDI value to convert
	    ```js
	    nx.mtof(69) // returns 440
	    ```
	*/
	exports.mtof = function(midi) {
	  return Math.pow(2, ((midi-69)/12)) * 440;
	}


	/** @method random 
	    Returns a random integer between 0 a given scale parameter.
	    @param {float} [scale] Upper limit of random range.
	    ```js
	    nx.random(10) // returns a random number from 0 to 9.
	    ```
	*/
	exports.random = function(scale) {
	  return Math.floor(Math.random() * scale);
	}


	exports.interp = function(loc,min,max) {
	  return loc * (max - min) + min;  
	}
	},{}],7:[function(require,module,exports){


	exports.throttle = function(func, wait) {
	  var timeout;
	  return function() {
	    var context = this, args = arguments;
	    if (!timeout) {
	      // the first time the event fires, we setup a timer, which 
	      // is used as a guard to block subsequent calls; once the 
	      // timer's handler fires, we reset it and create a new one
	      timeout = setTimeout(function() {
	        timeout = null;
	        try {
	          func.apply(context, args);
	        } catch (err) {
	          console.log(err);
	        }
	      }, wait);
	    }
	  }
	}
	},{}],8:[function(require,module,exports){
	exports.defineTransmit = function(protocol) {
	  
	  var newTransmit;

	  if (typeof(protocol)=="function") {
	    return protocol;
	  } else {
	    switch (protocol) {
	      case 'js':
	        newTransmit = function(data) {
	          this.makeOSC(this.emit, data);
	          this.emit('*',data);
	        }
	        return newTransmit
	      
	      case 'ajax':
	        newTransmit = function(data) {
	          this.makeOSC(exports.ajaxTransmit, data);
	        }
	        return newTransmit
	      
	      case 'node':
	        newTransmit = function(data) {
	          this.makeOSC(exports.nodeTransmit, data);
	        }
	        return newTransmit
	      
	      case 'ios':
	        newTransmit = function(data) {
	          
	        }
	        return newTransmit
	      
	      case 'max':
	        newTransmit = function(data) {
	          this.makeOSC(exports.maxTransmit, data);
	        }
	        return newTransmit
	    }
	  }
	}

	exports.setGlobalTransmit = function(protocol) {
	  var newTransmit = exports.defineTransmit(protocol)
	  this.transmit = newTransmit
	  this.destination = protocol
	  for (var key in nx.widgets) {
	    this.widgets[key].transmit = newTransmit;
	    this.widgets[key].destination = protocol;
	  }
	}

	exports.setWidgetTransmit = function(protocol) {
	  var newTransmit = exports.defineTransmit(protocol)
	  this.transmit = newTransmit
	  this.destination = protocol
	}


	exports.ajaxTransmit = function(subPath, data) {

	    var oscPath = subPath=='value' ? this.oscPath : this.oscPath+"/"+subPath;
	     
	    xmlhttp=new XMLHttpRequest();
	    xmlhttp.open("POST",nx.ajaxPath,true);
	    xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
	    xmlhttp.send('oscName='+oscPath+'&data='+data);

	}

	exports.setAjaxPath = function(path) {
	  this.ajaxPath = path;
	}

	exports.nodeTransmit = function(subPath, data) {
	   
	    var msg = {
	      oscName: subPath=='value' ? this.oscPath : this.oscPath+"/"+subPath,
	      value: data
	    }
	    socket.emit('nx', msg)

	}

	exports.maxTransmit = function (subPath, data) {
	    var oscPath = subPath=='value' ? this.oscPath : this.oscPath+"/"+subPath;
	    window.max.outlet(oscPath + " " + data);
	}
	},{}],9:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class banner      
		"Powered by NexusUI" tag with a link to our website. Use it if you want to share the positive vibes of NexusUI. Thanks for using!
		```html
		<canvas nx="banner"></canvas>
		```
		<canvas nx="banner" style="margin-left:25px"></canvas>
	*/

	var banner = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 40 };
		widget.call(this, target);
		
		//unique attributes
		/** @property {string} message1 The first line of text on the banner. */
		this.message1 = "Powered By";
		/** @property {string} message2 The second line of text on the banner. */
		this.message2 = "NexusUI";
		/** @property {string} link The URL the banner will link to. */
		this.link = "http://www.nexusosc.com";
		/** @property {boolean} isLink Whether or not the banner is a hyperlink. Defaults to true. */
		this.isLink = true;
	}
	util.inherits(banner, widget);

	banner.prototype.init = function() {
		this.draw();
	}

	banner.prototype.draw = function() {
		with (this.context) {

			globalAlpha = 0.1;
			fillStyle = this.colors.accent;
			beginPath();
				moveTo(0,10);
				lineTo(10,this.height/2+5);
				lineTo(0,this.height);
				lineTo(30,this.height);
				lineTo(30,10);
				fill();
				moveTo(this.width-30,10);
				lineTo(this.width-30,this.height);
				lineTo(this.width,this.height);
				lineTo(this.width-10,this.height/2+5);
				lineTo(this.width,10);
				fill();
			closePath();
			globalAlpha = 1;

			fillStyle = this.colors.accent;
			fillRect(15,0,this.width-30,this.height-10);
			
			fillStyle = this.colors.white;
			font = this.fontWeight + " " +this.height/5+"px "+this.font;
			textAlign = "center";
			fillText(this.message1, this.width/2, this.height/3.3);
			fillText(this.message2, this.width/2, (this.height/3.3)*2);

			fillStyle = this.colors.black;
			beginPath();
				moveTo(15,this.height-10);
				lineTo(30,this.height);
				lineTo(30,this.height-10);
				lineTo(15,this.height-10);
				fill();
				moveTo(this.width-15,this.height-10);
				lineTo(this.width-30,this.height);
				lineTo(this.width-30,this.height-10);
				lineTo(this.width-15,this.height-10);
				fill();
			closePath();
		
		}
	}

	banner.prototype.click = function() {
		if (this.isLink) {
			window.location = this.link;
		}
	}
	},{"../core/widget":3,"util":44}],10:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');
	var drawing = require('../utils/drawing');

	var button = module.exports = function(target) {

	/** 
		
		@public
		@class button 

		Touch button with three modes of interaction ("toggle", "impulse", and "aftertouch").
		```html
		<canvas nx="button"></canvas>
		```
		<canvas nx="button" style="margin-left:25px"></canvas>
	*/

		this.defaultSize = { width: 50, height: 50 };
		widget.call(this, target);

		/** 
			@property {object}  val  Main value set and output, with sub-properties:
			| &nbsp; | data
			| --- | ---
			| *press* | 0 (clicked) or 1 (unclicked)
			| *x* | 0-1 float of x-position of click ("aftertouch" mode only)
			| *y* | 0-1 float of y-position of click ("aftertouch" mode only) 
			
			When the widget is interacted with, val is sent as the output data for the widget.
			```js 
			button1.on('*', function(data) {
				// some code using data.press, data.x, and data.y
			});
			```
			Or, if NexusUI is outputting OSC (e.g. if nx.sendsTo("ajax")), val will be broken into OSC messages: 
			```html 
			/button1/press 1
			/button1/x 37
			/button1/y 126
			```
			*/
		this.val = {
			press: 0
		}
		
		/** @property {string}  mode  Interaction mode. Options:
		<b>impulse</b> &nbsp; 1 on click <br>
		<b>toggle</b> &nbsp;  1 on click, 0 on release _(default)_<br>
		<b>aftertouch</b> &nbsp; 1, x, y on click; x, y on move; 0, x, y on release <br> 
		```js 
		button1.mode = "aftertouch" 
		```
		*/
		this.mode = "toggle";

		this.lockResize = true;

		this.image = null;
		this.imageHover = null;
		this.imageTouch = null;

		this.subval = new Object();

		this.init();

	}
	util.inherits(button, widget);

	button.prototype.init = function() {
		this.width = this.canvas.width;
		this.height = this.canvas.height;
		this.radius = (Math.min(this.center.x, this.center.y)-this.lineWidth/2)
		this.draw();
	}

	button.prototype.draw = function() {
		this.erase();
		
		with (this.context) {
			
			if (this.image !== null) {
				// Image Button
				if (!this.val.press) {
					// Draw Image if not touched
					drawImage(this.image, 0, 0);
				} else {
					if (!this.imageTouch) {

						drawImage(this.image, 0, 0);

						// No touch image, apply highlighting
						globalAlpha = 0.5;
						fillStyle = this.colors.accent;
						fillRect (0, 0, this.width, this.height);
						globalAlpha = 1;
						
					} else {
						// Draw Touch Image
						drawImage(this.imageTouch, 0, 0);
					}
				}
				
			} else {
		
				// Regular Button
				if (!this.val.press) {
					fillStyle = this.colors.fill;
				} else if (this.val.press) {
					fillStyle = this.colors.accent;
				}
			
				beginPath();
					arc(this.center.x, this.center.y, this.radius, 0, Math.PI*2, true);
					fill();	  
				closePath();

				if (this.val.press && this.mode=="node") {
					globalAlpha = 0.2;
					fillStyle = this.colors.white;
					beginPath();
						arc(this.val.x, this.val.y, (Math.min(this.center.x, this.center.y)/2), 0, Math.PI*2, true);
						fill();	  
					closePath();

					globalAlpha = 1;
				}
			}

			this.drawLabel();
			
		}
	}

	button.prototype.click = function(e) {
		if (drawing.isInside(this.clickPos,{x: this.center.x-this.radius, y:this.center.y-this.radius, w:this.radius*2, h:this.radius*2})) {
			this.val["press"] = 1;
			if (this.mode=="node") {
				this.val["x"] = this.clickPos.x;
				this.val["y"] = this.clickPos.y;
			}
			this.transmit(this.val);
			this.draw();
		}
	}

	button.prototype.move = function () {
		// use to track movement on the button
		if (this.mode=="node") {
			this.val["x"] = this.clickPos.x;
			this.val["y"] = this.clickPos.y;
			this.subval["x"] = this.clickPos.x;
			this.subval["y"] = this.clickPos.y;
			this.transmit(this.subval);
			this.draw();
		}
	}

	button.prototype.release = function() {
		this.val["press"] = 0;
		if (this.mode=="toggle" || this.mode=="node") { 
			this.transmit(this.val);
		}
		this.draw();
	}


	/** @method setImage 
		Turns the button into an image button with custom image. Sets the default (unclicked) button image.
		@param {string} [src] Image source */
	button.prototype.setImage = function(image) {
		this.image = new Image();
	  var that = this;
		this.image.onload = function() { that.draw() }
		this.image.src = image;
	}

	button.prototype.setHoverImage = function(image) {
		this.imageHover = new Image();
		this.imageHover.onload = function() { this.draw() }
		this.imageHover.src = image;
	}

	/** @method setTouchImage 
		Sets the image that will show when the button is clicked.
		@param {string} [src] Image source */
	button.prototype.setTouchImage = function(image) {
		this.imageTouch = new Image();
		this.imageTouch.onload = this.draw();
		this.imageTouch.src = image;
	}
	},{"../core/widget":3,"../utils/drawing":5,"util":44}],11:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class colors      
		Color picker that outputs RBG values
		```html
		<canvas nx="colors"></canvas>
		```
		<canvas nx="colors" style="margin-left:25px"></canvas>
	*/
					
	var colors = module.exports = function (target) {
		
		this.defaultSize = { width: 100, height: 100 };	
		widget.call(this, target);

		/* new tactic */

		this.gradient1 = this.context.createLinearGradient(0,0,this.width,0)
	 	this.gradient1.addColorStop(0, '#F00'); 
	 	this.gradient1.addColorStop(0.17, '#FF0'); 
	 	this.gradient1.addColorStop(0.34, '#0F0'); 
	 	this.gradient1.addColorStop(0.51, '#0FF'); 
	 	this.gradient1.addColorStop(0.68, '#00F'); 
	 	this.gradient1.addColorStop(0.85, '#F0F'); 
	 	this.gradient1.addColorStop(1, '#F00'); 

		this.gradient2 = this.context.createLinearGradient(0,0,0,this.height)
	 	this.gradient2.addColorStop(0, 'rgba(0,0,0,255)'); 
	 	this.gradient2.addColorStop(0.49, 'rgba(0,0,0,0)'); 
	 	this.gradient2.addColorStop(0.51, 'rgba(255,255,255,0)'); 
	 	this.gradient2.addColorStop(0.95, 'rgba(255,255,255,255)'); 
		this.init();
		
	}
	util.inherits(colors, widget);

	colors.prototype.init = function() {

		this.draw();
	}

	colors.prototype.draw = function() {
		this.erase();

		with(this.context) {
			fillStyle = this.gradient1;
			fillRect(0,0,this.width,this.height)
			fillStyle = this.gradient2;
			fillRect(0,0,this.width,this.height)
		}

		this.drawLabel();
	}

	colors.prototype.drawColor = function() {
		with(this.context) {
			fillStyle = "rgb("+this.val.r+","+this.val.g+","+this.val.b+")"
			fillRect(0,this.height * 0.95,this.width,this.height* 0.05)

		}
	}

	colors.prototype.click = function(e) {
		if (this.clickPos.x > 0 && this.clickPos.y > 0 && this.clickPos.x < this.width && this.clickPos.y < this.height) {
			var imgData = this.context.getImageData(this.clickPos.x*2,this.clickPos.y*2,1,1);
		} else {
			return;
		}
		

		/** @property {object}  val  RGB color value at mouse position. <br> This is also the widget's data output (See <a href="#nexusui-api-widget-widgetval">widget.val</a>). <br> Properties:
		| &nbsp; | data
		| --- | ---
		| *r* | red value 0-256
		| *g* | green value 0-256
		| *b* | blue value 0-256 
		```js 
		colors1.on('*', function(data) {
			// some code using data.r, data.g, and data.b
		}
		```
		*/

		this.val = {
			r: imgData.data[0], 
			g: imgData.data[1], 
			b: imgData.data[2]
		}
		this.transmit(this.val);
		this.drawColor();
	}


	colors.prototype.move = function(e) {
		this.click(e);
	}
	},{"../core/widget":3,"util":44}],12:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class comment      
		Text comment
		```html
		<canvas nx="comment"></canvas>
		```
		<canvas nx="comment" style="margin-left:25px"></canvas>
	*/

	var comment = module.exports = function (target) {
		
		this.defaultSize = { width: 75, height: 25 };
		widget.call(this, target);

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *text* | text of comment area (as string)
			```js 
			comment1.val.text = "This is my comment"
			comment1.draw()
			```
		*/
		
		this.val = {
			text: "comment"
		}
		this.sizeSet = false;

		this.init();
	}
	util.inherits(comment, widget);

	/** @method setSize
		Set the font size of the comment text
		@param {integer} [size] Text size in pixels
	*/
	comment.prototype.setSize = function(size) {
		this.size = size;
		this.sizeSet = true;
		this.draw();
	}

	comment.prototype.init = function() {
		this.draw();
	}

	comment.prototype.draw = function() {
		if (!this.sizeSet) {
			this.size = Math.sqrt((this.width * this.height) / (this.val.text.length));
		}

		this.erase();
		with (this.context) {
			
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
			
			beginPath();
			moveTo(0,this.height);
			lineTo(this.width,this.height);
			closePath();
			
			fillStyle = this.colors.black;
			textAlign = "left";
			font = this.size+"px Gill Sans";
		}
		this.wrapText(this.val.text, 6, 3+this.size, this.width-6, this.size);
	}
	},{"../core/widget":3,"util":44}],13:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class crossfade      
		Crossfade for panning or mixing
		```html
		<canvas nx="crossfade"></canvas>
		```
		<canvas nx="crossfade" style="margin-left:25px"></canvas>
	*/

	var crossfade = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 30 };
		widget.call(this, target);

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *value* | Crossfade value (float -1 to 1)
		*/
		this.val.value = 0.7

		this.label = "";

		this.init();
	}
	util.inherits(crossfade, widget);

	crossfade.prototype.init = function() {

		if (this.canvas.getAttribute("label")!=null) {
			this.label = this.canvas.getAttribute("label");
		}

		this.draw();
	}

	crossfade.prototype.draw = function() {
		
		this.erase();
			
		with (this.context) {

			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);

			
			if (nx.showLabels) {
				this.setFont();
				fillText(this.label, this.width/2, this.height/2);
				globalAlpha = 1;
			
			}

			var x1 = this.width/2;
			var y1 = 0;
			var x2 = (this.val.value/2)*this.width;
			var y2 = this.height;
		   
		
			fillStyle = this.colors.accent;
			fillRect(x1,y1,x2,y2);

			fillRect(x1-1,y1,2,y2);

		}
	}

	crossfade.prototype.click = function() {
		this.move();
	}

	crossfade.prototype.move = function() {
		var x = nx.scale(this.clickPos.x/this.width,0,1,-1,1)
		this.val.value = math.prune(math.clip(x, -1, 1),3)
		this.draw();
		this.transmit(this.val);
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],14:[function(require,module,exports){
	var math = require('../utils/math');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class dial      
		Circular dial
		```html
		<canvas nx="dial"></canvas>
		```
		<canvas nx="dial" style="margin-left:25px"></canvas>
	*/

	var dial = module.exports = function(target) {
		
		this.defaultSize = { width: 50, height: 50 };
		widget.call(this, target);
		
		//define unique attributes
		this.circleSize;
		this.handleLength;

		/** @property {object}  val
		    | &nbsp; | data
			| --- | ---
			| *value* | Current value of dial as float 0-1
		*/
		this.val = {
			value: 0
		}
		/** @property {float}  responsivity    How much the dial increments on drag. Default: 0.004<br>
		*/
		this.responsivity = 0.004;
		
		this.aniStart = 0;
		this.aniStop = 1;
		this.aniMove = 0.01;

		this.lockResize = true;

		this.init();
		
	}

	util.inherits(dial, widget);

	dial.prototype.init = function() {

		this.circleSize = (Math.min(this.center.x, this.center.y));
		this.handleLength = this.circleSize;
		this.mindim = Math.min(this.width,this.height)
		
		if (this.mindim<101) {
			this.handleLength--;
		//	this.handleLength--;
		}

		if (this.mindim<101 || this.mindim<101) {
			this.accentWidth = this.lineWidth * 1;
		} else {
			this.accentWidth = this.lineWidth * 2;
		}
		
		this.draw();
		
		return 1;
	}

	dial.prototype.draw = function() {
		var dial_angle = (((1.0 - this.val.value) * 2 * Math.PI) + (1.5 * Math.PI));
		var dial_position = (this.val.value + 0.25) * 2 * Math.PI
		var point = math.toCartesian(this.handleLength, dial_angle);

		this.erase();
		
		with (this.context) {
			
			fillStyle = this.colors.fill;
			
			//draw main circle
			beginPath();
				arc(this.center.x, this.center.y, this.circleSize-1, 0, Math.PI*2, true);
				fill();
			closePath();

			//draw color fill
			beginPath();
				lineWidth = this.accentWidth;
				arc(this.center.x, this.center.y, this.circleSize, Math.PI* 0.5, dial_position, false);
				lineTo(this.center.x,this.center.y);
				globalAlpha = 0.1;
				fillStyle = this.colors.accent;
				fill();
				globalAlpha = 1;
			closePath(); 

			//draw round accent
			beginPath();
				lineWidth = this.accentWidth;
				arc(this.center.x, this.center.y, this.circleSize-this.lineWidth , Math.PI* 0.5, dial_position, false);
				strokeStyle = this.colors.accent;
				stroke();
			closePath(); 
		
			//draw bar accent
			beginPath();
				lineWidth = this.accentWidth;
				strokeStyle = this.colors.accent;
				moveTo(this.center.x, this.center.y);
				lineTo(point.x + this.center.x, point.y + this.center.y);
				stroke();
			closePath(); 
			
			//draw circle in center
			beginPath();
				fillStyle = this.colors.accent;
				arc(this.center.x, this.center.y, this.circleSize/8, 0, Math.PI*2, false);
				fill();
			closePath(); 
			
		}

		this.drawLabel();
	}


	dial.prototype.click = function(e) {
		this.val.value = math.prune(this.val.value, 4)
		this.transmit(this.val);
		this.draw();
		this.aniStart = this.val.value;
	}


	dial.prototype.move = function() {	
		this.val.value = math.clip((this.val.value - (this.deltaMove.y * this.responsivity)), 0, 1);
		this.val.value = math.prune(this.val.value, 4)
		this.transmit(this.val);
		
		this.draw();
	}


	dial.prototype.release = function() {
		this.aniStop = this.val.value;
	}

	/** @method animate 
		Animates the dial
		@param {string} [type] Type of animation. Currently accepts "bounce" (bounces between mousedown and mouserelease points) or "none" */
	dial.prototype.animate = function(aniType) {
		
		switch (aniType) {
			case "bounce":
				nx.aniItems.push(this.aniBounce.bind(this));
				break;
			case "none":
				nx.aniItems.splice(nx.aniItems.indexOf(this.aniBounce));
				break;
		}
		
	}

	dial.prototype.aniBounce = function() {
		if (!this.clicked) {
			this.val.value += this.aniMove;
			if (this.aniStop < this.aniStart) {
				this.stopPlaceholder = this.aniStop;
				this.aniStop = this.aniStart;
				this.aniStart = this.stopPlaceholder;
			}
			this.aniMove = math.bounce(this.val.value, this.aniStart, this.aniStop, this.aniMove);	
			this.draw();
			this.val.value = math.prune(this.val.value, 4)
			this.transmit(this.val);
		}
	}


	},{"../core/widget":3,"../utils/math":6,"util":44}],15:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class envelope      
		Three-point line ramp generator
		```html
		<canvas nx="envelope"></canvas>
		```
		<canvas nx="envelope" style="margin-left:25px"></canvas>
	*/

	var envelope = module.exports = function (target) {
		
		this.defaultSize = { width: 75, height: 75 };
		widget.call(this, target);
		
		this.nodeSize = 0;
		/** @property {boolean} active Whether or not the envelope is currently animating. */
		this.active = false;
		/** @property {integer} duration The envelope's duration in ms. */
		this.duration = 1000; // 1000 ms
		/** @property {boolean} looping Whether or not the envelope loops. */
		this.looping = false

		//define unique attributes
		
		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *amp* | amplitude at current point of ramp (float 0-1)
			| *index* | current progress through ramp (float 0-1)
			| *x* | x of envelope peak point (float 0-1)
			| *y* | y of envelope peak point (float 0-1)
		*/
		this.val = {
			x: 0.15,
			y: 0.5,
			amp: 0,
			index: 0
		}
		this.init();

	}

	util.inherits(envelope, widget);

	envelope.prototype.init = function() {
		this.actualWid = this.width- this.nodeSize*2;
		this.actualHgt = this.height- this.nodeSize*2;
		this.draw();
		nx.aniItems.push(this.pulse.bind(this));
	}

	envelope.prototype.draw = function() {
		this.erase();
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);

			var drawingX = this.val.x * this.actualWid + this.nodeSize
			var drawingY = this.val.y * this.actualHgt + this.nodeSize

			//stay within right/left bounds
			if (drawingX<(this.bgLeft+this.nodeSize)) {
				drawingX = this.bgLeft + this.nodeSize;
			} else if (drawingX>(this.bgRight-this.nodeSize)) {
				drawingX = this.bgRight - this.nodeSize;
			}
			//stay within top/bottom bounds
			if (drawingY<(this.bgTop+this.nodeSize)) {
				drawingY = this.bgTop + this.nodeSize;
			} else if (drawingY>(this.bgBottom-this.nodeSize)) {
				drawingY = this.bgBottom - this.nodeSize;
			}
		
			with (this.context) {
				beginPath();
					strokeStyle = this.colors.accent;
					moveTo(0,this.height);
					lineTo(drawingX,drawingY);
					lineTo(this.width,this.height);					
					stroke();
					globalAlpha = 0.2;
					fillStyle = this.colors.accent;
					fill();
					globalAlpha = 1;
				closePath();
				beginPath();
					fillStyle = this.colors.accent;
					strokeStyle = this.colors.border;
					arc(drawingX, drawingY, this.nodeSize, 0, Math.PI*2, true);					
					fill();
				closePath();
				globalAlpha = 0.1
				fillRect(0,0,this.val.index*this.width,this.height);
				globalAlpha = 1;
			}
		}
		
		this.drawLabel();
	}

	envelope.prototype.scaleNode = function() {
		var actualX = this.val.x - this.nodeSize;
		var actualY = this.val.y - this.nodeSize;
		var clippedX = math.clip(actualX/this.actualWid, 0, 1);
		var clippedY = math.clip(actualY/this.actualHgt, 0, 1);
		this.val.x = math.prune(clippedX, 3)
		this.val.y = math.prune(clippedY, 3)
	}

	envelope.prototype.click = function() {
		this.val.x = this.clickPos.x;
		this.val.y = this.clickPos.y;
		this.scaleNode();
		this.transmit(this.val);
		this.draw();
	}

	envelope.prototype.move = function() {
		if (this.clicked) {
			this.val.x = this.clickPos.x;
			this.val.y = this.clickPos.y;
			this.scaleNode();
			this.transmit(this.val);
			this.draw();
		}
	}

	envelope.prototype.release = function() {
		this.val.x = this.clickPos.x;
		this.val.y = this.clickPos.y;
		this.scaleNode();
		this.draw();
	}

	envelope.prototype.pulse = function() {
		if (this.active) {
			this.val.index += ((this.width/3.3)/this.duration);
			this.val.index = math.clip(this.val.index, 0, 1)

			if (this.val.index < this.val.x) {
				var guiy = (this.val.index/this.val.x) * (1-this.val.y);
				this.val.amp = math.clip(guiy, 0, 1)
			} else {
				var guiy = ((1-this.val.index)/(1-this.val.x)) * (1-this.val.y);
				this.val.amp = math.clip(guiy, 0, 1)
			}
		
			this.transmit(this.val);
			this.draw();
			if (this.val.index >= 1) {
				if (this.looping) {
					this.val.index -= 1;
				} else {
					this.stop();
				}
			}
		}
	}

	/** @method start
		Start ramp from beginning. If set to loop, will loop the ramp until stopped. */
	envelope.prototype.start = function() {
		this.active = true;
		this.val.index = 0;
	}

	/** @method stop
		Stop the ramp and set progress to 0. */
	envelope.prototype.stop = function() {
		this.active = false;
		this.val.index = 0;
		this.draw();
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],16:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class ghost (alpha) 
		Interface gesture capture / playback (in development)    
		
		```html
		<canvas nx="ghost"></canvas>
		```
		<canvas nx="ghost" style="margin-left:25px"></canvas>
	*/

	var ghost = module.exports = function(target) {
		
		this.defaultSize = { width: 100, height: 50 };
		widget.call(this, target);
		
		//define unique attributes
		this.recording = false;
		this.playing = false;
		this.maxLength = 2000;
		this.components = new Array();
		this.buffer = new Array();
		//this.moment is for the record head
		this.moment = 0;
		//this.needle is for the playback head
		this.needle = 0;
		this.val = new Object();
		this.rate = 1;
		this.start = 0;
		this.end = 1;
		this.size = 0;
		this.looping = true;
		this.boundLog = this.log.bind(this)
		this.direction = 1;
		//settings
		this.noise = 0;
		this.loopstart = 0;
		this.loopend = 0;
		this.mode = "linear";   // linear,bounce,random,wander,pattern/dream
		//init
		this.init();

		this.boundAdv = this.advance.bind(this);
		nx.aniItems.push(this.boundAdv)

	}

	util.inherits(ghost, widget);


	ghost.prototype.init = function() {
		this.draw();
	}

	ghost.prototype.watch = function() {
	}
		
		//sets a new component to be recorded
	ghost.prototype.connect = function(target) {
		var compIndex = this.components.length;
		this.components.push(target);
		target.tapeNum = compIndex;
		target.isRecording = true;
		target.recorder = this;
		this.buffer[compIndex] = new Object();
		for (var key in target.val) {
			this.buffer[compIndex][key] = new Array();
		}
		
	}
		
		//the actual recording function
	ghost.prototype.write = function(index, val) {
		if (this.moment>=this.maxLength) {
			this.stop();
		}
		for (var key in val) {
			if (this.buffer[index][key]) {
				this.buffer[index][key][this.moment] = val[key];
			}
		}
		this.draw();
	}
		

	ghost.prototype.draw = function() {

		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height)
		}

		var quad = this.width/4;
		var quad2 = this.width-quad;
		
		if (!this.recording) {
			with (this.context) {
				fillStyle = "#e33";
				beginPath()
				arc(quad,this.height/2,quad*0.8,0,Math.PI*2)
				fill()
				closePath();
				textAlign = "center"
				textBaseline = "middle"
				font = "normal "+this.height/6+"px courier"
				fillStyle = this.colors.fill
				fillText("rec",quad,this.height/2)
			}
		} else {
			with (this.context) {
				fillStyle = "#e33";
				fillRect(quad*0.4,quad*0.4,quad*1.2,quad*1.2)
			}
		}
		
		if (!this.playing) {
			with (this.context) {
				fillStyle = this.colors.border
				beginPath()
				arc(quad2,this.height/2,quad*0.8,0,Math.PI*2)
				fill()
				closePath()
				textAlign = "center"
				textBaseline = "middle"
				font = "normal "+this.height/6+"px courier"
				fillStyle = this.colors.fill
				fillText("play",quad2,this.height/2)
			}
		} else {
			with (this.context) {
				strokeStyle = this.colors.border
				lineWidth = this.width/30
				beginPath()
				arc(quad2,this.height/2,quad*0.8,0,Math.PI*2)
				stroke()
				closePath()
				var sec = ~~(this.needle/30)
				textAlign = "center"
				textBaseline = "middle"
				font = "normal "+this.height/3+"px courier"
				fillStyle = this.colors.border
				fillText(sec,quad2,this.height/2+2)
			}
		}
	}

	ghost.prototype.record = function() {
		if (!this.playing) {
			this.components = new Array();
			for (var key in nx.widgets) {
				this.connect(nx.widgets[key]);
			}
		}
		this.moment = 0;
		nx.aniItems.push(this.boundLog)
		this.recording = true;
	}

	ghost.prototype.log = function() {
		for (var i=0;i<this.components.length;i++) {
			var sender = this.components[i];
			this.write(this.components[i].tapeNum,this.components[i].val);
		}
		this.moment++;
	}

	ghost.prototype.stop = function() {
		nx.removeAni(this.boundLog);
		this.size = this.moment;
		this.recording = false;
		this.draw();
	}


	ghost.prototype.scan = function(x) {
		// loop through the widgets that were recorded
		for (var i=0;i<this.components.length;i++) {
			//sender is the current widget we're looking at
			var sender = this.components[i];
			//loop through the widget's gesture buffer
			for (var key in this.buffer[sender.tapeNum]) {
				if (this.buffer[sender.tapeNum][key]) {
					//create a new val object
					var val = new Object();
					//make sure we're not looking out of bounds of the buffer
					var max = this.buffer[sender.tapeNum][key][~~this.needle+1] ? this.buffer[sender.tapeNum][key][~~this.needle+1] : this.buffer[sender.tapeNum][key][~~this.needle]
					if (this.buffer[sender.tapeNum][key][~~this.needle-this.direction] != undefined && this.buffer[sender.tapeNum][key][~~this.needle] != this.buffer[sender.tapeNum][key][~~this.needle-this.direction]) {
						// create the value pair
						val[key] = nx.interp(this.needle - ~~this.needle, this.buffer[sender.tapeNum][key][~~this.needle], max)
						val[key] += Math.random() * this.noise - this.noise/2;
						val[key] = nx.clip(val[key],0,1)
						//set the widget with the value from the buffer
						sender.set(val, true)
					}
				}
			}
		}
	}



	//this.moment is for the record head
	//this.needle is for the playback head

	ghost.prototype.play = function(rate,start,end) {
		rate ? this.rate = rate : false;
		if (start) {
			this.needle = this.moment-1;
			this.start = start;
		} else {
			this.needle = this.moment-1;
			this.start = 0;
		} 
		if (this.mode=="linear") {
			this.direction = 1;
		}
		end ? this.end = end : this.end = 1
		this.playing = true;
	}

	ghost.prototype.pause = function() {
		this.playing = false;
	}

	ghost.prototype.loop = function() {
		
	}

	ghost.prototype.advance = function() {
		if (this.playing) {
			if (this.mode == "linear" || this.mode == "bounce") {
				this.needle += this.rate*this.direction;
			} else if (this.mode=="random") {
				this.needle = nx.random((this.end-this.start)*this.size)+this.start*this.size;
				console.log(this.needle)
			} else if (this.mode=="wander") {
				var dir = 3
				this.needle > this.size*0.75 ? dir-- : null;
				this.needle < this.size*0.25 ? dir++ : null;
				this.needle += this.rate*this.direction * (nx.random(dir)-1);
			}

			if (this.needle/this.size < this.end && this.needle/this.size > this.start) {
				this.scan();
			} else if (this.looping) {
				if (this.mode=="linear") {
					this.needle = this.start*this.size + 1;
				} else {
					this.direction = this.direction * -1
				}
			} else {
				this.playing = false;
			}
			this.draw();
		}
	}
		

	ghost.prototype.click = function(e) {
		if (this.clickPos.x<this.width/2) {
			if (this.recording) {
				this.stop()
			} else {
				this.record()
			}
		} else {
			if (this.playing) {
				this.pause();
			} else {
				this.play();
			}
			this.draw();
		}
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],17:[function(require,module,exports){
	module.exports = {
	  banner: require('./banner'),
	  button: require('./button'),
	  colors: require('./colors'),
	  comment: require('./comment'),
	  crossfade: require('./crossfade'),
	  dial: require('./dial'),
	  envelope: require('./envelope'),
	  ghost: require('./ghost'),
	  joints: require('./joints'),
	  keyboard: require('./keyboard'),
	  matrix: require('./matrix'),
	  message: require('./message'),
	  meter: require('./meter'),
	  metro: require('./metro'),
	  mouse: require('./mouse'),
	  multislider: require('./multislider'),
	  multitouch: require('./multitouch'),
	  number: require('./number'),
	  position: require('./position'),
	  remix: require('./remix'),
	  range: require('./range'),
	  select: require('./select'),
	  slider: require('./slider'),
	  string: require('./string'),
	  tabs: require('./tabs'),
	  tilt: require('./tilt'),
	  toggle: require('./toggle'),
	  typewriter: require('./typewriter'),
	  vinyl: require('./vinyl'),
	  windows: require('./windows')
	}
	},{"./banner":9,"./button":10,"./colors":11,"./comment":12,"./crossfade":13,"./dial":14,"./envelope":15,"./ghost":16,"./joints":18,"./keyboard":19,"./matrix":20,"./message":21,"./meter":22,"./metro":23,"./mouse":24,"./multislider":25,"./multitouch":26,"./number":27,"./position":28,"./range":29,"./remix":30,"./select":31,"./slider":32,"./string":33,"./tabs":34,"./tilt":35,"./toggle":36,"./typewriter":37,"./vinyl":38,"./windows":39}],18:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class joints      
		2D slider with connections to several points; a proximity-based multislider.
		```html
		<canvas nx="joints"></canvas>
		```
		<canvas nx="joints" style="margin-left:25px"></canvas>
	*/

	var joints = module.exports = function (target) {
		this.defaultSize = { width: 150, height: 150 };
		widget.call(this, target);
		
		/* @property {integer} nodeSize The size of the proximity points in pixels */
		this.nodeSize = this.width/14; 
		this.values = [0,0];

		/** @property {object}  val  
			| &nbsp; | data
			| --- | ---
			| *x* | x position of touch/mouse
			| *y* | y position of touch/mouse
			| *node0* | nearness to first node if within range (float 0-1)
			| *node1* | nearness to second node if within range (float 0-1)
			| *node2* | nearness to third node if within range (float 0-1)
			| etc... | &nbsp;
			
		*/
		this.val = {
			x: 0.35,
			y: 0.35,
			node1: 0
		}
		/** @property {array} joints An array of objects with x and y properties detailing coordinates of each proximity node.
		```js
			// The widget will now have only 2 proximity points, instead of 8
			joints1.joints = [
			&nbsp; { x: 20 , y: 100 },
			&nbsp; { x: 75 , y: 150 }
			]
		```
		 */
		this.joints = [
			{ x: this.width/1.2 , y: this.height/1.2 },
			{ x: this.width/2 , y: this.height/1.3 },
			{ x: this.width/4.2 , y: this.height/1.1 },
			
			{ x: this.width/1.4 , y: this.height/2.2 },
			{ x: this.width/2.1 , y: this.height/1.8 },
			{ x: this.width/5 , y: this.height/2.4 },
			
			{ x: this.width/2.8 , y: this.height/6 },
			{ x: this.width/6 , y: this.height/3.7 }
		
		]
		this.threshold = this.width / 3;
	}
	util.inherits(joints, widget);

	joints.prototype.init = function() {
		this.draw();
	}

	joints.prototype.draw = function() {
		this.erase();

		this.drawingX = this.val.x * this.width;
		this.drawingY = this.val.y * this.height;

		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
			if (this.val.x != null) {
				this.drawNode();
			}
			else {
				fillStyle = this.colors.border;
				font = "14px courier";
				fillText(this.default_text, 10, 20);
			}	
			fillStyle = this.colors.accent;
			strokeStyle = this.colors.border;
			for (var i in this.joints) {
				beginPath();
					arc(this.joints[i].x, this.joints[i].y, this.nodeSize/2, 0, Math.PI*2, true);					
					fill();
				closePath();
				var cnctX = Math.abs(this.joints[i].x-this.drawingX);
				var cnctY = Math.abs(this.joints[i].y-this.drawingY);
				var strength = cnctX + cnctY;
				if (strength < this.threshold) {
					beginPath();
						moveTo(this.joints[i].x, this.joints[i].y);
						lineTo(this.drawingX,this.drawingY);
						strokeStyle = this.colors.accent;
						lineWidth = math.scale( strength, 0, this.threshold, this.nodeSize/2, 5 );
						stroke();
					closePath();
					var scaledstrength = math.scale( strength, 0, this.threshold, 1, 0 );
					this.val["node"+i] = scaledstrength;
				}
			}
		}
		
		this.drawLabel();
	}

	joints.prototype.drawNode = function() {
		//stay within right/left bounds
		if (this.drawingX<(this.nodeSize)) {
			this.drawingX = this.nodeSize;
		} else if (this.drawingX>(this.width-this.nodeSize)) {
			this.drawingX = this.width - this.nodeSize;
		}
		//stay within top/bottom bounds
		if (this.drawingY < this.nodeSize) {
			this.drawingY = this.nodeSize;
		} else if (this.drawingY>(this.height-this.nodeSize)) {
			this.drawingY = this.height - this.nodeSize;
		}

		with (this.context) {
			globalAlpha=1;
			beginPath();
				fillStyle = this.colors.accent;
				strokeStyle = this.colors.border;
				lineWidth = this.lineWidth;
				arc(this.drawingX, this.drawingY, this.nodeSize, 0, Math.PI*2, true);					
				fill();
			closePath();
		}
	}

	joints.prototype.click = function() {
		this.val = new Object();
		this.val.x = this.clickPos.x/this.width;
		this.val.y = this.clickPos.y/this.height;
		this.draw();
		this.transmit(this.val);
		this.connections = new Array();
	    
	}

	joints.prototype.move = function() {
		this.val = new Object();
		if (this.clicked) {
			this.val.x = this.clickPos.x/this.width;
			this.val.y = this.clickPos.y/this.height;
			this.draw();
			this.transmit(this.val);
			this.connections = new Array();
		}
	}


	joints.prototype.release = function() {
			this.anix = this.deltaMove.x/this.width;
			this.aniy = (this.deltaMove.y)/this.height;
		
	}

	/** @method animate
		Add simple physics to the widget
		@param {string} [type] Currently accepts "bounce" or "none".
	*/

	joints.prototype.animate = function(aniType) {
		
		switch (aniType) {
			case "bounce":
				nx.aniItems.push(this.aniBounce.bind(this));
				break;
			case "none":
				nx.aniItems.splice(nx.aniItems.indexOf(this.aniBounce));
				break;
		}
		
	}

	joints.prototype.anix = 0;
	joints.prototype.aniy = 0;

	joints.prototype.aniBounce = function() {
		if (!this.clicked && this.val.x) {
			this.val.x += (this.anix);
			this.val.y += (this.aniy);
			this.anix = math.bounce(this.val.x, 0.1, 0.9, this.anix);
			this.aniy = math.bounce(this.val.y, 0.1, 0.9, this.aniy);
			this.draw();
			this.transmit(this.val);
		}
	}

	},{"../core/widget":3,"../utils/math":6,"util":44}],19:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');
	var drawing = require('../utils/drawing');
	var math = require('../utils/math');

	/** 
		@class keyboard      
		Piano keyboard which outputs MIDI
		```html
		<canvas nx="keyboard"></canvas>
		```
		<canvas nx="keyboard" style="margin-left:25px"></canvas>
	*/

	var keyboard = module.exports = function (target) {

		this.defaultSize = { width: 300, height: 75 };
		widget.call(this, target);

		/** @property {integer} octaves Number of octaves on the keyboard */
		this.octaves = 3;
		this.white = {
			width:0,
			height:0
		}
		this.black = {
			width:0,
			height:0
		}
		this.wkeys = new Array();
		this.bkeys = new Array();

		/** @property {array} keypattern Array of 'w' and 'b' denoting the pattern of white and black keys. This can be customized! The pattern can be any number of keys, however each black key must be surrounded by two white keys.
		```js
			//This key pattern would put a black key between every white key
			keyboard1.keypattern = ['w','b','w','b','w','b','w','b','w','b','w','b']
			keyboard1.init()

			//This key pattern uses only white keys
			keyboard2.keypattern = ['w','w','w','w','w','w','w','w','w','w','w','w']
			keyboard2.init()
		```


		 */
		this.keypattern = ['w','b','w','b','w','w','b','w','b','w','b','w']
		this.keys = new Array();
		/** @property {integer} midibase The MIDI note value of the lowest note on the keyboard. Defaults to 48. */
		this.midibase = 48;
		this.lineWidth = 1;

		//to enable multitouch
		this.fingers = [
			{ 
				key: -1,
				pkey: -1

			}
		]
		this.multitouch = false; // will auto switch to true if experiences 2 simultaneous touches
		this.oneleft = false;

		/** @property {string} mode Play mode. Currently accepts "button" (default) or "sustain" in which each key acts as a toggle. */	
		this.mode = "button" // modes: "button", "sustain" and, possibly in future, "aftertouch"

		// for each key: x, y, w, h, color, on, note

		/** @property {object}  val   Core interactive values and data output
			| &nbsp; | data
			| --- | ---
			| *on* | 0 if noteon, 1 if noteoff
			| *note* | MIDI value of key pressed
			| *midi* | paired MIDI message as a string - example "20 0" - This is to allow for simultaneous arrival of the MIDI pair if sent as an OSC message. 
		*/
		this.val = {
			on: 0,
			note: 0,
			midi: "0 0"
		};

		this.init();
		
	}
	util.inherits(keyboard, widget);

	keyboard.prototype.init = function() {

		//recap from header
		this.white = {
			width:0,
			height:0
		}
		this.black = {
			width:0,
			height:0
		}
		this.wkeys = new Array();
		this.bkeys = new Array();

		/** @property {array} keys Array of key objects. This may be of use in combination with the keyboard.toggle method. */
		this.keys = new Array();

		//new stuff
		this.white.num = 0;
		for (var i=0;i<this.keypattern.length;i++) {
			this.keypattern[i]=='w' ? this.white.num++ : null;
		}
		this.white.num *= this.octaves;

		this.white.width = this.width/this.white.num
		this.white.height = this.height

		this.black.width = this.white.width*0.6
		this.black.height = this.height*0.6

		for (var i=0;i<this.keypattern.length*this.octaves;i++) {
			this.keys[i] = {
				note: i+this.midibase,
				on: false
			}
			switch (this.keypattern[i%this.keypattern.length]) {
				case 'w':
					this.keys[i].x =  this.wkeys.length*this.white.width,
					this.keys[i].y = 0,
					this.keys[i].w = this.white.width,
					this.keys[i].h = this.white.height,
					this.keys[i].type = 'w';
					this.keys[i].index = i;
					this.wkeys.push(this.keys[i]);

					break;
				case 'b':
					this.keys[i].x = this.wkeys.length*this.white.width - this.black.width/2,
					this.keys[i].y = 0,
					this.keys[i].w = this.black.width,
					this.keys[i].h = this.black.height,
					this.keys[i].type = 'b';
					this.keys[i].index = i;
					this.bkeys.push(this.keys[i]);
					break;
			}
		}


		this.draw();
	}

	keyboard.prototype.draw = function() {

		with (this.context) {
			strokeStyle = this.colors.border;
			lineWidth = 1;
				
			for (var i in this.wkeys) {
				fillStyle = this.wkeys[i].on ? this.colors.border : this.colors.fill
				strokeRect(this.wkeys[i].x,0,this.white.width,this.white.height);
				fillRect(this.wkeys[i].x,0,this.white.width,this.white.height);
			}
			for (var i in this.bkeys) {
				fillStyle = this.bkeys[i].on ? this.colors.border : this.colors.black
				fillRect(this.bkeys[i].x,0,this.black.width,this.black.height);
			}
			//strokeRect(0,0,this.width,this.height);
		}
		this.drawLabel();
	}

	/** @method toggle
		Manually toggle a key on or off, and transmit the new state.
		@param {object} [key]  A key object (from the .keys array) to be turned on or off
		@param {boolean} [on/off]  (Optional) Whether the key should be turned on (true) or off (false). If this parameter is left out, the key will switch to its opposite state.
		```js
		// Turns the first key on
		keyboard1.toggle( keyboard1.keys[0], true );
		```
	*/
	keyboard.prototype.toggle = function(key, data) {
		if (this.mode=="button") {
			if (key) {
				if (data) {
					key.on = data;
				} else {
					key.on = !key.on;
				}

				var on = key.on ? 1 : 0;
				var amp = math.invert(this.clickPos.y/this.height) * 128;
				amp = math.prune(math.clip(amp,5,128),0);

				this.val = { 
					on: on*amp,
					note: key.note,
					midi: key.note + " " + on
				};
				this.transmit(this.val);
				this.draw();
			}
		} else if (this.mode=="sustain") {
			if (key) {
				if (data) {
					key.on = data;
				} else {
					key.on = !key.on;
				}

				var on = key.on ? 1 : 0;
				var amp = math.invert(this.clickPos.y/this.height) * 128;
				amp = math.prune(math.clip(amp,5,128),0);

				this.val = { 
					on: on*amp,
					note: key.note,
					midi: key.note + " " + on
				};
				this.transmit(this.val);
				this.draw();
			}

		}

	}

	keyboard.prototype.whichKey = function (x, y){

		for (var i in this.bkeys) {
			if (drawing.isInside({"x":x,"y":y}, this.bkeys[i])) {
				return this.bkeys[i]
			}
		}

		var keyx = ~~(x/this.white.width);
		if (keyx>=this.wkeys.length) { keyx = this.wkeys.length-1 }
		if (keyx<0) { keyx = 0 }
		return this.wkeys[keyx];
	}

	keyboard.prototype.click = function(e) {
		if (this.clickPos.touches.length>1 || this.multitouch) {
			if (this.clickPos.touches.length>=2 && this.oneleft) {
				this.oneleft = false;
			}
			for (var j=0;j<this.clickPos.touches.length;j++) {
				this.multitouch = true;
				this.fingers[j] = {
					key: this.whichKey(this.clickPos.touches[j].x, this.clickPos.touches[j].y)
				}
				if (!this.fingers[j].key.on) {
					this.fingers[j].key.on = true;
				}
			}
		} else {
			this.fingers[0].pkey = this.fingers[0].key;
			this.fingers[0].key = this.whichKey(this.clickPos.x, this.clickPos.y);
			this.toggle(this.fingers[0].key)
		}
	}

	keyboard.prototype.move = function(e) {
		var debug = document.getElementById("debug");
		if (this.clickPos.touches.length>1 || this.multitouch) {
			this.keysinuse = new Array();
			for (var j=0;j<this.clickPos.touches.length;j++) {
				this.fingers[j] = {
					key: this.whichKey(this.clickPos.touches[j].x, this.clickPos.touches[j].y)
				}
				if (!this.fingers[j].key.on) {
					this.toggle(this.fingers[j].key, true)
				}
				this.keysinuse.push(this.fingers[j].key.index)
			}
			for (var j=0;j<this.keys.length;j++) {
				if (this.keys[j].on  && this.keysinuse.indexOf(this.keys[j].index)<0) {
					this.toggle(this.keys[j], false);
				}
			}
		} else {
			this.fingers[0].pkey = this.fingers[0].key;
			this.fingers[0].key = this.whichKey(this.clickPos.x, this.clickPos.y);
			if (this.fingers[0].key && this.fingers[0].key.index != this.fingers[0].pkey.index) {
				this.toggle(this.fingers[0].pkey, false);
				this.toggle(this.fingers[0].key, true);
			}
		}
	}

	keyboard.prototype.release = function(e) {
		if (this.clickPos.touches.length>1 || this.multitouch) {
			this.keysinuse = new Array();
			for (var j=0;j<this.clickPos.touches.length;j++) { 
				if (this.oneleft && this.clickPos.touches.length==1) {
					break;
				}
				this.fingers[j] = {
					key: this.whichKey(this.clickPos.touches[j].x, this.clickPos.touches[j].y)
				}
				this.keysinuse.push(this.fingers[j].key.index)
			}
			for (var j=0;j<this.keys.length;j++) {
				if (this.keys[j].on  && this.keysinuse.indexOf(this.keys[j].index)<0) {
					this.toggle(this.keys[j], false);
				}
			}
			if (this.clickPos.touches.length==1) { this.oneleft = true }
		} else {
			if (this.mode=="button") {
				this.toggle(this.fingers[0].key, false);
			}
		}
	}








	},{"../core/widget":3,"../utils/drawing":5,"../utils/math":6,"util":44}],20:[function(require,module,exports){
	var math = require('../utils/math');
	var drawing = require('../utils/drawing');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class matrix      
		Matrix of toggles, with sequencer functionality.
		```html
		<canvas nx="matrix"></canvas>
		```
		<canvas nx="matrix" style="margin-left:25px"></canvas>
	*/


	var matrix = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 100 };
		widget.call(this, target);
		

		/** @property {integer}  row   Number of rows in the matrix
		```js
			matrix1.row = 2;
			matrix1.init()
		```
		*/
		this.row = 4;

		/** @property {integer}  col   Number of columns in the matrix
		```js
			matrix1.col = 10;
			matrix1.init()
		```
		*/
		this.col = 4;
		
		this.cellHgt;
		this.cellWid;

		/** @property {array}  matrix   Nested array of matrix values. Cells can be manually altered using .matrix (see code), however this will *not* cause the new value to be transmit. See .setCell() to set/transmit cell values.
		```js
			//Turn on the cell at row 1 column 2
			matrix1.matrix[1][2] = 1
			matrix1.draw()


			//Turn off the cell at row 3 column 0
			matrix1.matrix[3][0] = 0
			matrix1.draw()
		```
		*/
		this.matrix;

		/** @property {object}  val   Core values and data output
			| &nbsp; | data
			| --- | ---
			| *row* | Current row being changed
			| *col* | Current column being changed
			| *level* | Whether cell is on or off (0 or 1)
			| *list * | Array of values in highlighted column (if sequencing)
		*/
		this.val = {
			row: 0,
			col: 0,
			level: 0,
			list: new Array()
		}

		//for mouse logic
		this.cur;
		this.prev;

		/** @property {boolean}  erasing   Whether or not mouse clicks will erase cells. Set to true automatically if you click on an "on" cell. */
		this.erasing = false;

		/** @property {integer}  place   When sequencing, the current column. */
		this.place = null;

		this.starttime;
		this.thisframe = 0;
		this.lastframe = 0;
		this.context.lineWidth = 1;

		this.sequencing = false;

		/** @property {integer}  cellBuffer  How much padding between matrix cells, in pixels */
		this.cellBuffer = 4;
		
		/** @property {string}  sequenceMode  Sequence pattern (currently accepts "linear" which is default, or "random") */
		this.sequenceMode = "linear"; // "linear" or "random". future options would be "wander" (drunk) or "markov"

		/** @property {integer}  bpm   Beats per minute (if sequencing)
		```js
			matrix1.bpm = 120;
		```
		*/
		this.bpm = 120;
		this.init();
		
	}
	util.inherits(matrix, widget);



	matrix.prototype.init = function() {
		
		this.pmatrix = this.matrix ? this.matrix : false;

		this.matrix = null;
		// generate 2D matrix array
		this.matrix = new Array(this.col)
		for (var i=0;i<this.col;i++) {
			this.matrix[i] = new Array(this.row)
			for (var j=0;j<this.row;j++) {
				this.matrix[i][j] = this.pmatrix ? this.pmatrix[i] ? this.pmatrix[i][j] : 0 : 0; // set value of each matrix cell
			}
		}


		this.draw();
		
	}

	matrix.prototype.draw = function() {

		this.erase();

		this.cellWid = this.width/this.col;
		this.cellHgt = this.height/this.row;

		for (var i=0;i<this.row;i++){
			for (var j=0;j<this.col;j++) {
				var st_x = j*this.cellWid // starting point(left)
				j==0 ? st_x += 0 : null;
				var st_y = i*this.cellHgt; // starting point(top)
				i==0 ? st_y += 0 : null;
				var boxwid = this.cellWid;
				var boxhgt = this.cellHgt;

				
				with (this.context) {
					strokeStyle = this.colors.border;
					lineWidth = this.cellBuffer;
					if (this.matrix[j][i] > 0) {
						fillStyle = this.colors.accent;
					} else {
						fillStyle = this.colors.fill;
					}
					fillRect(st_x+this.cellBuffer/2, st_y+this.cellBuffer/2, boxwid-this.cellBuffer, boxhgt-this.cellBuffer);
				
					// sequencer highlight
					if (this.place == j) {
						globalAlpha = 0.4;
						fillStyle = this.colors.border;
						fillRect(st_x, st_y, boxwid, boxhgt);
						globalAlpha = 1;
					}

				}
			} 
		}

		this.drawLabel();
	}



	matrix.prototype.click = function(e) {

		this.cur = {
			col: ~~(this.clickPos.x/this.cellWid),
			row: ~~(this.clickPos.y/this.cellHgt)
		}

		if (this.matrix[this.cur.col][this.cur.row]) {
			this.matrix[this.cur.col][this.cur.row] = 0;
			this.erasing = true;
		} else {
			this.matrix[this.cur.col][this.cur.row] = 1;
			this.erasing = false;
		}

		this.cur.value = this.matrix[this.cur.col][this.cur.row]
		this.prev = this.cur;

	//	var data = this.matrix[this.cur.col];
	//	data = data.join();
	//	data = data.replace(/\,/g," ");

		this.val = {
			row: this.cur.row,
			col: this.cur.col,
			level: this.cur.value
		}

		this.transmit(this.val);
		this.draw();
	}

	matrix.prototype.move = function(e) {
		if (this.clicked) {
			
			this.cur = {
				col: ~~(this.clickPos.x/this.cellWid),
				row: ~~(this.clickPos.y/this.cellHgt)
			}

			if (this.cur.row < this.row && this.cur.col < this.col && this.cur.row >= 0 && this.cur.col >=0) {
				if (this.cur.col!=this.prev.col || this.cur.row != this.prev.row) {
					if (this.erasing) {
						this.matrix[this.cur.col][this.cur.row] = 0;
					} else {
						this.matrix[this.cur.col][this.cur.row] = 1;
					}

					this.cur.value = this.matrix[this.cur.col][this.cur.row]
					this.prev = this.cur;

					this.val = {
						row: this.cur.row,
						col: this.cur.col,
						level: this.cur.value
					}

					this.transmit(this.val);
					this.draw();
				}
			}

		}
	}


	/** @method setCell
	Manually set an individual cell on/off and transmit the new value.
	@param {integer} [col] The column of the cell to be turned on/off
	@param {integer} [row] The row of the cell to be turned on/off
	@param {boolean} [on/off] Whether the cell should be turned on/off

	```js
		// Turns cell on at column 1 row 3
		matrix1.setCell(1,3,true);
	```
	*/
	matrix.prototype.setCell = function(col,row,on) {

		var value = on ? 1 : 0;
		this.matrix[col][row] = value

		this.val = {
			row: row,
			col: col,
			level: value
		}

		this.transmit(this.val);
		this.draw();

	}

	/** @method sequence
	@param {float} [bpm] Beats per minute of the pulse
	Turns the matrix into a sequencer.

	```js
		matrix1.sequence(240);
	```
	*/
	matrix.prototype.sequence = function(bpm) {

		if (bpm) {
			this.bpm = bpm;
		}	
		this.sequencing = true;
		requestAnimationFrame(this.seqStep.bind(this));
	 
	}

	/** @method stop
	Stops the matrix sequencer.

	```js
		matrix1.stop();
	```
	*/
	matrix.prototype.stop = function() {
		this.sequencing = false;
	}

	matrix.prototype.seqStep = function() {

	    var now = new Date().getTime();
	    var dt = now - nx.starttime;

	    this.thisframe = ~~(dt/(60000/this.bpm));

	    if (this.thisframe != this.lastframe) {

			if (this.sequenceMode=="linear") {
				this.place++;
			} else if (this.sequenceMode=="random") {
				this.place = math.random(this.col);
			}
			if (this.place>=this.col) {
				this.place = 0;
			}

			if (this.place==null) {
				this.place = 0;
			}

			this.jumpToCol(this.place);

	    }

	    this.lastframe = this.thisframe;
	    if (this.sequencing) {
			requestAnimationFrame(this.seqStep.bind(this));
		}
	}

	/** @method jumpToCol
	Jump to a certain column of the matrix, highlight it, and output its values as an array. Column numbers start at 0.

	```js
		matrix1.jumpToCol(1);
	```
	*/

	matrix.prototype.jumpToCol = function(place) {
			this.place = place
			this.val = {
				list: this.matrix[this.place]
			}
			this.transmit(this.val);
			this.draw();
	}


	matrix.prototype.customDestroy = function() {
		this.stop();
	}

	},{"../core/widget":3,"../utils/drawing":5,"../utils/math":6,"util":44}],21:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class message      
		Send a string of text.
		```html
		<canvas nx="message"></canvas>
		```
		<canvas nx="message" style="margin-left:25px"></canvas>
	*/

	var message = module.exports = function (target) {
		
		this.defaultSize = { width: 100, height: 30 };
		widget.call(this, target);
		

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *value* | Text of message, as string
		*/

		this.val = {
			value: "send a message"
		}

		/** @property {integer} size Text size in px */
		this.size = 12;
		
	}
	util.inherits(message, widget);

	message.prototype.init = function() {
		if (this.canvas.getAttribute("label")) {
			this.val.value = this.canvas.getAttribute("label");
		}
		//this.size = Math.sqrt((this.width * this.height) / (this.val.message.length));
		this.draw();
	}

	message.prototype.draw = function() {
		this.erase();
		with (this.context) {
			if (this.clicked) {
				fillStyle = this.colors.accent;
			} else {
				fillStyle = this.colors.fill;
			}
			fillRect(0,0,this.width,this.height)
			
			if (this.clicked) {
				fillStyle = this.colors.white;
			} else {
				fillStyle = this.colors.black;
			}
			textAlign = "left";
			font = this.size+"px courier";
		}
		this.wrapText(this.val.value, 5, 1+this.size, this.width-6, this.size);
	}

	message.prototype.click = function(e) {
		this.draw();
		this.transmit(this.val);
	}

	message.prototype.release = function(e) {
		this.draw();
	}
	},{"../core/widget":3,"util":44}],22:[function(require,module,exports){
	var util = require('util');
	var drawing = require('../utils/drawing');
	var widget = require('../core/widget');

	/** 
	    
	    @public
	    @class meter 

	    Decibel level meter.

	    ```html
	    <canvas nx="meter"></canvas>
	    ```
	    <canvas nx="meter" style="margin-left:25px"></canvas>
	*/

	var meter = module.exports = function(target) {

	    // to update, eventually (note to self)
	    // possibly a less-frequent animation request, to lighten the graphics load
	    // option for stereo meter? i.e. optional third .setup(ctx,s1,s2) argument

	    this.defaultSize = { width: 20, height: 50 };
	    widget.call(this, target);

	    this.val = {
	        level: 0
	    }
	    this.dataArray;
	    this.bars = 10;

	    this.init();

	}
	util.inherits(meter, widget);


	meter.prototype.init = function(){
	   this.bar = {
	        x: 0,
	        y: 0,
	        w: this.width,
	        h: this.height/this.bars
	    }
	    with (this.context) {
	        fillStyle = this.colors.fill;
	        fillRect(0,0,this.width, this.height);
	    }
	}

	meter.prototype.setup = function(actx,source){
	    this.actx = actx;   
	    this.source = source;

	    this.analyser = this.actx.createAnalyser();
	    this.analyser.smoothingTimeConstant = 0.85;
	    this.analyser.fftsize = 1024;
	    this.bufferLength = this.analyser.frequencyBinCount;
	    this.dataArray = new Uint8Array(this.bufferLength);
	    this.source.connect(this.analyser);
	    
	    this.draw();
	}

	meter.prototype.draw = function(){
	    
	    if(this.dataArray) {
	        this.analyser.getByteTimeDomainData(this.dataArray);

	        var max = Math.max.apply(null, this.dataArray);
	        var min = Math.min.apply(null, this.dataArray);
	        var amp = max - min;
	        amp /= 240

	        //converts amps to db
	        var db = 20 * (Math.log(amp) / Math.log(10))

	        with (this.context){
	            fillStyle = this.colors.fill;
	            fillRect(0,0,this.width, this.height);

	            //scales: -40 to +10 db range => a number of bars
	            var dboffset = Math.floor((db + 40) / (50/this.bars) );
	           
	            for (var i = 0; i<this.bars; i++) {

	                // 0+ db is red
	                if(i >= this.bars*.8) {
	                    fillStyle = 'rgb(255,0,0)';

	                // -5 to 0 db is yellow
	                } else if (i < this.bars*.8 && i >= this.bars*.69) {
	                    fillStyle = 'rgb(255,255,0)';

	                // -40 to -5 db is green
	                } else if (i < this.bars*.69) {
	                    fillStyle = 'rgb(0,255,0)';
	                }

	                // draw bar
	                if (i<dboffset)
	                    fillRect(1,this.height-this.bar.h*i,this.width-2,this.bar.h-1);

	            }
	        }
	    }

	    window.requestAnimationFrame(this.draw.bind(this));
	    
	}
	    
	    
	},{"../core/widget":3,"../utils/drawing":5,"util":44}],23:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class metro      
		Bouncing ball metronome
		```html
		<canvas nx="metro"></canvas>
		```
		<canvas nx="metro" style="margin-left:25px"></canvas>
	*/

	var metro = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 20 };
		widget.call(this, target);

		//define unique attributes
		
		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *beat* | Which side the ball is bouncing on (0 if left, 1 if right)
		*/
		this.val = {
			beat: 0
		}

		this.x = 10;
		this.y = 10;
		this.loc = 10;
		this.nodeSize = 10;
		/** @property {float} speed Speed of the ball (default 1) */
		this.speed = 1;
		this.direction = 1;
		/** @property {string} orientation Orientation of metro. Default is "horizontal". */
		this.orientation = "horizontal"
		this.boundary = this.width

		nx.aniItems.push(this.advance.bind(this));
		this.active = true;
		
		this.init();
	}
	util.inherits(metro, widget);

	metro.prototype.init = function() {
		this.nodeSize = Math.min(this.width,this.height)/2;
		if (this.width<this.height) {
			this.orientation = "vertical"
			this.boundary = this.height
		} else {
			this.orientation = "horizontal"
			this.boundary = this.width
		}
		this.x = this.nodeSize;
		this.y = this.nodeSize;
		this.loc = this.nodeSize;

		this.draw();

	}

	metro.prototype.draw = function() {
		this.erase()
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height); 

			beginPath();
			fillStyle = this.colors.accent;
			arc(this.x, this.y, this.nodeSize, 0, Math.PI*2, true);					
			fill();
			closePath();
		}
		
		this.drawLabel();
	}

	metro.prototype.click = function() {
	}

	metro.prototype.move = function() {
		if (this.clicked) {
			this.speed -= (this.deltaMove.y / 50);
		}
	}

	metro.prototype.release = function() {
	}

	metro.prototype.advance = function() {
		if (this.speed>=0) {
			this.loc += this.speed * this.direction;
		} else {
			this.loc += this.speed * this.direction;
		}
		if (this.loc-this.nodeSize<0 || this.loc+this.nodeSize>this.boundary) {
			this.val.beat = math.scale(this.direction,-1,1,0,1)
			this.transmit(this.val);
			this.direction *= -1
		}
		if (this.orientation == "vertical") {
			this.y = this.loc
		} else {
			this.x = this.loc
		}
		this.draw();
	}

	metro.prototype.customDestroy = function() {
		nx.removeAni(this.advance.bind(this))
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],24:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');
	var math = require('../utils/math');

	/** 
		@class mouse      
		Mouse tracker, relative to web browser window.
		```html
		<canvas nx="mouse"></canvas>
		```
		<canvas nx="mouse" style="margin-left:25px"></canvas>
	*/

	var mouse = module.exports = function (target) {
		
		this.defaultSize = { width: 98, height: 100 };
		widget.call(this, target);

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *x* | x value of mouse relative to browser
			| *y* | y value of mouse relative to browser
			| *deltax* | x change in mouse from last position
			| *deltay* | y change in mouse from last position
		*/
		this.val = {
			x: 0,
			y: 0,
			deltax: 0, 
			deltay: 0
		}
		this.inside = new Object();
		this.boundmove = this.preMove.bind(this)
		this.mousing = window.addEventListener("mousemove", this.boundmove, false);
		
		this.init();
	}
	util.inherits(mouse, widget);

	mouse.prototype.init = function() {
		
		this.inside.height = this.height;
		this.inside.width = this.width;
		this.inside.left = 0;
		this.inside.top = 0;
		this.inside.quarterwid = (this.inside.width)/4;
		 
		this.draw();
	}

	mouse.prototype.draw = function() {
		this.erase();

		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height); 

			var scaledx = -(this.val.x) * this.height;
			var scaledy = -(this.val.y) * this.height;
			var scaleddx = -(this.val.deltax) * this.height - this.height/2;
			var scaleddy = -(this.val.deltay) * this.height - this.height/2;

			fillStyle = this.colors.accent;
			fillRect(this.inside.left, this.inside.height, this.inside.quarterwid, scaledx);
			fillRect(this.inside.quarterwid, this.inside.height, this.inside.quarterwid, scaledy);
			fillRect(this.inside.quarterwid*2, this.inside.height, this.inside.quarterwid, scaleddx);
			fillRect(this.inside.quarterwid*3, this.inside.height, this.inside.quarterwid, scaleddy);

			globalAlpha = 1;
			fillStyle = this.colors.fill;
			textAlign = "center";
			font = this.width/7+"px "+this.font;
			fillText("x", this.inside.quarterwid*0 + this.inside.quarterwid/2, this.height-7);
			fillText("y", this.inside.quarterwid*1 + this.inside.quarterwid/2, this.height-7);
			fillText("dx", this.inside.quarterwid*2 + this.inside.quarterwid/2, this.height-7);
			fillText("dy", this.inside.quarterwid*3 + this.inside.quarterwid/2, this.height-7);

			globalAlpha = 1;
		}
		
		this.drawLabel();
	}

	mouse.prototype.move = function(e) {
		this.val = {
			deltax: e.clientX/window.innerWidth - this.val.x,
			deltay: math.invert(e.clientY/window.innerHeight) - this.val.y,
			x: e.clientX/window.innerWidth,
			y: math.invert(e.clientY/window.innerHeight)
		}
		this.draw();
		this.transmit(this.val);

	}

	mouse.prototype.customDestroy = function() {
		window.removeEventListener("mousemove",  this.boundmove, false);
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],25:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class multislider      
		Multiple vertical sliders in one interface.
		```html
		<canvas nx="multislider"></canvas>
		```
		<canvas nx="multislider" style="margin-left:25px"></canvas>
	*/
	var multislider = module.exports = function (target) {
		
		this.defaultSize = { width: 100, height: 75 };
		widget.call(this, target);
		
		/** @property {integer} sliders Number of sliders in the multislider. (Must call .init() after changing this setting, or set with .setNumberOfSliders) */
		this.sliders = 15;

		/** @property {array}  val   Array of slider values. <br> **Note:** This widget's output is not .val! Transmitted output is:	

			| &nbsp; | data
			| --- | ---
			| *(slider index)* | value of currently changed slider
			| list | all multislider values as list. (if the interface sends to js or node, this list will be an array. if sending to ajax, max7, etc, the list will be a string of space-separated values)

		*/
		
		this.val = new Object();
		for (var i=0;i<this.sliders;i++) {
			this.val[i] = 0.7;
		}
		this.sliderClicked = 0;
		this.oldSliderToMove;
		this.init();
	}
	util.inherits(multislider, widget);

	multislider.prototype.init = function() {
		this.val = new Object();
		for (var i=0;i<this.sliders;i++) {
			this.val[i] = 0.7;
		}
		this.realSpace = { x: this.width, y: this.height }
		this.sliderWidth = this.realSpace.x/this.sliders;
		this.draw();
	}

	multislider.prototype.draw = function() {
		this.erase();
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
			
			strokeStyle = this.colors.accent;
			fillStyle = this.colors.accent;
			lineWidth = 5;
	    	
			for(var i=0; i<this.sliders; i++) {
				beginPath();
				moveTo(i*this.sliderWidth, this.height-this.val[i]*this.height);
				lineTo(i*this.sliderWidth + this.sliderWidth, this.height-this.val[i]*this.height);
				stroke();
				lineTo(i*this.sliderWidth + this.sliderWidth, this.height);
				lineTo(i*this.sliderWidth,  this.height);
				globalAlpha = 0.3 - (i%3)*0.1;
				fill();
				closePath(); 
				globalAlpha = 1;
			//	var separation = i==this.sliders-1 ? 0 : 1;
			//	fillRect(i*this.sliderWidth, this.height-this.val[i]*this.height, this.sliderWidth-separation, this.val[i]*this.height)
			}
		}
		this.drawLabel();
	}

	multislider.prototype.click = function() {
		this.oldSliderToMove = false;
		this.move(true);
	}

	multislider.prototype.move = function(firstclick) {
		if (this.clicked) {


			if (this.clickPos.touches.length>1) {

				for (var i=0;i<this.clickPos.touches.length;i++) {
					var sliderToMove = Math.floor(this.clickPos.touches[i].x / this.sliderWidth);
					sliderToMove = math.clip(sliderToMove,0,this.sliders-1);
					this.val[sliderToMove] = math.clip(math.invert((this.clickPos.touches[i].y / this.height)),0,1);
				}

			} else {

				var sliderToMove = Math.floor(this.clickPos.x / this.sliderWidth);
				sliderToMove = math.clip(sliderToMove,0,this.sliders-1);
				this.val[sliderToMove] = math.clip(math.invert(this.clickPos.y / this.height),0,1);

				if (this.oldSliderToMove && this.oldSliderToMove > sliderToMove + 1) {
					var missed = this.oldSliderToMove - sliderToMove - 1;
					for (var i=1;i<=missed;i++) {
						this.val[sliderToMove+i] = this.val[sliderToMove] + (this.val[this.oldSliderToMove] - this.val[sliderToMove]) * ((i/(missed+1)));
					}
				} else if (this.oldSliderToMove && sliderToMove > this.oldSliderToMove + 1) {
					var missed = sliderToMove - this.oldSliderToMove - 1;
					for (var i=1;i<=missed;i++) {
						this.val[this.oldSliderToMove+i] = this.val[this.oldSliderToMove] + (this.val[sliderToMove] - this.val[this.oldSliderToMove]) * ((i/(missed+1)));
					}
				}
			
			}
			this.draw();
		}
		var msg = new Object()
		msg[sliderToMove] = this.val[sliderToMove]
		if (this.destination=="js" || this.destination=="node") {
			msg["list"] = this.val;
		} else {
			msg["list"] = new String();
			for (var key in this.val) { msg["list"] += this.val[key] + " " }
		}
		this.transmit(msg);
		this.oldSliderToMove = sliderToMove;
		
	}

	/** @method setNumberOfSliders
	@param {integer} [num] New number of sliders in the multislider */
	multislider.prototype.setNumberOfSliders = function(numOfSliders) {
		this.sliders = numOfSliders;
		this.val = new Array();
		for (var i=0;i<this.sliders;i++) {
			this.val.push(0.7);
		}
		this.sliderWidth = this.realSpace.x/this.sliders;
		this.init();
	}

	/** @method setSliderValue
	Sets a slider to new value and transmits.
	@param {integer} [slider] Slider to set (slider index starts at 0)
	@param {integer} [value] New slider value */
	multislider.prototype.setSliderValue = function(slider,value) {
		this.val[slider] = value;
		this.draw();
		var msg = new Object();
		msg[slider] = this.val[slider]
		if (this.destination=="js" || this.destination=="node") {
			msg["list"] = this.val;
		} else {
			msg["list"] = new String();
			for (var key in this.val) { msg["list"] += this.val[key] + " " }
		}
		this.transmit(msg);
	}

	},{"../core/widget":3,"../utils/math":6,"util":44}],26:[function(require,module,exports){
	var math = require('../utils/math');
	var drawing = require('../utils/drawing');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class multitouch      
		Multitouch 2d-slider with up to 5 points of touch.
		```html
		<canvas nx="multitouch"></canvas>
		```
		<canvas nx="multitouch" style="margin-left:25px"></canvas>
	*/

	var multitouch = module.exports = function (target) {
		
		this.defaultSize = { width: 200, height: 200 };
		widget.call(this, target);
		
		//unique attributes
		this.nodeSize = this.width/10;

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *touch1.x* | x position of first touch
			| *touch1.y* | y position of first touch
			| *touch2.x* | x position of second touch (if 2 touches)
			| *touch2.y* | y position of second touch (if 2 touches)
			| *etc* | &nbsp;
		*/
		this.val = {
			touch1: {
				x: 0,
				y: 0
			}
		}
		
		this.nodes = new Array();
		
		/** @property {string}  text  Text that will show when object is static */
		this.text = "multitouch";

		this.rainbow = ["#00f", "#04f", "#08F", "0AF", "0FF"];
		
		/** @property {string}  mode   "normal" or "matrix" mode. "matrix" mode has a GUI of discrete touch areas.
		*/
		this.mode = "normal";

		/** @property {integer}  rows   How many rows in the matrix (matrix mode only)
		*/
		this.rows = 10;

		/** @property {integer}  cols   How many rows in the matrix (matrix mode only)
		*/
		this.cols = 10;

		/** @property {array}  matrixLabels  An array of strings that can provide text labels on cells of the matrix. If shorter than the matrix cells, the array will repeat.
		```
			this.mode = "matrix"
			this.matrixLabels = [ "A", "A#", "B", "C" ]
			this.init();
		```
		*/
		this.matrixLabels = false;

		this.init();
	}
	util.inherits(multitouch, widget);

	multitouch.prototype.init = function() {
		this.nodeSize = this.width/10;
		this.draw();
	}

	multitouch.prototype.draw = function() {
		this.erase();
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);

			var count = 0;

			if (this.mode == "matrix") {
				for (var j=0;j<this.rows;j++) {
					for (var i=0;i<this.cols;i++) {
						with (this.context) {
							beginPath();
								fillStyle = this.colors.accent;
								strokeStyle = this.colors.border;
								lineWidth = 1;
								var circx = i*this.width/this.cols + (this.width/this.cols)/2;
								var circy = j*this.height/this.rows + (this.height/this.rows)/2;
								arc(circx, circy, (this.height/this.rows)/2, 0, Math.PI*2, true);					
								stroke();
								fillStyle = this.colors.border;
								textAlign = "center";
								textBaseline = "middle";
								if (this.matrixLabels) {
									fillText(this.matrixLabels[count%this.matrixLabels.length], circx, circy);
									count++
								} 
								var thisarea = {
									x: i*this.width/this.cols,
									y: j*this.height/this.rows,
									w: this.width/this.cols,
									h: this.height/this.rows
								}
								if (this.clickPos.touches.length>=1) {
									for (var k=0;k<this.clickPos.touches.length;k++) {
										if (drawing.isInside(this.clickPos.touches[k],thisarea)) {
											globalAlpha=0.5;
											fillStyle = this.colors.accent;
											fill();
											globalAlpha=0.3;
											fillStyle = this.rainbow[k];
											fill();
											globalAlpha=1;
										}
									}
								}
							closePath();
						}
					}
				}
			} else {
				if (this.clickPos.touches.length>=1) {
					for (var i=0;i<this.clickPos.touches.length;i++) {
						
						with (this.context) {
							globalAlpha=0.5;
							beginPath();
							fillStyle = this.colors.accent;
							strokeStyle = this.colors.border;
							lineWidth = this.lineWidth;
							arc(this.clickPos.touches[i].x, this.clickPos.touches[i].y, this.nodeSize, 0, Math.PI*2, true);					
							fill();
							//	stroke();
							closePath();
							globalAlpha=0.3;
							beginPath();
							fillStyle = this.rainbow[i];
							strokeStyle = this.colors.border;
							lineWidth = this.lineWidth;
							arc(this.clickPos.touches[i].x, this.clickPos.touches[i].y, this.nodeSize, 0, Math.PI*2, true);					
							fill();
							//	stroke();
							closePath(); 
							globalAlpha=1;
						}

					}
				}
				else {
					this.setFont()
					fillStyle = this.colors.border;
					fillText(this.text, this.width/2, this.height/2);
					globalAlpha = 1;
				}
			}
		}
		this.drawLabel();
	}

	multitouch.prototype.click = function() {
		this.draw();
		this.sendit();
	}

	multitouch.prototype.move = function() {
		if (this.clicked) {
			this.draw();
			this.sendit();
		}
	}

	multitouch.prototype.release = function() {

		if(!this.clicked) {
			this.clickPos.touches = new Array();
			for (var i=0;i<5;i++) {
				this.val["touch"+i] = {
					x: 0,
					y: 0
				}
			}
			this.transmit(this.val);
		}
		
		this.draw();
		this.sendit();
		
	}

	multitouch.prototype.sendit = function() {
		this.val = new Object();
		for (var i=0;i<this.clickPos.touches.length;i++) {
			this.val["touch"+i] = {
				x: this.clickPos.touches[i].x/this.width,
				y: math.invert(this.clickPos.touches[i].y/this.height)
			}
		}
		this.transmit(this.val);
	}
	},{"../core/widget":3,"../utils/drawing":5,"../utils/math":6,"util":44}],27:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class number      
		Number box
		```html
		<canvas nx="number"></canvas>
		```
		<canvas nx="number" style="margin-left:25px"></canvas>
	*/

	var number = module.exports = function (target) {
		this.defaultSize = { width: 50, height: 20 };
		widget.call(this, target);
		
		/** @property {object}  val    
			| &nbsp; | data
			| --- | ---
			| *value* | Number value
			
			```js
				// Sets number1.val.value to 20
				number1.set({
					value: 20
				})
			```
		*/
		this.val = {
			value: 0
		}

		/** @property {integer}  decimalPlaces   How many decimal places on the number. This applies to both the output and the interface text. Default is 2. To achieve an int (non-float), set decimalPlaces to 0.

			```js
				// Turns number into an int counter
				number1.decimalPlaces = 0;
			```

		*/ 
		this.decimalPlaces = 2;
		this.lostdata = 0;
		this.actual = 0;
		this.init();
	}
	util.inherits(number, widget);

	number.prototype.init = function() {
		this.draw();
	}

	number.prototype.draw = function() {
		this.erase();
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
			fillStyle = this.colors.black;
			textAlign = "left";
			font = this.height*.6+"px courier";
			textBaseline = 'middle';
			fillText(this.val.value, this.width/10, this.height/2);
		}
	}

	number.prototype.move = function(e) {
		if (this.clicked) {
			this.val.value += (this.deltaMove.x*.02);
			this.val.value += (this.deltaMove.y*-.1);
			this.val.value += this.lostdata;
			this.actual = this.val.value;
			this.val.value = math.prune(this.val.value,this.decimalPlaces);
			this.lostdata = this.actual - this.val.value;
			this.draw();
			this.transmit(this.val);
		}
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],28:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class position      
		Two-dimensional touch slider.
		```html
		<canvas nx="position"></canvas>
		```
		<canvas nx="position" style="margin-left:25px"></canvas>
	*/

	var position = module.exports = function (target) {

		// define a default size
		this.defaultSize = { width: 150, height: 100 };

		widget.call(this, target);
		
		/** @property {integer} nodeSize Size of touch node graphic. */
		this.nodeSize = 15;

		/** @property {object}  val   val is an object containing the main interactive / actionable aspects of the widget.
			| &nbsp; | data
			| --- | ---
			| *x* | x position of slider (float 0-1)
			| *y* | y position of slider (float 0-1)
		*/
		this.val = {
			x: 0.5,
			y: 0.5
		}
		
		this.init();
	}

	// inherit the widget object template
	util.inherits(position, widget);

	// .init() is called automatically when the widget is created on a webpage.
	position.prototype.init = function() {
		this.nodeSize = Math.min(this.height,this.width)/10;
		this.nodeSize = Math.max(this.nodeSize,10)
		this.actualWid = this.width - this.nodeSize*2;
		this.actualHgt = this.height - this.nodeSize*2;
		this.draw();
	}

	// .draw() should be used for any graphics activity
	position.prototype.draw = function() {
		this.erase();
		with (this.context) {

			// use this.colors.fill for the widget background color (default: very light gray)
			// use this.colors.border for any extra structural needs (default: light gray)
			// use this.colors.accent for important or highlighted parts (default: a bright color)
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);

			var drawingX = this.val.x * this.actualWid + this.nodeSize
			var drawingY = math.invert(this.val.y) * this.actualHgt + this.nodeSize

			//stay within right/left bounds
			if (drawingX<(this.nodeSize)) {
				drawingX = this.nodeSize;
			} else if (drawingX>(this.width-this.nodeSize)) {
				drawingX = this.width - this.nodeSize;
			}
			//stay within top/bottom bounds
			if (drawingY<(this.nodeSize)) {
				drawingY = this.nodeSize;
			} else if (drawingY>(this.height-this.nodeSize)) {
				drawingY = this.height - this.nodeSize;
			}
		
			with (this.context) {
				// draw the x/y level meters
			/*	beginPath();
				strokeStyle = this.colors.accent;
				lineWidth = 5;
				moveTo(0,this.height);
				lineTo(this.val.x*this.width,this.height);
				moveTo(0,this.height);
				lineTo(0,math.invert(this.val.y)*this.height);					
				stroke();
				closePath(); */

				// draw the touch point
				beginPath();
				fillStyle = this.colors.accent;
				arc(drawingX, drawingY, this.nodeSize, 0, Math.PI*2, true);					
				fill();
				closePath();
			}
		}
		
		this.drawLabel();
	}

	// .click() will be fired when the interface is interacted with
	// this.clicked is automatically set to true
	// this.clickPos is already and object with x and y properties detailing click point.
	position.prototype.click = function() {
		this.val.x = this.clickPos.x;
		this.val.y = this.clickPos.y;
		this.scaleNode();
		this.val["state"] = "click"
		this.transmit(this.val);
		this.draw();
	}

	// .move() will be fired when the interface is moved over after being clicked
	// this.clickPos is already and object with x and y properties detailing click point.
	position.prototype.move = function() {
		this.val.x = this.clickPos.x;
		this.val.y = this.clickPos.y;
		this.scaleNode();
		this.val["state"] = "move"
		this.transmit(this.val);
		this.draw();
	}

	// .release() will be fired on mouse up (unclick)
	position.prototype.release = function() {
		this.val.x = this.clickPos.x;
		this.val.y = this.clickPos.y;
		this.scaleNode();
		this.val["state"] = "release"
		this.transmit(this.val);
		this.draw();
	}

	/* TOUCH SPECIFIC EVENTS
	 currently, ontouch, ontouchmove, and ontouchrelease automatically execute .click, .move, and .release
	 so you only need to write one function for these events, and they will be touch compatible by default
	 however if you would like to create a touch-specific event you may define the following functions.
	 in these functions, .clickPos and .clicked will refer to your touch interactions.

	position.prototype.touch = function() {

	}

	position.prototype.touchmove = function() {
		
	}

	position.prototype.touchrelease = function() {
		
	}




	*/



	/* 
	 extra functions pertaining only to this widget 
	*/

	position.prototype.scaleNode = function() {
		var actualX = this.val.x - this.nodeSize;
		var actualY = this.val.y - this.nodeSize;
		var clippedX = math.clip(actualX/this.actualWid, 0, 1);
		var clippedY = math.clip(actualY/this.actualHgt, 0, 1);
		this.val.x = math.prune(clippedX, 3)
		this.val.y = math.prune(clippedY, 3)
		this.val.y = math.invert(this.val.y);
	}

	/** @method animate
		Adds animation to the widget.
		@param {string} [type] Type of animation. Currently accepts "none" or "bounce", in which case the touch node can be tossed and bounces.
	*/
	position.prototype.animate = function(aniType) {
		
		switch (aniType) {
			case "bounce":
				nx.aniItems.push(this.aniBounce.bind(this));
				break;
			case "none":
				nx.aniItems.splice(nx.aniItems.indexOf(this.aniBounce));
				break;
		}
		
	}

	position.prototype.aniBounce = function() {
		if (!this.clicked && this.val.x) {
			this.val.x += (this.deltaMove.x/2)/this.width;
			this.val.y += (this.deltaMove.y/2)/this.height;
			this.val["state"] = "animated";
			if (math.bounce(this.val.x, 0, 1, this.deltaMove.x) != this.deltaMove.x) {
				this.deltaMove.x = math.bounce(this.val.x, 0, 1, this.deltaMove.x);
				this.val["state"] = "bounce";
			}
			if (math.bounce(this.val.y, 0, 1, this.deltaMove.y) != this.deltaMove.y) {
				this.deltaMove.y = math.bounce(this.val.y, 0, 1, this.deltaMove.y);
				this.val["state"] = "bounce";
			}
			this.transmit(this.val);
			this.draw();
		}
	}

	position.prototype.customDestroy = function() {
		nx.removeAni(this.aniBounce);
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],29:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');
	var math = require('../utils/math')

	/** 
		@class range      
		Range slider
		```html
		<canvas nx="range"></canvas>
		```
		<canvas nx="range" style="margin-left:25px"></canvas>
	*/

	var range = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 30 };
		widget.call(this, target);

		/** @property {object}  val  Object containing core interactive aspects of widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *start* | Range start value (float 0-1)
			| *stop* | Range end value (float 0-1)
			| *size* | Distance between ends (float 0-1)
		*/
		this.val = {
			start: 0.3,
			stop: 0.7,
			size: 0.4
		}


		// handling horiz possibility
		/** @property {boolean}  hslider  Whether or not the slider is a horizontal slider. Default is false, but set automatically to true if the slider is wider than it is tall. */  
		this.hslider = false;
		this.handle;
		this.relhandle;
		this.cap;
		this.firsttouch = "start";

		/** @property {string}  mode  Mode of interaction. "edge" mode lets you drag each edge of the range individually. "area" mode (default) lets you drag the range as a whole (with parallel mouse movement) or scale the range as a whole (with transverse mouse movement) */
		this.mode = "area" // modes: "edge", "area"
		this.touchdown = new Object();
		this.init();
	}
	util.inherits(range, widget);

	range.prototype.init = function() {

		//decide if hslider or vslider
		if (this.height>=this.width) {
			this.hslider = false;
		} else {
			this.hslider = true;
		}

		if (this.canvas.getAttribute("label")!=null) {
			this.label = this.canvas.getAttribute("label");
		}

		this.draw();
	}

	range.prototype.draw = function() {
		this.erase();
			
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
		
			if (!this.hslider) {
				
				if (nx.showLabels && this.label) {
					save();
		 			translate(this.width/2, 0);
					rotate(Math.PI/2);
					this.setFont();
					fillText(this.label, this.height/2, 0);
					globalAlpha = 1;
					restore();
				}

				var x1 = 0;
				var y1 = this.height-this.val.stop*this.height;
				var x2 = this.width;
				var y2 = this.height-this.val.start*this.height;

				fillStyle = this.colors.accent;
				fillRect(x1,y1,x2-x1,y2-y1);

			} else {
				
				if (nx.showLabels && this.label) {
					this.setFont();
					fillText(this.label, this.width/2, this.height/2);
					globalAlpha = 1;
				}

				var x1 = this.val.start*this.width;
				var y1 = 0;
				var x2 = this.val.stop*this.width;
				var y2 = this.height;
			   
			
				fillStyle = this.colors.accent;
				fillRect(x1,y1,x2-x1,y2-y1);
			}
		}
	}

	range.prototype.click = function() {
		if (this.mode=="edge") {
			if (this.hslider) {
				if (Math.abs(this.clickPos.x-this.val.start*this.width) < Math.abs(this.clickPos.x-this.val.stop*this.width)) {
					this.firsttouch = "start"
				} else {
					this.firsttouch = "stop"
				}
			} else {
				if (Math.abs(Math.abs(this.clickPos.y-this.height)-this.val.start*this.height) < Math.abs(Math.abs(this.clickPos.y-this.height)-this.val.stop*this.height)) {
					this.firsttouch = "start"
				} else {
					this.firsttouch = "stop"
				}
			}
		} else if (this.mode=="area") {
			this.touchdown = {
				x: this.clickPos.x,
				y: this.clickPos.y
			}
			this.startval = new Object();
			this.startval.size = this.val.stop - this.val.start;
			this.startval.loc = this.val.start + this.startval.size/2;
		}
		this.move();
	}

	range.prototype.move = function() {

		if (this.mode=="edge") {
			if (this.hslider) {
				if (this.firsttouch=="start") {
					this.val.start = this.clickPos.x/this.width;
					if (this.clickPos.touches.length>1) {
						this.val.stop = this.clickPos.touches[1].x/this.width;
					}
				} else {
					this.val.stop = this.clickPos.x/this.width;
					if (this.clickPos.touches.length>1) {
						this.val.start = this.clickPos.touches[1].x/this.width;
					}
				}
			} else {
				if (this.firsttouch=="start") {
					this.val.start = math.invert(this.clickPos.y/this.height);
					if (this.clickPos.touches.length>1) {
						this.val.stop = math.invert(this.clickPos.touches[1].y/this.height);
					}
				} else {
					this.val.stop = math.invert(this.clickPos.y/this.height);
					if (this.clickPos.touches.length>1) {
						this.val.start = math.invert(this.clickPos.touches[1].y/this.height);
					}
				}
			}

			if (this.val.stop < this.val.start) {
				this.tempstart = this.val.start;
				this.val.start = this.val.stop;
				this.val.stop = this.tempstart;
				if (this.firsttouch=="start") {
					this.firsttouch = "stop";
				} else {
					this.firsttouch = "start";
				}
			} 
			this.val = {
				start: math.clip(this.val.start, 0, 1),
				stop: math.clip(this.val.stop, 0, 1),
			} 
			this.val['size'] = math.prune(math.clip(Math.abs(this.val.stop - this.val.start), 0, 1), 3)
		
			this.draw();

			this.transmit(this.val);

		} else if (this.mode=="area") {

			if (this.hslider) {
				var moveloc = this.clickPos.x/this.width;
				var movesize = (this.touchdown.y - this.clickPos.y)/this.height;
			} else {
				var moveloc = nx.invert(this.clickPos.y/this.height);
				var movesize = (this.touchdown.x - this.clickPos.x)/this.width;
			//	moveloc *= -1;
				movesize *= -1;
			}
			movesize /= 3;
			var size = this.startval.size + movesize;
			size = math.clip(size,0.001,1);

			this.val = {
				start: moveloc - size/2,
				stop: moveloc + size/2
			}

			this.val.start = math.clip(this.val.start,0,1);
			this.val.stop = math.clip(this.val.stop,0,1);

			this.draw();

			this.transmit(this.val);

		}
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],30:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class remix (alpha)     
		
		```html
		<canvas nx="remix"></canvas>
		```
		<canvas nx="remix" style="margin-left:25px"></canvas>
	*/

	var remix = module.exports = function(target) {
		
		this.defaultSize = { width: 400, height: 150 };
		widget.call(this, target);
		
		//define unique attributes
		this.maxLength = 2000;
		this.components = new Array();
		this.buffer = new Array();
		this.moment = 0;
		this.val = {
			x: 0.15,
			y: 0.5
		}
		this.rate = 1;
		this.start = 0;
		this.end = 1;
		this.size = 0;
		this.looping = false;
		this.boundLog = this.log.bind(this)
		this.init();

		this.boundAdv = this.advance.bind(this);
		nx.aniItems.push(this.boundAdv)

	}

	util.inherits(remix, widget);


	remix.prototype.init = function() {
		this.draw();
	}
		
		//sets a new component to be recorded
	remix.prototype.connect = function(target) {
		var compIndex = this.components.length;
		this.components.push(target);
		target.tapeNum = compIndex;
		target.isRecording = true;
		target.recorder = this;
		this.buffer[compIndex] = new Object();
		for (var key in target.val) {
			this.buffer[compIndex][key] = new Array();
		}
		
	}
		
		//the actual recording function
	remix.prototype.write = function(index, val) {
		if (this.moment>=this.maxLength) {
			this.stop();
		}
		for (var key in val) {
			if (this.buffer[index][key]) {
				this.buffer[index][key][this.moment] = val[key];
			}
		}
		this.draw();
	}
		

	remix.prototype.draw = function() {

		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height)
		}

		if (this.moment>= 0) {
			var nodeWid = this.width / this.moment
		} else {
			var nodeWid = this.width;
		}
		var nodeDrawWid = 5;
		
		var nodeX = this.moment*nodeWid+this.lineWidth/2;
		var nodeY;
		
		if (!this.recording) {
			with (this.context) {
				strokeStyle = this.colors.accent;
				lineWidth = 1;
				
				for (var i=0;i<this.buffer.length;i++) {
					for (var key in this.buffer[i]) {
						for (var j=0;j<this.buffer[i][key].length;j++) {
							pnodeX = (j-1)*nodeWid;
							pnodeY = Math.abs(this.buffer[i][key][j-1]-1)*(this.height);

							nodeX = j*nodeWid;
							nodeY = Math.abs(this.buffer[i][key][j]-1)*(this.height);
							
							beginPath()
								moveTo(pnodeX,pnodeY)
								lineTo(nodeX,nodeY)
								stroke()
							closePath();
							
						}
					}
					
				}
			}
		} else {

			with (this.context) {
				font = "bold "+this.height/3+"px gill sans";
				textAlign = "center";
				textBaseline = "middle"
				fillStyle = "#F00"
				fillText("rec",this.width/2,this.height/2);
			}
		}
	}

	remix.prototype.record = function() {
		this.moment = 0;
		nx.aniItems.push(this.boundLog)
		this.recording = true;
	}

	remix.prototype.log = function() {
		for (var i=0;i<this.components.length;i++) {
			var sender = this.components[i];
			this.write(this.components[i].tapeNum,this.components[i].val);
		}
		this.moment++;
	}

	remix.prototype.stop = function() {
		nx.removeAni(this.boundLog);
		this.size = this.moment;
		this.recording = false;
		this.draw();
	}

	remix.prototype.scan = function(x) {
		this.needle = x * this.size;
		this.needle = nx.clip(this.needle,0,this.size-1)
		if (this.needle) {
			for (var i=0;i<this.components.length;i++) {
				var sender = this.components[i];
				for (var key in this.buffer[sender.tapeNum]) {
					if (this.buffer[sender.tapeNum][key]) {
						var val = new Object();
						var max = this.buffer[sender.tapeNum][key][~~this.needle+1] ? this.buffer[sender.tapeNum][key][~~this.needle+1] : this.buffer[sender.tapeNum][key][~~this.needle]
						val[key] = nx.interp(this.needle - ~~this.needle, this.buffer[sender.tapeNum][key][~~this.needle], max)
						sender.set(val, true)
					}
				}
			}
		}
	}

	remix.prototype.play = function(rate,start,end) {
		rate ? this.rate = rate : null;
		if (start) {
			this.needle = start * this.size;
			this.start = start;
		} else {
			this.needle = 0;
			this.start = 0;
		} 
		end ? this.end = end : this.end = 1
		this.playing = true;
	}

	remix.prototype.loop = function() {
		
	}

	remix.prototype.advance = function() {
		if (this.playing) {
			this.needle += this.rate;
			if (this.needle/this.size < this.end) {
				this.scan(this.needle/this.size);
			} else if (this.looping) {
				this.needle = this.start;
			} else {
				this.playing = false;
			}
		}
	}
		

	remix.prototype.click = function(e) {
		if (this.size) {
			this.scan(this.clickPos.x/this.width)
		}
	}


	remix.prototype.move = function(e) {
		if (this.size) {
			this.scan(this.clickPos.x/this.width)
		}
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],31:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class select    
		HTML-style option selector. Outputs the chosen text string. <br> **Note:** Currently the canvas is actaully replaced by an HTML select object. Any inline style on your canvas may be lost in this transformation. To style the resultant select element, we recommend creating CSS styles for the select object using its ID or the select tag.
		```html
		<canvas nx="select" choices="sine,saw,square"></canvas>
		```
		<canvas nx="select" choices="sine,saw,square"></canvas>
	*/

	var select = module.exports = function (target) {
		this.defaultSize = { width: 200, height: 30 };
		widget.call(this, target);
		
		/** @property {array} choices Desired choices, as an array of strings. Can be initialized with a "choices" HTML attribute of comma-separated text (see example above). 
		```js
		select1.choices = ["PartA", "PartB", "GoNuts"]
		select1.init()
		```
		*/
		this.choices = [ ];

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *value* | Text string of option chosen
		*/
		this.val = new Object();
	}
	util.inherits(select, widget);

	select.prototype.init = function() {
		
		this.canvas.ontouchstart = null;
		this.canvas.ontouchmove = null;
		this.canvas.ontouchend = null;
		
		if (this.canvas.getAttribute("choices")) {
			this.choices = this.canvas.getAttribute("choices");
			this.choices = this.choices.split(",");
		}

		var htmlstr = '<select id="'+this.canvasID+'" style="height:'+this.height+'px;width:'+this.width+'px;font-size:'+this.height/2+'px;" onchange="'+this.canvasID+'.change(this)"></select><canvas height="1px" width="1px" style="display:none"></canvas>'                   
		var canv = this.canvas
		var cstyle = this.canvas.style
		var parent = canv.parentNode;
		var newdiv = document.createElement("span");
		newdiv.innerHTML = htmlstr;
		parent.replaceChild(newdiv,canv)
		this.sel = document.getElementById(this.canvasID)
		this.sel.style.float = "left"
		this.sel.style.display = "block"
		for (var prop in cstyle)
	    	this.sel.style[prop] = cstyle[prop];


		this.canvas = document.getElementById(this.canvasID);
		
		for (var i=0;i<this.choices.length;i++) {
			var option=document.createElement("option");
			option.text = this.choices[i];
			option.value = this.choices[i];
			this.canvas.add(option,null);
		}
		
	}

	// should have a modified "set" function
	select.prototype.change = function(thisselect) {
		this.val.text = thisselect.value;
		this.transmit(this.val);
	}
	},{"../core/widget":3,"util":44}],32:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class slider      
		Slider (vertical or horizontal)
		```html
		<canvas nx="slider"></canvas>
		```
		<canvas nx="slider" style="margin-left:25px"></canvas>
	*/

	var slider = module.exports = function (target) {
		this.defaultSize = { width: 30, height: 100 };
		widget.call(this, target);

		/** @property {object}  val   
			| &nbsp; | data
			| --- | ---
			| *value* | Slider value (float 0-1)
		*/
		this.val.value = 0.7

		/** @property {string}  mode   Set "absolute" or "relative" mode. In absolute mode, slider will jump to click/touch position. In relative mode, it will not.
		```js
		nx.onload = function() {
		&nbsp; // Slider will not jump to touch position.
		&nbsp; slider1.mode = "relative" 
		}
		```
		*/
		this.mode = "absolute";

		/** @property {boolean}  hslider   Whether or not the slider should be horizontal. This is set to true automatically if the canvas is wider than it is tall. To override the default decision, set this property to true to create a horizontal slider, or false to create a vertical slider.
		
		```js
		nx.onload = function() {
		&nbsp; //forces horizontal slider 
		&nbsp; slider1.hslider = true
		&nbsp; slider1.draw();
		&nbsp; //forces vertical slider 
		&nbsp; slider2.hslider = false
		&nbsp; slider2.draw();
		}
		```
		*/
		this.hslider = false;
		this.label = "";
		this.handle;
		this.relhandle;
		this.cap;


		this.init();
	}
	util.inherits(slider, widget);

	slider.prototype.init = function() {

		//decide if hslider or vslider
		if (this.height>=this.width) {
			this.hslider = false;
		} else {
			this.hslider = true;
		}

		if (this.canvas.getAttribute("label")!=null) {
			this.label = this.canvas.getAttribute("label");
		}

		this.draw();
	}

	slider.prototype.draw = function() {
		
		this.erase();
			
		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height);
		
			if (!this.hslider) {

				if (nx.showLabels) {

					save();
		 			translate(this.width/2, 0);
					rotate(Math.PI/2);
					this.setFont();
					fillText(this.label, this.height/2, 0);
					globalAlpha = 1;
					restore();
				
				}

				var x1 = 0;
				var y1 = this.height-this.val.value*this.height;
				var x2 = this.width;
				var y2 = this.height;

			
				fillStyle = this.colors.accent;
				if (this.val.value>0.01) {
					fillRect(x1,y1,x2-x1,y2-y1);
				}

			} else {
				
				if (nx.showLabels) {
					this.setFont();
					fillText(this.label, this.width/2, this.height/2);
					globalAlpha = 1;
				
				}

				var x1 = 0;
				var y1 = 0;
				var x2 = this.val.value*this.width;
				var y2 = this.height;
			   
			
				fillStyle = this.colors.accent;
				if (this.val.value>0.01) {
					fillRect(x1,y1,x2-x1,y2-y1);
				}
			}
		}
	}

	slider.prototype.click = function() {
		this.move();
	}

	slider.prototype.move = function() {
		if (this.hslider) {
			this.handle = this.clickPos.x;
			this.relhandle = this.deltaMove.x;
			this.cap = this.width;
		} else {
			this.handle = this.clickPos.y;
			this.relhandle = this.deltaMove.y*-1;
			this.cap = this.height
		}

		if (this.mode=="absolute") {
			if (this.clicked) {
				if (!this.hslider) {
					this.val.value = math.prune((Math.abs((math.clip(this.clickPos.y/this.height, 0, 1)) - 1)),3);
				} else {	
					this.val.value = math.prune(math.clip(this.clickPos.x/this.width, 0, 1),3);
				}
				this.draw();
			}
		} else if (this.mode=="relative") {
			if (this.clicked) {
				if (!this.hslider) {
					this.val.value = math.clip((this.val.value + ((this.deltaMove.y*-1)/this.height)),0,1);
				} else {
					this.val.value = math.clip((this.val.value + ((this.deltaMove.x)/this.width)),0,1);
				}
				this.draw();
			}
		}
		this.transmit(this.val);
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],33:[function(require,module,exports){
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class string      
		Animated model of a plucked string interface.
		```html
		<canvas nx="string"></canvas>
		```
		<canvas nx="string" style="margin-left:25px"></canvas>
	*/

	var string = module.exports = function (target) {
		this.defaultSize = { width: 150, height: 75 };
		widget.call(this, target);
		
		/** @property {object}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *string* | Index of the string that is plucked (starts at 0)
			| *x* | Where on the string the pluck occured (float 0-1);
		*/
		this.val = {
			string: 0,
			x: 0
		}
		/** @property {integer}  numberOfStrings How many strings in the widget. We recommend setting this property with .setStrings() */
		this.numberOfStrings = 10;
		this.strings = new Array();
		this.abovestring = new Array();
		/** @property {integer}  friction  How quickly the string slows down */
		this.friction = 1;
		
		var stringdiv;

		this.init();

		nx.aniItems.push(this.draw.bind(this));
	}
	util.inherits(string, widget);

	string.prototype.init = function() {
		stringdiv = this.height/(this.numberOfStrings + 1);
		for (var i=0;i<this.numberOfStrings;i++) {
			this.strings[i] = {
				x1: this.lineWidth,
				y1: stringdiv*(1+i),
				x2: this.width - this.lineWidth,
				y2: stringdiv*(i+1),
				held: false, // whether or not it's gripped
				vibrating: false, // whether or not its vibrating
				force: 0, // amount of force of pull on string
				maxstretch: 0, // vibration cap (in Y domain)
				stretch: 0, // current point vibrating in y domain
				direction: 0, // which direction it's vibrating
				above: false // is mouse above or below string
			};
		}
		this.draw();
	}

	string.prototype.pulse = function() {
		this.draw();
	}

	/* @method setStrings Sets how many strings are in the widget.
		```js
		string1.setStrings(20);
		``` 
		*/
	string.prototype.setStrings = function(val) {
		this.numberOfStrings = val;
		this.strings = new Array();
		this.init();
	}

	string.prototype.draw = function() {
		this.erase();
		this.makeRoundedBG();
		with (this.context) {
			strokeStyle = this.colors.border;
			fillStyle = this.colors.fill;
			lineWidth = this.lineWidth;
		//	stroke();
			fill();
			
			strokeStyle = this.colors.accent;

			for (var i = 0;i<this.strings.length;i++) {

				var st = this.strings[i];

				if (st.vibrating) {
					if (st.maxstretch < 0) {
						st.vibrating = false;
						st.held = false;
					}
					st.stretch = st.stretch + st.direction;
					
					if (Math.abs(st.stretch) > st.maxstretch) {
						//st.direction *= (-0.99);
						st.direction *= -1;
						st.stretch = st.stretch + st.direction;
						st.maxstretch = st.maxstretch - this.friction;

						st.direction = (st.direction / Math.abs(st.direction)) * (st.maxstretch/1)
					}

					beginPath();
					moveTo(st.x1, st.y1);
					quadraticCurveTo(this.width/2, st.y1+st.stretch, st.x2, st.y2);
					stroke();
					closePath();
					st.on = true;


				} else if (st.held) {
						//will draw rounded
						//if mouse is higher than string and gripup
						//or if mouse is 
						//	if (this.clickPos.y-st.y1<0 && st.gripup || this.clickPos.y-st.y1>0 && !st.gripup) {
						beginPath();
						moveTo(st.x1, st.y1);
						quadraticCurveTo(this.clickPos.x, this.clickPos.y, st.x2, st.y2);
						stroke();
						closePath();
						st.on = true;	
						/*	} else {
						beginPath();
						moveTo(st.x1, st.y1);
						lineTo(st.x2, st.y2);
						stroke();
						closePath();
					} */
				} else {
					beginPath();
					moveTo(st.x1, st.y1);
					lineTo(st.x2, st.y2);
					stroke();
					closePath();
					if (st.on) {
						st.on = false;
					}
				}
			}
		}
		this.drawLabel();
	}

	string.prototype.click = function() {
		for (var i = 0;i<this.numberOfStrings;i++) {
			this.strings[i].above = (this.clickPos.y<this.strings[i].y1);
		}
		this.draw();
	}

	string.prototype.move = function() {
		if (this.clicked) {
			for (var i = 0;i<this.strings.length;i++) {

				//if crosses string
				if (this.strings[i].above != (this.clickPos.y<this.strings[i].y1) ) {
					this.strings[i].held = true;
					this.strings[i].above ^= true;
				}

				if (this.strings[i].held && Math.abs(this.clickPos.y - this.strings[i].y1) > this.height/(this.strings.length*3)) {

					this.pluck(i)
					
				}
			}
		}
	}

	string.prototype.release = function() {
		for (var i = 0;i<this.strings.length;i++) {
			if (this.strings[i].held) {
				this.pluck(i);
			}
		}	
	}

	string.prototype.pluck = function(which) {
		var i = which;
		this.val = {
			string: i,
			x: this.clickPos.x/this.width
		}
		this.transmit(this.val);
		this.strings[i].held = false;
		this.strings[i].force = this.clickPos.y - this.strings[i].y1;
		this.strings[i].maxstretch = Math.abs(this.clickPos.y - this.strings[i].y1);
		this.strings[i].stretch = this.clickPos.y - this.strings[i].y1;
		this.strings[i].vibrating = true;
		this.strings[i].direction = (this.clickPos.y - this.strings[i].y1)/Math.abs(this.clickPos.y - this.strings[i].y1) * ((this.clickPos.y - this.strings[i].y1)/-1.2);
	}

	string.prototype.customDestroy = function() {
		nx.removeAni(this.draw.bind(this));
	}
	},{"../core/widget":3,"util":44}],34:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class tabs   
		
		```html
		<canvas nx="tabs"></canvas>
		```
		<canvas nx="tabs" style="margin-left:25px"></canvas>
	*/

	var tabs = module.exports = function(target) {
		
		this.defaultSize = { width: 150, height: 50 };
		widget.call(this, target);
		
		//define unique attributes
		this.choice = 0;
		this.val = {
			index: 0,
			text: ""
		}
		this.tabwid = 0;
		this.options = ["one", "two", "three"]
		//init
		this.init();

	}

	util.inherits(tabs, widget);


	tabs.prototype.init = function() {
		this.draw();
	}


	tabs.prototype.draw = function() {

		with (this.context) {
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height)

			textAlign = "center"
			textBaseline = "middle"
			font = "normal "+this.height/5+"px courier"
		}

		this.tabwid = this.width/this.options.length

		for (var i=0;i<this.options.length;i++) {
			if (i==this.choice) {
				var tabcol = this.colors.accent;
				var textcol = this.colors.white;
			} else {
				var tabcol = this.colors.fill;
				var textcol = this.colors.black;
				globalAlpha = 0.7;
			}
			with (this.context) {
				fillStyle=tabcol;
				fillRect(this.tabwid*i,0,this.tabwid,this.height)
				if (i!=this.options.length-1) {
					beginPath();
					moveTo(this.tabwid*(i+1),0)
					lineTo(this.tabwid*(i+1),this.height)
					lineWidth = 1;
					strokeStyle = this.colors.border
					stroke()
					closePath()
				}
				fillStyle=textcol;
				font = this.fontSize+"px "+this.font;
				fillText(this.options[i],this.tabwid*i+this.tabwid/2,this.height/2)
			}
			
		}
	}


	tabs.prototype.click = function() {
		this.choice = ~~(this.clickPos.x / this.tabwid);
		this.val = {
			index: this.choice,
			text: this.options[this.choice]
		}
		this.transmit(this.val)
		this.draw();
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],35:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class tilt      
		Mobile and Mac/Chrome-compatible tilt sensor. May not work on all devices! <br> **Notes:** Clicking on this widget toggles it inactive or active. <br>
		We recommend not calling .init() on this object after the original initialization, because it will add additional redundant tilt listeners to your document.
		```html
		<canvas nx="tilt"></canvas>
		```
		<canvas nx="tilt" style="margin-left:25px"></canvas>
	*/

	var tilt = module.exports = function (target) {
		this.defaultSize = { width: 50, height: 50 };
		widget.call(this, target);
		
		this.tiltLR;
		this.tiltFB;
		this.z;
		/** @property {boolean} active Whether or not the tilt widget is on (animating and transmitting data). */
		this.active = true;

		/** @property {object}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *x* | X-axis rotation if supported (-1 to 1)
			| *y* | Y-axis rotation if supported (-1 to 1)
			| *z* | Z-axis rotation if supported (-1 to 1 or possibly 0 to 360 depending on device)
		*/
		this.val = {
			x: 0,
			y: 0,
			z: 0
		}

		/** @property {string}  text   Text shown on tilt object
		*/
		
		this.text = "TILT";
		this.init();

		this.boundChromeTilt = this.chromeTilt.bind(this)
		this.boundMozTilt = this.mozTilt.bind(this)

		if (window.DeviceOrientationEvent) {
			window.addEventListener('deviceorientation', this.boundChromeTilt, false);
		} else if (window.OrientationEvent) {
		  	window.addEventListener('MozOrientation', this.boundMozTilt, false);
		} else {
		  	console.log("Not supported on your device or browser.")
		}
		
	}
	util.inherits(tilt, widget);

	tilt.prototype.deviceOrientationHandler = function() {
		
		this.val = {
			x: math.prune(this.tiltLR/90,3),
			y: math.prune(this.tiltFB/90,3),
			z: math.prune(this.z,3)
		}

		if (this.active) {
			this.transmit(this.val);
		}
		
	}

	tilt.prototype.chromeTilt = function(eventData) {
	    this.tiltLR = eventData.gamma;
			this.tiltFB = eventData.beta;
			this.z = eventData.alpha
	    this.deviceOrientationHandler();
	    this.draw();
	}

	tilt.prototype.mozTilt = function(eventData) {
	    this.tiltLR = eventData.x * 90;
	    // y is the front-to-back tilt from -1 to +1, so we need to convert to degrees
	    // We also need to invert the value so tilting the device towards us (forward) 
	    // results in a positive value. 
	    this.tiltFB = eventData.y * -90;
	    this.z = eventData.z;
	    this.deviceOrientationHandler();
	    this.draw();
	}

	tilt.prototype.init = function() {
		this.draw();
	}

	tilt.prototype.draw = function() {
		
		this.erase();

		with (this.context) {
			fillStyle = this.colors.fill;
		    fillRect(0,0,this.width,this.height);

			save(); 
			translate(this.width/2,this.height/2)
			rotate(-this.val.x*Math.PI/2);
			translate(-this.width/2,-this.height/2)
		    globalAlpha = 0.4;

		    if (this.active) {
		    	fillStyle = this.colors.accent;
		    } else {
		    	fillStyle = this.colors.border;
		    }

			fillRect(-this.width,this.height*(this.val.y/2)+this.height/2,this.width*3,this.height*2)
			font = "bold "+this.height/5+"px "+this.font;
			textAlign = "center";
			fillText(this.text, this.width/2, this.height*(this.val.y/2)+this.height/2+this.height/15);
			globalAlpha = 1;
			restore();
		}
		this.drawLabel();
	}

	tilt.prototype.click = function() {
		this.active = !this.active;
	}

	tilt.prototype.customDestroy = function() {
		this.active = false;
		window.removeEventListener("deviceorientation",this.boundChromeTilt,false);
		window.removeEventListener("mozOrientation",this.boundMozTilt,false);
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],36:[function(require,module,exports){
	var drawing = require('../utils/drawing');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class toggle      
		On/off toggle
		```html
		<canvas nx="toggle"></canvas>
		```
		<canvas nx="toggle" style="margin-left:25px"></canvas>
	*/

	var toggle = module.exports = function (target) {
		this.defaultSize = { width: 50, height: 50 };
		widget.call(this, target);
		
		this.mindim = this.height>this.width ? this.width : this.height;

		/** @property {object}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *value*| 1 if on, 0 if off
		*/
		this.val = {
			value: 0
		}
		this.init();
	}
	util.inherits(toggle, widget);

	toggle.prototype.init = function() {
		this.fontsize = this.mindim/4;
		this.draw();
	}

	toggle.prototype.draw = function() {
		
		this.erase()

		with (this.context) {
			if (this.val.value) {
				fillStyle = this.colors.accent;
			} else {
				fillStyle = this.colors.fill;
			}
			fillRect(0,0,this.width,this.height);
			if (this.val.value) {
				this.setFont();
				fillStyle = this.colors.white
				globalAlpha = 1;
				fillText("on", this.width/2, this.height/2);	
			} else {
				this.setFont();
				fillText("off", this.width/2, this.height/2);
				globalAlpha = 1;
			}
		}

		this.drawLabel();
		
	}

	toggle.prototype.click = function() {
		if (!this.val.value) {
			this.val.value = 1;
		} else {
			this.val.value = 0;
		}
		this.draw();
		this.transmit(this.val);
	}
	},{"../core/widget":3,"../utils/drawing":5,"util":44}],37:[function(require,module,exports){
	var drawing = require('../utils/drawing');
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class typewriter      
		Computer keyboard listener and visualization. (Desktop only) <br> **Note:** Clicking on the widget toggles it inactive or active, which can be useful if you need to temporarily type without triggering the widget's events.
		```html
		<canvas nx="typewriter"></canvas>
		```
		<canvas nx="typewriter" style="margin-left:25px"></canvas>
	*/

	var typewriter = module.exports = function (target) {
		this.defaultSize = { width: 300, height: 100 };
		widget.call(this, target);

		
		this.letter = ""
		this.keywid = this.width/14.5;
		this.keyhgt = this.height/5

		/** @property {boolean}  active  Whether or not the widget is on (listening for events and transmitting values).*/ 
		this.active = true;

		/** @property {object}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *key* | symbol of key pressed (example: "a")
			| *ascii* | ascii value of key pressed (example: 48)
			| *on* | 0 if key is being pressed, 1 if key is being released
		*/
		this.val = {
			key: "",
			ascii: 0,
			on: 0
		}

		this.rows = [
			[
				{ symbol: "`", value: 192, width: 1, on: false },
				{ symbol: "1", value: 49, width: 1, on: false  },
				{ symbol: "2", value: 50, width: 1, on: false  },
				{ symbol: "3", value: 51, width: 1, on: false  },
				{ symbol: "4", value: 52, width: 1, on: false  },
				{ symbol: "5", value: 53, width: 1, on: false  },
				{ symbol: "6", value: 54, width: 1, on: false  },
				{ symbol: "7", value: 55, width: 1, on: false  },
				{ symbol: "8", value: 56, width: 1, on: false  },
				{ symbol: "9", value: 57, width: 1, on: false  },
				{ symbol: "0", value: 48, width: 1, on: false  },
				{ symbol: "-", value: 189, width: 1, on: false  },
				{ symbol: "=", value: 187, width: 1, on: false  },
				{ symbol: "delete", value: 46, width: 1.5, on: false  }
			],
			[
				{ symbol: "tab", value: 10, width: 1.5, on: false  },
				{ symbol: "q", value: 81, width: 1, on: false  },
				{ symbol: "w", value: 87, width: 1, on: false  },
				{ symbol: "e", value: 69, width: 1, on: false  },
				{ symbol: "r", value: 82, width: 1, on: false  },
				{ symbol: "t", value: 84, width: 1, on: false  },
				{ symbol: "y", value: 89, width: 1, on: false  },
				{ symbol: "u", value: 85, width: 1, on: false  },
				{ symbol: "i", value: 73, width: 1, on: false  },
				{ symbol: "o", value: 79, width: 1, on: false  },
				{ symbol: "p", value: 80, width: 1, on: false  },
				{ symbol: "[", value: 219, width: 1, on: false  },
				{ symbol: "]", value: 221, width: 1, on: false  },
				{ symbol: "\\", value: 220, width: 1, on: false  }
			],
			[
				{ symbol: "caps", value: 20, width: 1.75, on: false  },
				{ symbol: "a", value: 65, width: 1, on: false  },
				{ symbol: "s", value: 83, width: 1, on: false  },
				{ symbol: "d", value: 68, width: 1, on: false  },
				{ symbol: "f", value: 70, width: 1, on: false  },
				{ symbol: "g", value: 71, width: 1, on: false  },
				{ symbol: "h", value: 72, width: 1, on: false  },
				{ symbol: "j", value: 74, width: 1, on: false  },
				{ symbol: "k", value: 75, width: 1, on: false  },
				{ symbol: "l", value: 76, width: 1, on: false  },
				{ symbol: ";", value: 186, width: 1, on: false  },
				{ symbol: "'", value: 222, width: 1, on: false  },
				{ symbol: "enter", value: 13, width: 1.75, on: false }
			],
			[
				{ symbol: "shift", value: 16, width: 2.25, on: false  },
				{ symbol: "z", value: 90, width: 1, on: false  },
				{ symbol: "x", value: 88, width: 1, on: false  },
				{ symbol: "c", value: 67, width: 1, on: false  },
				{ symbol: "v", value: 86, width: 1, on: false  },
				{ symbol: "b", value: 66, width: 1, on: false  },
				{ symbol: "n", value: 78, width: 1, on: false  },
				{ symbol: "m", value: 77, width: 1, on: false  },
				{ symbol: ",", value: 10, width: 1, on: false  },
				{ symbol: ".", value: 10, width: 1, on: false  },
				{ symbol: "/", value: 10, width: 1, on: false  },
				{ symbol: "shift", value: 16, width: 2.25, on: false }
			],
			[
				{ symbol: "fn", value: 10, width: 1, on: false  },
				{ symbol: "ctrl", value: 17, width: 1, on: false  },
				{ symbol: "opt", value: 10, width: 1, on: false  },
				{ symbol: "cmd", value: 10, width: 1.25, on: false  },
				{ symbol: "space", value: 32, width: 5, on: false  },
				{ symbol: "cmd", value: 10, width: 1, on: false  },
				{ symbol: "opt", value: 10, width: 1, on: false  },
				{ symbol: "<", value: 37, width: .81, on: false  },
				{ symbol: "^", value: 38, width: .81, on: false  },
				{ symbol: "v", value: 39, width: .81, on: false  },
				{ symbol: ">", value: 40, width: .81, on: false  }
			]
		]

		this.boundType = this.type.bind(this);
		this.boundUntype = this.untype.bind(this);
		window.addEventListener("keydown", this.boundType);
		window.addEventListener("keyup", this.boundUntype);

		this.init();
	}
	util.inherits(typewriter, widget);
		
	typewriter.prototype.init = function() {

		this.keywid = this.width/14.5;
		this.keyhgt = this.height/5
		
		this.draw();
	}

	typewriter.prototype.draw = function() {	// erase
		this.erase();

		if (!this.active) {
			this.context.globalAlpha = 0.4
		} else {
			this.context.globalAlpha = 1
		}

		with (this.context) {

			strokeStyle = this.colors.border 
			fillStyle = this.colors.accent 
			lineWidth = 1

			for (var i=0;i<this.rows.length;i++) {
				var currkeyL = 0;
				for (var j=0;j<this.rows[i].length;j++) {

					if (this.val.key==this.rows[i][j].symbol) {
						if (this.val.on) {
							this.rows[i][j].on = true;
						} else {
							this.rows[i][j].on = false;
						}
					}

					drawing.makeRoundRect(this.context, currkeyL , i*this.keyhgt,this.keywid*this.rows[i][j].width,this.keyhgt,4);
						
					if (this.rows[i][j].on) {
						fillStyle = this.colors.accent 
						strokeStyle = this.colors.accent 
						fill()
						stroke()
					} else {
						fillStyle = this.colors.fill 
						strokeStyle = this.colors.border 

						fill()
						stroke()
					}
		
					currkeyL += this.keywid*this.rows[i][j].width;

				}
			}

			if (this.val.on) {
				this.setFont();
				fillStyle = this.colors.border;
				font = this.height+"px "+this.font;
				fillText(this.val.key, this.width/2, this.height/2);
				
				globalAlpha = 1
			}

			if (!this.active) {
				globalAlpha = 0.7
				fillStyle = this.colors.border;
				font = (this.height/2)+"px courier";
				textAlign = "center";
				textBaseline = "middle"
				fillText("inactive", this.width/2, this.height/2);
			}
		}

		this.drawLabel();
	}

	typewriter.prototype.click = function(e) {
		this.active = !this.active;
		this.draw();
	}

	typewriter.prototype.type = function(e) {
		if (this.active) {
			var currKey = e.which;
			for (var i=0;i<this.rows.length;i++) {
				for (var j=0;j<this.rows[i].length;j++) {
					if (currKey == this.rows[i][j].value) {
						this.val.key = this.rows[i][j].symbol;
						this.val.on = 1;
						this.val.ascii = e.which;
						this.transmit(this.val);
						break;
					}
				}
			}
			this.draw();
		}	
	}

	typewriter.prototype.untype = function(e) {
		if (this.active) {
			var currKey = e.which;
			for (var i=0;i<this.rows.length;i++) {
				for (var j=0;j<this.rows[i].length;j++) {
					if (currKey == this.rows[i][j].value) {
					//	this.rows[i][j].on = false;
						this.val.key = this.rows[i][j].symbol;
						this.val.on = 0;
						this.val.ascii = e.which;
						this.transmit(this.val);
						break;
					}
				}
			}
			this.draw();
		}
	}

	typewriter.prototype.customDestroy = function() {
		window.removeEventListener("keydown", this.boundType);
		window.removeEventListener("keyup", this.boundUntype);
	}
	},{"../core/widget":3,"../utils/drawing":5,"util":44}],38:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class vinyl      
		For the boom bap
		```html
		<canvas nx="vinyl"></canvas>
		```
		<canvas nx="vinyl" style="margin-left:25px"></canvas>
	*/

	var vinyl = module.exports = function (target) {
		this.defaultSize = { width: 100, height: 100 };
		widget.call(this, target);
		
		this.circleSize;

		/** @property speed The rotation increment. Default is 0.05. Not to be confused with .val.speed (see below) which is the data output. During rotation, .speed will always move towards .defaultSpeed */
		this.speed = 0.05;
		/** @property defaultSpeed The "steady-state" rotation increment. Default is 0.05. During rotation, if .speed is changed, it will gradually move towards this. */
		this.defaultspeed = 0.05
		this.rotation = 0;
		this.hasMovedOnce = false;
		/** @property {float}  val  Object containing the core interactive aspects of the widget, which are also its data output. Has the following properties: 
			| &nbsp; | data
			| --- | ---
			| *speed*| Current speed of the record player's rotation (normal is 1)
		*/
		this.val = {
			speed: 0
		}
		this.init();
		nx.aniItems.push(this.spin.bind(this));
	}
	util.inherits(vinyl, widget);

	vinyl.prototype.init = function() {

		this.circleSize = (Math.min(this.center.x, this.center.y)-this.lineWidth);
		this.draw();
	}

	vinyl.prototype.draw = function() {
		this.erase()

		with (this.context) {
			strokeStyle = this.colors.border;
			fillStyle = this.colors.fill;
			fillRect(0,0,this.width,this.height)
			
			//draw main circle
			beginPath();
			fillStyle = this.colors.black;
			arc(this.center.x, this.center.y, this.circleSize-5, 0, Math.PI*2, true);
			fill();
			closePath();


			//draw circle in center
			beginPath();
			fillStyle = this.colors.accent;
			arc(this.center.x, this.center.y*1, this.circleSize/4, 0, Math.PI*2, false);
			fill()
			closePath();


			//draw tint
			beginPath();
			globalAlpha = 0.5;
			fillStyle = this.colors.fill;
			arc(this.center.x, this.center.y, this.circleSize, this.rotation, this.rotation + 0.4, false);
			lineTo(this.center.x, this.center.y);
			arc(this.center.x, this.center.y, this.circleSize, this.rotation+Math.PI, this.rotation +Math.PI+ 0.4, false);
			lineTo(this.center.x, this.center.y);
			fill();
			globalAlpha = 1;
			closePath(); 


			//draw white circle in center
			beginPath();
			fillStyle = this.colors.white;
			arc(this.center.x, this.center.y*1, this.circleSize/16, 0, Math.PI*2, false);
			fill()
			closePath(); 

		}

		this.drawLabel();
	}

	vinyl.prototype.click = function(e) {
		this.hasMovedOnce = false;
		this.lastRotation = this.rotation
		this.grabAngle = this.rotation % (Math.PI*2)
		this.grabPos = math.toPolar(this.clickPos.x-this.center.x,this.clickPos.y-this.center.y).angle

	}

	vinyl.prototype.move = function() {

		if (!this.hasMovedOnce) {
			this.hasMovedOnce = true;
			this.grabAngle = this.rotation % (Math.PI*2)
			this.grabPos = math.toPolar(this.clickPos.x-this.center.x,this.clickPos.y-this.center.y).angle
		}

		this.rotation = math.toPolar(this.clickPos.x-this.center.x,this.clickPos.y-this.center.y).angle + this.grabAngle - this.grabPos	


	}

	vinyl.prototype.release = function() {
		this.speed = ((this.rotation - this.lastRotation) + (this.lastRotation-this.lastRotation2))/2 ;
	}

	vinyl.prototype.spin = function() {

		if (this.clicked) { 
			this.speed /= 1.1;
		} else {
			this.speed = this.speed*0.9 + this.defaultspeed*0.1
		}

		// may need to math.clip(this.val.speed,-10,10);
		this.val.speed = (this.rotation - this.lastRotation) * 20; // normalizes it to 1

		this.lastRotation2 = this.lastRotation
		this.lastRotation = this.rotation

		this.rotation += this.speed

		this.draw();

		this.transmit(this.val)
		
	}

	vinyl.prototype.customDestroy = function() {
		nx.removeAni(this.spin.bind(this));
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],39:[function(require,module,exports){
	var math = require('../utils/math')
	var util = require('util');
	var widget = require('../core/widget');

	/** 
		@class windows      
		Scalable windows
		```html
		<canvas nx="windows"></canvas>
		```
		<canvas nx="windows" style="margin-left:25px"></canvas>
	*/

	var windows = module.exports = function (target) {

		this.defaultSize = { width: 200, height: 200 };

		widget.call(this, target);

		this.val = {}

		this.items = []
		this.size = 30;
		this.meta = false;
		this.resizing = false;
		
		this.init();

		document.addEventListener('keydown',function(e) {
			this.meta = true;
			this.draw();
		}.bind(this))
		document.addEventListener('keyup',function(e) {
			this.meta = false;
			this.draw();
		}.bind(this))
	}
	util.inherits(windows, widget);

	windows.prototype.init = function() {
		this.draw();
	}

	windows.prototype.draw = function() {
		this.erase();
		with (this.context) {

			if (!this.meta) {
				fillStyle = this.colors.fill;
			} else {
				fillStyle = this.colors.border;
			}

			fillRect(0,0,this.width,this.height);
		
			for (var i=0;i<this.items.length;i++) {
				fillStyle = this.colors.accent;
				fillRect(this.items[i].x-this.items[i].w/2,this.items[i].y-this.items[i].h/2,this.items[i].w,this.items[i].h)
			    
				strokeStyle = this.colors.fill;
				lineWidth = 1;
			    strokeRect(this.items[i].x+this.items[i].w/2-10,this.items[i].y+this.items[i].h/2-10,10,10)
			
			}

		}
		
		this.drawLabel();
	}

	windows.prototype.click = function() {
		this.holds = false;
		for (var i=0;i<this.items.length;i++) {
			if (nx.isInside({x:this.clickPos.x+this.items[i].w/2,y:this.clickPos.y+this.items[i].h/2 },this.items[i])) {
				this.holds = i;
				if (this.clickPos.x > this.items[i].x + this.items[i].w/2 - 10 && this.clickPos.x < this.items[i].x + this.items[i].w/2 && this.clickPos.y > this.items[i].y + this.items[i].h/2 - 10 && this.clickPos.y < this.items[i].y + this.items[i].h/2) {
					this.resizing = true;
				}
			}
		}
		if (this.holds===false) {
			this.items.push({
				x: ~~((this.clickPos.x)/5)*5,
				y: ~~((this.clickPos.y)/5)*5,
				w: this.size,
				h: this.size
			})
			this.holds = this.items.length-1;
			this.hasMoved = true;
			this.val = {
				add: this.items[this.holds],
				items: this.items
			}
			this.transmit(this.val)
		}
		if (this.meta) {
			for (var i=0;i<this.items.length;i++) {
				this.items[i].tx = this.items[i].x
				this.items[i].ty = this.items[i].y
			}
			this.tx = this.clickPos.x
			this.ty = this.clickPos.y
		}
		this.draw();
	}

	windows.prototype.move = function() {
		if (this.resizing) {
			if (!this.meta) {
				this.items[this.holds].w = this.clickPos.x + this.items[this.holds].w/2 - this.items[this.holds].x
				this.items[this.holds].h = this.clickPos.y + this.items[this.holds].h/2 - this.items[this.holds].y
			} else {
				for (var i=0;i<this.items.length;i++) {
					this.items[i].w = this.clickPos.x + this.items[this.holds].w/2 - this.items[this.holds].x
					this.items[i].h = this.clickPos.y + this.items[this.holds].h/2 - this.items[this.holds].y
				}
			}
		} else {
			if (!this.meta) {
				this.items[this.holds].x = ~~((this.clickPos.x)/5)*5;
				this.items[this.holds].y = ~~((this.clickPos.y)/5)*5;	
			} else {
				for (var i=0;i<this.items.length;i++) {
					this.items[i].x = (~~((this.clickPos.x)/5)*5 - this.tx) + this.items[i].tx;
					this.items[i].y = (~~((this.clickPos.y)/5)*5 - this.ty) + this.items[i].ty;	
				}
			}	
		}
		
		this.val = {
			change: true,
			items: this.items
		}
		this.transmit(this.val)
		this.draw();
	}

	windows.prototype.release = function() {
		if (!this.hasMoved) {
			if (this.meta) {
				this.val = {
					remove: "all",
					items: this.items
				}
				this.items = []
			} else {
				this.val = {
					remove: this.holds,
					items: this.items
				}
				this.items.splice(this.holds,1)
			}
		}
		this.resizing = false;
		this.transmit(this.val);
		this.draw();
	}
	},{"../core/widget":3,"../utils/math":6,"util":44}],40:[function(require,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	},{}],41:[function(require,module,exports){
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}

	},{}],42:[function(require,module,exports){
	// shim for using process in browser

	var process = module.exports = {};

	process.nextTick = (function () {
	    var canSetImmediate = typeof window !== 'undefined'
	    && window.setImmediate;
	    var canPost = typeof window !== 'undefined'
	    && window.postMessage && window.addEventListener
	    ;

	    if (canSetImmediate) {
	        return function (f) { return window.setImmediate(f) };
	    }

	    if (canPost) {
	        var queue = [];
	        window.addEventListener('message', function (ev) {
	            var source = ev.source;
	            if ((source === window || source === null) && ev.data === 'process-tick') {
	                ev.stopPropagation();
	                if (queue.length > 0) {
	                    var fn = queue.shift();
	                    fn();
	                }
	            }
	        }, true);

	        return function nextTick(fn) {
	            queue.push(fn);
	            window.postMessage('process-tick', '*');
	        };
	    }

	    return function nextTick(fn) {
	        setTimeout(fn, 0);
	    };
	})();

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	}

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};

	},{}],43:[function(require,module,exports){
	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}
	},{}],44:[function(require,module,exports){
	(function (process,global){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = require('./support/isBuffer');

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	exports.inherits = require('inherits');

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./support/isBuffer":43,"_process":42,"inherits":41}],45:[function(require,module,exports){
	var hasOwn = Object.prototype.hasOwnProperty;
	var toString = Object.prototype.toString;
	var undefined;

	var isPlainObject = function isPlainObject(obj) {
		'use strict';
		if (!obj || toString.call(obj) !== '[object Object]') {
			return false;
		}

		var has_own_constructor = hasOwn.call(obj, 'constructor');
		var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) {}

		return key === undefined || hasOwn.call(obj, key);
	};

	module.exports = function extend() {
		'use strict';
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0],
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
			target = {};
		}

		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && Array.isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = extend(deep, clone, copy);

					// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};


	},{}]},{},[1]);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* global module, Tone */


	var tone = new Tone();

	module.exports = {
	  midiToNote: tone.midiToNote.bind(tone),
	  noteToMidi: tone.noteToMidi.bind(tone)
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * @license
	 * lodash 3.10.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern -d -o ./index.js`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;

	  /** Used as the semantic version number. */
	  var VERSION = '3.10.0';

	  /** Used to compose bitmasks for wrapper metadata. */
	  var BIND_FLAG = 1,
	      BIND_KEY_FLAG = 2,
	      CURRY_BOUND_FLAG = 4,
	      CURRY_FLAG = 8,
	      CURRY_RIGHT_FLAG = 16,
	      PARTIAL_FLAG = 32,
	      PARTIAL_RIGHT_FLAG = 64,
	      ARY_FLAG = 128,
	      REARG_FLAG = 256;

	  /** Used as default options for `_.trunc`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect when a function becomes hot. */
	  var HOT_COUNT = 150,
	      HOT_SPAN = 16;

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2;

	  /** Used as the `TypeError` message for "Functions" methods. */
	  var FUNC_ERROR_TEXT = 'Expected a function';

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      objectTag = '[object Object]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      weakMapTag = '[object WeakMap]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
	      reUnescapedHtml = /[&<>"'`]/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

	  /**
	   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)
	   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).
	   */
	  var reRegExpChars = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g,
	      reHasRegExpChars = RegExp(reRegExpChars.source);

	  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */
	  var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect hexadecimal string values. */
	  var reHasHexPrefix = /^0[xX]/;

	  /** Used to detect host constructors (Safari > 5). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^\d+$/;

	  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
	  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to match words to create compound words. */
	  var reWords = (function() {
	    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
	        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

	    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
	  }());

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
	    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',
	    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
	  cloneableTags[dateTag] = cloneableTags[float32Tag] =
	  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
	  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[stringTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[mapTag] = cloneableTags[setTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map latin-1 supplementary letters to basic latin letters. */
	  var deburredLetters = {
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;',
	    '`': '&#96;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'",
	    '&#96;': '`'
	  };

	  /** Used to determine if values are of the language type `Object`. */
	  var objectTypes = {
	    'function': true,
	    'object': true
	  };

	  /** Used to escape characters for inclusion in compiled regexes. */
	  var regexpEscapes = {
	    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',
	    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',
	    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',
	    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',
	    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Detect free variable `exports`. */
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;

	  /** Detect free variable `self`. */
	  var freeSelf = objectTypes[typeof self] && self && self.Object && self;

	  /** Detect free variable `window`. */
	  var freeWindow = objectTypes[typeof window] && window && window.Object && window;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

	  /**
	   * Used as a reference to the global object.
	   *
	   * The `this` value is used if it's the global object to avoid Greasemonkey's
	   * restricted `window` object, otherwise the `window` object is used.
	   */
	  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The base implementation of `compareAscending` which compares values and
	   * sorts them in ascending order without guaranteeing a stable sort.
	   *
	   * @private
	   * @param {*} value The value to compare.
	   * @param {*} other The other value to compare.
	   * @returns {number} Returns the sort order indicator for `value`.
	   */
	  function baseCompareAscending(value, other) {
	    if (value !== other) {
	      var valIsNull = value === null,
	          valIsUndef = value === undefined,
	          valIsReflexive = value === value;

	      var othIsNull = other === null,
	          othIsUndef = other === undefined,
	          othIsReflexive = other === other;

	      if ((value > other && !othIsNull) || !valIsReflexive ||
	          (valIsNull && !othIsUndef && othIsReflexive) ||
	          (valIsUndef && othIsReflexive)) {
	        return 1;
	      }
	      if ((value < other && !valIsNull) || !othIsReflexive ||
	          (othIsNull && !valIsUndef && valIsReflexive) ||
	          (othIsUndef && valIsReflexive)) {
	        return -1;
	      }
	    }
	    return 0;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromRight) {
	    var length = array.length,
	        index = fromRight ? length : -1;

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without support for binary searches.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    if (value !== value) {
	      return indexOfNaN(array, fromIndex);
	    }
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isFunction` without support for environments
	   * with incorrect `typeof` results.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	   */
	  function baseIsFunction(value) {
	    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
	    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
	    return typeof value == 'function' || false;
	  }

	  /**
	   * Converts `value` to a string if it's not one. An empty string is returned
	   * for `null` or `undefined` values.
	   *
	   * @private
	   * @param {*} value The value to process.
	   * @returns {string} Returns the string.
	   */
	  function baseToString(value) {
	    return value == null ? '' : (value + '');
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the first character not found in `chars`.
	   */
	  function charsLeftIndex(string, chars) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last character
	   * of `string` that is not found in `chars`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @param {string} chars The characters to find.
	   * @returns {number} Returns the index of the last character not found in `chars`.
	   */
	  function charsRightIndex(string, chars) {
	    var index = string.length;

	    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.sortBy` to compare transformed elements of a collection and stable
	   * sort them in ascending order.
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareAscending(object, other) {
	    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
	  }

	  /**
	   * Used by `_.sortByOrder` to compare multiple properties of a value to another
	   * and stable sort them.
	   *
	   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,
	   * a value is sorted in ascending order if its corresponding order is "asc", and
	   * descending if "desc".
	   *
	   * @private
	   * @param {Object} object The object to compare.
	   * @param {Object} other The other object to compare.
	   * @param {boolean[]} orders The order to sort by for each property.
	   * @returns {number} Returns the sort order indicator for `object`.
	   */
	  function compareMultiple(object, other, orders) {
	    var index = -1,
	        objCriteria = object.criteria,
	        othCriteria = other.criteria,
	        length = objCriteria.length,
	        ordersLength = orders.length;

	    while (++index < length) {
	      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
	      if (result) {
	        if (index >= ordersLength) {
	          return result;
	        }
	        var order = orders[index];
	        return result * ((order === 'asc' || order === true) ? 1 : -1);
	      }
	    }
	    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	    // that causes it, under certain circumstances, to provide the same value for
	    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	    // for more details.
	    //
	    // This also ensures a stable sort in V8 and other engines.
	    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
	    return object.index - other.index;
	  }

	  /**
	   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  function deburrLetter(letter) {
	    return deburredLetters[letter];
	  }

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeHtmlChar(chr) {
	    return htmlEscapes[chr];
	  }

	  /**
	   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @param {string} leadingChar The capture group for a leading character.
	   * @param {string} whitespaceChar The capture group for a whitespace character.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {
	    if (leadingChar) {
	      chr = regexpEscapes[chr];
	    } else if (whitespaceChar) {
	      chr = stringEscapes[chr];
	    }
	    return '\\' + chr;
	  }

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the index at which the first occurrence of `NaN` is found in `array`.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
	   */
	  function indexOfNaN(array, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 0 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      var other = array[index];
	      if (other !== other) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * Checks if `value` is object-like.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	   */
	  function isObjectLike(value) {
	    return !!value && typeof value == 'object';
	  }

	  /**
	   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
	   * character code is whitespace.
	   *
	   * @private
	   * @param {number} charCode The character code to inspect.
	   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
	   */
	  function isSpace(charCode) {
	    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
	      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      if (array[index] === placeholder) {
	        array[index] = PLACEHOLDER;
	        result[++resIndex] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * An implementation of `_.uniq` optimized for sorted arrays without support
	   * for callback shorthands and `this` binding.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} [iteratee] The function invoked per iteration.
	   * @returns {Array} Returns the new duplicate-value-free array.
	   */
	  function sortedUniq(array, iteratee) {
	    var seen,
	        index = -1,
	        length = array.length,
	        resIndex = -1,
	        result = [];

	    while (++index < length) {
	      var value = array[index],
	          computed = iteratee ? iteratee(value, index, array) : value;

	      if (!index || seen !== computed) {
	        seen = computed;
	        result[++resIndex] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the first non-whitespace character.
	   */
	  function trimmedLeftIndex(string) {
	    var index = -1,
	        length = string.length;

	    while (++index < length && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
	   * character of `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the index of the last non-whitespace character.
	   */
	  function trimmedRightIndex(string) {
	    var index = string.length;

	    while (index-- && isSpace(string.charCodeAt(index))) {}
	    return index;
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  function unescapeHtmlChar(chr) {
	    return htmlUnescapes[chr];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the given `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @category Utility
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // using `context` to mock `Date#getTime` use in `_.now`
	   * var mock = _.runInContext({
	   *   'Date': function() {
	   *     return { 'getTime': getTimeMock };
	   *   }
	   * });
	   *
	   * // or creating a suped-up `defer` in Node.js
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  function runInContext(context) {
	    // Avoid issues with some ES3 environments that attempt to use values, named
	    // after built-in constructors like `Object`, for the creation of literals.
	    // ES5 clears this up by stating that literals must use built-in constructors.
	    // See https://es5.github.io/#x11.1.5 for more details.
	    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

	    /** Native constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Number = context.Number,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for native method references. */
	    var arrayProto = Array.prototype,
	        objectProto = Object.prototype,
	        stringProto = String.prototype;

	    /** Used to resolve the decompiled source of functions. */
	    var fnToString = Function.prototype.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /**
	     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var objToString = objectProto.toString;

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Native method references. */
	    var ArrayBuffer = context.ArrayBuffer,
	        clearTimeout = context.clearTimeout,
	        parseFloat = context.parseFloat,
	        pow = Math.pow,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        Set = getNative(context, 'Set'),
	        setTimeout = context.setTimeout,
	        splice = arrayProto.splice,
	        Uint8Array = context.Uint8Array,
	        WeakMap = getNative(context, 'WeakMap');

	    /* Native method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeCreate = getNative(Object, 'create'),
	        nativeFloor = Math.floor,
	        nativeIsArray = getNative(Array, 'isArray'),
	        nativeIsFinite = context.isFinite,
	        nativeKeys = getNative(Object, 'keys'),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = getNative(Date, 'now'),
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random;

	    /** Used as references for `-Infinity` and `Infinity`. */
	    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
	        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

	    /** Used as references for the maximum length and index of an array. */
	    var MAX_ARRAY_LENGTH = 4294967295,
	        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	    /**
	     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	     * of an array-like value.
	     */
	    var MAX_SAFE_INTEGER = 9007199254740991;

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
	     * Methods that operate on and return arrays, collections, and functions can
	     * be chained together. Methods that retrieve a single value or may return a
	     * primitive value will automatically end the chain returning the unwrapped
	     * value. Explicit chaining may be enabled using `_.chain`. The execution of
	     * chained methods is lazy, that is, execution is deferred until `_#value`
	     * is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
	     * fusion is an optimization strategy which merge iteratee calls; this can help
	     * to avoid the creation of intermediate data structures and greatly reduce the
	     * number of iteratee executions.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
	     * `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
	     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
	     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
	     * and `where`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
	     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
	     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,
	     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,
	     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,
	     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
	     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
	     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,
	     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,
	     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
	     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
	     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,
	     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,
	     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,
	     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,
	     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,
	     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,
	     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,
	     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,
	     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,
	     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
	     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,
	     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,
	     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,
	     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,
	     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,
	     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,
	     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,
	     * `unescape`, `uniqueId`, `value`, and `words`
	     *
	     * The wrapper method `sample` will return a wrapped value when `n` is provided,
	     * otherwise an unwrapped value is returned.
	     *
	     * @name _
	     * @constructor
	     * @category Chain
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // returns an unwrapped value
	     * wrapped.reduce(function(total, n) {
	     *   return total + n;
	     * });
	     * // => 6
	     *
	     * // returns a wrapped value
	     * var squares = wrapped.map(function(n) {
	     *   return n * n;
	     * });
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The function whose prototype all chaining wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
	     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
	     */
	    function LodashWrapper(value, chainAll, actions) {
	      this.__wrapped__ = value;
	      this.__actions__ = actions || [];
	      this.__chain__ = !!chainAll;
	    }

	    /**
	     * An object environment feature flags.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    var support = lodash.support = {};

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type Object
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type RegExp
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type string
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type Object
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type Function
	         */
	        '_': lodash
	      }
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = POSITIVE_INFINITY;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = arrayCopy(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = arrayCopy(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = arrayCopy(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {
	        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a cache object to store key/value pairs.
	     *
	     * @private
	     * @static
	     * @name Cache
	     * @memberOf _.memoize
	     */
	    function MapCache() {
	      this.__data__ = {};
	    }

	    /**
	     * Removes `key` and its value from the cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
	     */
	    function mapDelete(key) {
	      return this.has(key) && delete this.__data__[key];
	    }

	    /**
	     * Gets the cached value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the cached value.
	     */
	    function mapGet(key) {
	      return key == '__proto__' ? undefined : this.__data__[key];
	    }

	    /**
	     * Checks if a cached value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapHas(key) {
	      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
	    }

	    /**
	     * Sets `value` to `key` of the cache.
	     *
	     * @private
	     * @name set
	     * @memberOf _.memoize.Cache
	     * @param {string} key The key of the value to cache.
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache object.
	     */
	    function mapSet(key, value) {
	      if (key != '__proto__') {
	        this.__data__[key] = value;
	      }
	      return this;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates a cache object to store unique values.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var length = values ? values.length : 0;

	      this.data = { 'hash': nativeCreate(null), 'set': new Set };
	      while (length--) {
	        this.push(values[length]);
	      }
	    }

	    /**
	     * Checks if `value` is in `cache` mimicking the return signature of
	     * `_.indexOf` by returning `0` if the value is found, else `-1`.
	     *
	     * @private
	     * @param {Object} cache The cache to search.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `0` if `value` is found, else `-1`.
	     */
	    function cacheIndexOf(cache, value) {
	      var data = cache.data,
	          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

	      return result ? 0 : -1;
	    }

	    /**
	     * Adds `value` to the cache.
	     *
	     * @private
	     * @name push
	     * @memberOf SetCache
	     * @param {*} value The value to cache.
	     */
	    function cachePush(value) {
	      var data = this.data;
	      if (typeof value == 'string' || isObject(value)) {
	        data.set.add(value);
	      } else {
	        data.hash[value] = true;
	      }
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a new array joining `array` with `other`.
	     *
	     * @private
	     * @param {Array} array The array to join.
	     * @param {Array} other The other array to join.
	     * @returns {Array} Returns the new concatenated array.
	     */
	    function arrayConcat(array, other) {
	      var index = -1,
	          length = array.length,
	          othIndex = -1,
	          othLength = other.length,
	          result = Array(length + othLength);

	      while (++index < length) {
	        result[index] = array[index];
	      }
	      while (++othIndex < othLength) {
	        result[index++] = other[othIndex];
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayCopy(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEach` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEach(array, iteratee) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (iteratee(array[index], index, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.forEachRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayEachRight(array, iteratee) {
	      var length = array.length;

	      while (length--) {
	        if (iteratee(array[length], length, array) === false) {
	          break;
	        }
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.every` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     */
	    function arrayEvery(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (!predicate(array[index], index, array)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`
	     * with one argument: (value).
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function arrayExtremum(array, iteratee, comparator, exValue) {
	      var index = -1,
	          length = array.length,
	          computed = exValue,
	          result = computed;

	      while (++index < length) {
	        var value = array[index],
	            current = +iteratee(value);

	        if (comparator(current, computed)) {
	          computed = current;
	          result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.filter` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function arrayFilter(array, predicate) {
	      var index = -1,
	          length = array.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.map` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function arrayMap(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = iteratee(array[index], index, array);
	      }
	      return result;
	    }

	    /**
	     * Appends the elements of `values` to `array`.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to append.
	     * @returns {Array} Returns `array`.
	     */
	    function arrayPush(array, values) {
	      var index = -1,
	          length = values.length,
	          offset = array.length;

	      while (++index < length) {
	        array[offset + index] = values[index];
	      }
	      return array;
	    }

	    /**
	     * A specialized version of `_.reduce` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the first element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduce(array, iteratee, accumulator, initFromArray) {
	      var index = -1,
	          length = array.length;

	      if (initFromArray && length) {
	        accumulator = array[++index];
	      }
	      while (++index < length) {
	        accumulator = iteratee(accumulator, array[index], index, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.reduceRight` for arrays without support for
	     * callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {boolean} [initFromArray] Specify using the last element of `array`
	     *  as the initial value.
	     * @returns {*} Returns the accumulated value.
	     */
	    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
	      var length = array.length;
	      if (initFromArray && length) {
	        accumulator = array[--length];
	      }
	      while (length--) {
	        accumulator = iteratee(accumulator, array[length], length, array);
	      }
	      return accumulator;
	    }

	    /**
	     * A specialized version of `_.some` for arrays without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function arraySome(array, predicate) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        if (predicate(array[index], index, array)) {
	          return true;
	        }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `_.sum` for arrays without support for callback
	     * shorthands and `this` binding..
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function arraySum(array, iteratee) {
	      var length = array.length,
	          result = 0;

	      while (length--) {
	        result += +iteratee(array[length]) || 0;
	      }
	      return result;
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assign` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : objectValue;
	    }

	    /**
	     * Used by `_.template` to customize its `_.assign` use.
	     *
	     * **Note:** This function is like `assignDefaults` except that it ignores
	     * inherited property values when checking if a property is `undefined`.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @param {string} key The key associated with the object and source values.
	     * @param {Object} object The destination object.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function assignOwnDefaults(objectValue, sourceValue, key, object) {
	      return (objectValue === undefined || !hasOwnProperty.call(object, key))
	        ? sourceValue
	        : objectValue;
	    }

	    /**
	     * A specialized version of `_.assign` for customizing assigned values without
	     * support for argument juggling, multiple sources, and `this` binding `customizer`
	     * functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     */
	    function assignWith(object, source, customizer) {
	      var index = -1,
	          props = keys(source),
	          length = props.length;

	      while (++index < length) {
	        var key = props[index],
	            value = object[key],
	            result = customizer(value, source[key], key, object, source);

	        if ((result === result ? (result !== value) : (value === value)) ||
	            (value === undefined && !(key in object))) {
	          object[key] = result;
	        }
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.assign` without support for argument juggling,
	     * multiple sources, and `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return source == null
	        ? object
	        : baseCopy(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `_.at` without support for string collections
	     * and individual key arguments.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {number[]|string[]} props The property names or indexes of elements to pick.
	     * @returns {Array} Returns the new array of picked elements.
	     */
	    function baseAt(collection, props) {
	      var index = -1,
	          isNil = collection == null,
	          isArr = !isNil && isArrayLike(collection),
	          length = isArr ? collection.length : 0,
	          propsLength = props.length,
	          result = Array(propsLength);

	      while(++index < propsLength) {
	        var key = props[index];
	        if (isArr) {
	          result[index] = isIndex(key, length) ? collection[key] : undefined;
	        } else {
	          result[index] = isNil ? undefined : collection[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property names to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @returns {Object} Returns `object`.
	     */
	    function baseCopy(source, props, object) {
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];
	        object[key] = source[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `_.callback` which supports specifying the
	     * number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function baseCallback(func, thisArg, argCount) {
	      var type = typeof func;
	      if (type == 'function') {
	        return thisArg === undefined
	          ? func
	          : bindCallback(func, thisArg, argCount);
	      }
	      if (func == null) {
	        return identity;
	      }
	      if (type == 'object') {
	        return baseMatches(func);
	      }
	      return thisArg === undefined
	        ? property(func)
	        : baseMatchesProperty(func, thisArg);
	    }

	    /**
	     * The base implementation of `_.clone` without support for argument juggling
	     * and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The object `value` belongs to.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates clones with source counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
	      var result;
	      if (customizer) {
	        result = object ? customizer(value, key, object) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return arrayCopy(value, result);
	        }
	      } else {
	        var tag = objToString.call(value),
	            isFunc = tag == funcTag;

	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = initCloneObject(isFunc ? {} : value);
	          if (!isDeep) {
	            return baseAssign(result, value);
	          }
	        } else {
	          return cloneableTags[tag]
	            ? initCloneByTag(value, tag, isDeep)
	            : (object ? value : {});
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == value) {
	          return stackB[length];
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate it with its clone.
	      stackA.push(value);
	      stackB.push(result);

	      // Recursively populate clone (susceptible to call stack limits).
	      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
	        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} prototype The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(prototype) {
	        if (isObject(prototype)) {
	          object.prototype = prototype;
	          var result = new object;
	          object.prototype = undefined;
	        }
	        return result || {};
	      };
	    }());

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts an index
	     * of where to slice the arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Object} args The arguments provide to `func`.
	     * @returns {number} Returns the timer id.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }

	    /**
	     * The base implementation of `_.difference` which accepts a single array
	     * of values to exclude.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values) {
	      var length = array ? array.length : 0,
	          result = [];

	      if (!length) {
	        return result;
	      }
	      var index = -1,
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,
	          valuesLength = values.length;

	      if (cache) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	        values = cache;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index];

	        if (isCommon && value === value) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === value) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (indexOf(values, value, 0) < 0) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object|string} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * Gets the extremum value of `collection` invoking `iteratee` for each value
	     * in `collection` to generate the criterion by which the value is ranked.
	     * The `iteratee` is invoked with three arguments: (value, index|key, collection).
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(collection, iteratee, comparator, exValue) {
	      var computed = exValue,
	          result = computed;

	      baseEach(collection, function(value, index, collection) {
	        var current = +iteratee(value, index, collection);
	        if (comparator(current, computed) || (current === exValue && current === result)) {
	          computed = current;
	          result = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : (end >>> 0);
	      start >>>= 0;

	      while (start < length) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
	     * without support for callback shorthands and `this` binding, which iterates
	     * over `collection` using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @param {boolean} [retKey] Specify returning the key of the found element
	     *  instead of the element itself.
	     * @returns {*} Returns the found element or its key, else `undefined`.
	     */
	    function baseFind(collection, predicate, eachFunc, retKey) {
	      var result;
	      eachFunc(collection, function(value, key, collection) {
	        if (predicate(value, key, collection)) {
	          result = retKey ? key : value;
	          return false;
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with added support for restricting
	     * flattening and specifying the start index.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, isDeep, isStrict, result) {
	      result || (result = []);

	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index];
	        if (isObjectLike(value) && isArrayLike(value) &&
	            (isStrict || isArray(value) || isArguments(value))) {
	          if (isDeep) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, isDeep, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForIn` and `baseForOwn` which iterates
	     * over `object` properties returned by `keysFunc` invoking `iteratee` for
	     * each property. Iteratee functions may exit iteration early by explicitly
	     * returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forIn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForIn(object, iteratee) {
	      return baseFor(object, iteratee, keysIn);
	    }

	    /**
	     * The base implementation of `_.forOwn` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from those provided.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the new array of filtered property names.
	     */
	    function baseFunctions(object, props) {
	      var index = -1,
	          length = props.length,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var key = props[index];
	        if (isFunction(object[key])) {
	          result[++resIndex] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `get` without support for string paths
	     * and default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path of the property to get.
	     * @param {string} [pathKey] The key representation of path.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path, pathKey) {
	      if (object == null) {
	        return;
	      }
	      if (pathKey !== undefined && pathKey in toObject(object)) {
	        path = [pathKey];
	      }
	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = object[path[index++]];
	      }
	      return (index && index == length) ? object : undefined;
	    }

	    /**
	     * The base implementation of `_.isEqual` without support for `this` binding
	     * `customizer` functions.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;

	      if (!objIsArr) {
	        objTag = objToString.call(object);
	        if (objTag == argsTag) {
	          objTag = objectTag;
	        } else if (objTag != objectTag) {
	          objIsArr = isTypedArray(object);
	        }
	      }
	      if (!othIsArr) {
	        othTag = objToString.call(other);
	        if (othTag == argsTag) {
	          othTag = objectTag;
	        } else if (othTag != objectTag) {
	          othIsArr = isTypedArray(other);
	        }
	      }
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && !(objIsArr || objIsObj)) {
	        return equalByTag(object, other, objTag);
	      }
	      if (!isLoose) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      // For more information on detecting circular references see https://es5.github.io/#JO.
	      stackA || (stackA = []);
	      stackB || (stackB = []);

	      var length = stackA.length;
	      while (length--) {
	        if (stackA[length] == object) {
	          return stackB[length] == other;
	        }
	      }
	      // Add `object` and `other` to the stack of traversed objects.
	      stackA.push(object);
	      stackB.push(other);

	      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

	      stackA.pop();
	      stackB.pop();

	      return result;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for callback
	     * shorthands and `this` binding.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} matchData The propery names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparing objects.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = toObject(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var result = customizer ? customizer(objValue, srcValue, key) : undefined;
	          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.map` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which does not clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        var key = matchData[0][0],
	            value = matchData[0][1];

	        return function(object) {
	          if (object == null) {
	            return false;
	          }
	          return object[key] === value && (value !== undefined || (key in toObject(object)));
	        };
	      }
	      return function(object) {
	        return baseIsMatch(object, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to compare.
	     * @returns {Function} Returns the new function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      var isArr = isArray(path),
	          isCommon = isKey(path) && isStrictComparable(srcValue),
	          pathKey = (path + '');

	      path = toPath(path);
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        var key = pathKey;
	        object = toObject(object);
	        if ((isArr || !isCommon) && !(key in object)) {
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          if (object == null) {
	            return false;
	          }
	          key = last(path);
	          object = toObject(object);
	        }
	        return object[key] === srcValue
	          ? (srcValue !== undefined || (key in object))
	          : baseIsEqual(srcValue, object[key], undefined, true);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for argument juggling,
	     * multiple sources, and `this` binding `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {Object} Returns `object`.
	     */
	    function baseMerge(object, source, customizer, stackA, stackB) {
	      if (!isObject(object)) {
	        return object;
	      }
	      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),
	          props = isSrcArr ? undefined : keys(source);

	      arrayEach(props || source, function(srcValue, key) {
	        if (props) {
	          key = srcValue;
	          srcValue = source[key];
	        }
	        if (isObjectLike(srcValue)) {
	          stackA || (stackA = []);
	          stackB || (stackB = []);
	          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
	        }
	        else {
	          var value = object[key],
	              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	              isCommon = result === undefined;

	          if (isCommon) {
	            result = srcValue;
	          }
	          if ((result !== undefined || (isSrcArr && !(key in object))) &&
	              (isCommon || (result === result ? (result !== value) : (value === value)))) {
	            object[key] = result;
	          }
	        }
	      });
	      return object;
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Array} [stackA=[]] Tracks traversed source objects.
	     * @param {Array} [stackB=[]] Associates values with source counterparts.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
	      var length = stackA.length,
	          srcValue = source[key];

	      while (length--) {
	        if (stackA[length] == srcValue) {
	          object[key] = stackB[length];
	          return;
	        }
	      }
	      var value = object[key],
	          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
	          isCommon = result === undefined;

	      if (isCommon) {
	        result = srcValue;
	        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
	          result = isArray(value)
	            ? value
	            : (isArrayLike(value) ? arrayCopy(value) : []);
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          result = isArguments(value)
	            ? toPlainObject(value)
	            : (isPlainObject(value) ? value : {});
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      // Add the source value to the stack of traversed objects and associate
	      // it with its merged value.
	      stackA.push(srcValue);
	      stackB.push(result);

	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
	      } else if (result === result ? (result !== value) : (value === value)) {
	        object[key] = result;
	      }
	    }

	    /**
	     * The base implementation of `_.property` without support for deep paths.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function baseProperty(key) {
	      return function(object) {
	        return object == null ? undefined : object[key];
	      };
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     */
	    function basePropertyDeep(path) {
	      var pathKey = (path + '');
	      path = toPath(path);
	      return function(object) {
	        return baseGet(object, path, pathKey);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * index arguments and capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0;
	      while (length--) {
	        var index = indexes[length];
	        if (index != previous && isIndex(index)) {
	          var previous = index;
	          splice.call(array, index, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for argument juggling
	     * and returning floating-point numbers.
	     *
	     * @private
	     * @param {number} min The minimum possible value.
	     * @param {number} max The maximum possible value.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(min, max) {
	      return min + nativeFloor(nativeRandom() * (max - min + 1));
	    }

	    /**
	     * The base implementation of `_.reduce` and `_.reduceRight` without support
	     * for callback shorthands and `this` binding, which iterates over `collection`
	     * using the provided `eachFunc`.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {*} accumulator The initial value.
	     * @param {boolean} initFromCollection Specify using the first or last element
	     *  of `collection` as the initial value.
	     * @param {Function} eachFunc The function to iterate over `collection`.
	     * @returns {*} Returns the accumulated value.
	     */
	    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
	      eachFunc(collection, function(value, index, collection) {
	        accumulator = initFromCollection
	          ? (initFromCollection = false, value)
	          : iteratee(accumulator, value, index, collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop detection.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      start = start == null ? 0 : (+start || 0);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : (+end || 0);
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortBy` which uses `comparer` to define
	     * the sort order of `array` and replaces criteria objects with their
	     * corresponding values.
	     *
	     * @private
	     * @param {Array} array The array to sort.
	     * @param {Function} comparer The function to define sort order.
	     * @returns {Array} Returns `array`.
	     */
	    function baseSortBy(array, comparer) {
	      var length = array.length;

	      array.sort(comparer);
	      while (length--) {
	        array[length] = array[length].value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.sortByOrder` without param guards.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseSortByOrder(collection, iteratees, orders) {
	      var callback = getCallback(),
	          index = -1;

	      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });

	      var result = baseMap(collection, function(value) {
	        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.sum` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {number} Returns the sum.
	     */
	    function baseSum(collection, iteratee) {
	      var result = 0;
	      baseEach(collection, function(value, index, collection) {
	        result += +iteratee(value, index, collection) || 0;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.uniq` without support for callback shorthands
	     * and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The function invoked per iteration.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     */
	    function baseUniq(array, iteratee) {
	      var index = -1,
	          indexOf = getIndexOf(),
	          length = array.length,
	          isCommon = indexOf == baseIndexOf,
	          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,
	          seen = isLarge ? createCache() : null,
	          result = [];

	      if (seen) {
	        indexOf = cacheIndexOf;
	        isCommon = false;
	      } else {
	        isLarge = false;
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value, index, array) : value;

	        if (isCommon && value === value) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (indexOf(seen, computed, 0) < 0) {
	          if (iteratee || isLarge) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.values` and `_.valuesIn` which creates an
	     * array of `object` property values corresponding to the property names
	     * of `props`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} props The property names to get values for.
	     * @returns {Object} Returns the array of property values.
	     */
	    function baseValues(object, props) {
	      var index = -1,
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        result[index] = object[props[index]];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,
	     * and `_.takeWhile` without support for callback shorthands and `this` binding.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to peform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      var index = -1,
	          length = actions.length;

	      while (++index < length) {
	        var action = actions[index];
	        result = action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }
	      return result;
	    }

	    /**
	     * Performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndex(array, value, retHighest) {
	      var low = 0,
	          high = array ? array.length : low;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return binaryIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * This function is like `binaryIndex` except that it invokes `iteratee` for
	     * `value` and each element of `array` to compute their sort ranking. The
	     * iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function binaryIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);

	      var low = 0,
	          high = array ? array.length : 0,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsUndef = value === undefined;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            isDef = computed !== undefined,
	            isReflexive = computed === computed;

	        if (valIsNaN) {
	          var setLow = isReflexive || retHighest;
	        } else if (valIsNull) {
	          setLow = isReflexive && isDef && (retHighest || computed != null);
	        } else if (valIsUndef) {
	          setLow = isReflexive && (retHighest || isDef);
	        } else if (computed == null) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * A specialized version of `baseCallback` which only supports `this` binding
	     * and specifying the number of arguments to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {number} [argCount] The number of arguments to provide to `func`.
	     * @returns {Function} Returns the callback.
	     */
	    function bindCallback(func, thisArg, argCount) {
	      if (typeof func != 'function') {
	        return identity;
	      }
	      if (thisArg === undefined) {
	        return func;
	      }
	      switch (argCount) {
	        case 1: return function(value) {
	          return func.call(thisArg, value);
	        };
	        case 3: return function(value, index, collection) {
	          return func.call(thisArg, value, index, collection);
	        };
	        case 4: return function(accumulator, value, index, collection) {
	          return func.call(thisArg, accumulator, value, index, collection);
	        };
	        case 5: return function(value, other, key, object, source) {
	          return func.call(thisArg, value, other, key, object, source);
	        };
	      }
	      return function() {
	        return func.apply(thisArg, arguments);
	      };
	    }

	    /**
	     * Creates a clone of the given array buffer.
	     *
	     * @private
	     * @param {ArrayBuffer} buffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function bufferClone(buffer) {
	      var result = new ArrayBuffer(buffer.byteLength),
	          view = new Uint8Array(result);

	      view.set(new Uint8Array(buffer));
	      return result;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders) {
	      var holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          leftIndex = -1,
	          leftLength = partials.length,
	          result = Array(leftLength + argsLength);

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        result[holders[argsIndex]] = args[argsIndex];
	      }
	      while (argsLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array|Object} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders) {
	      var holdersIndex = -1,
	          holdersLength = holders.length,
	          argsIndex = -1,
	          argsLength = nativeMax(args.length - holdersLength, 0),
	          rightIndex = -1,
	          rightLength = partials.length,
	          result = Array(argsLength + rightLength);

	      while (++argsIndex < argsLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        result[offset + holders[holdersIndex]] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.
	     *
	     * @private
	     * @param {Function} setter The function to set keys and values of the accumulator object.
	     * @param {Function} [initializer] The function to initialize the accumulator object.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee, thisArg) {
	        var result = initializer ? initializer() : {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        if (isArray(collection)) {
	          var index = -1,
	              length = collection.length;

	          while (++index < length) {
	            var value = collection[index];
	            setter(result, value, iteratee(value, index, collection), collection);
	          }
	        } else {
	          baseEach(collection, function(value, key, collection) {
	            setter(result, value, iteratee(value, key, collection), collection);
	          });
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return restParam(function(object, sources) {
	        var index = -1,
	            length = object == null ? 0 : sources.length,
	            customizer = length > 2 ? sources[length - 2] : undefined,
	            guard = length > 2 ? sources[2] : undefined,
	            thisArg = length > 1 ? sources[length - 1] : undefined;

	        if (typeof customizer == 'function') {
	          customizer = bindCallback(customizer, thisArg, 5);
	          length -= 2;
	        } else {
	          customizer = typeof thisArg == 'function' ? thisArg : undefined;
	          length -= (customizer ? 1 : 0);
	        }
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        var length = collection ? getLength(collection) : 0;
	        if (!isLength(length)) {
	          return eachFunc(collection, iteratee);
	        }
	        var index = fromRight ? length : -1,
	            iterable = toObject(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var iterable = toObject(object),
	            props = keysFunc(object),
	            length = props.length,
	            index = fromRight ? length : -1;

	        while ((fromRight ? index-- : ++index < length)) {
	          var key = props[index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to bind.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createBindWrapper(func, thisArg) {
	      var Ctor = createCtorWrapper(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(thisArg, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `Set` cache object to optimize linear searches of large arrays.
	     *
	     * @private
	     * @param {Array} [values] The values to cache.
	     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
	     */
	    function createCache(values) {
	      return (nativeCreate && Set) ? new SetCache(values) : null;
	    }

	    /**
	     * Creates a function that produces compound words out of the words in a
	     * given string.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        var index = -1,
	            array = words(deburr(string)),
	            length = array.length,
	            result = '';

	        while (++index < length) {
	          result = callback(result, array[index], index);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtorWrapper(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors.
	        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a `_.curry` or `_.curryRight` function.
	     *
	     * @private
	     * @param {boolean} flag The curry bit flag.
	     * @returns {Function} Returns the new curry function.
	     */
	    function createCurry(flag) {
	      function curryFunc(func, arity, guard) {
	        if (guard && isIterateeCall(func, arity, guard)) {
	          arity = undefined;
	        }
	        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);
	        result.placeholder = curryFunc.placeholder;
	        return result;
	      }
	      return curryFunc;
	    }

	    /**
	     * Creates a `_.defaults` or `_.defaultsDeep` function.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Function} Returns the new defaults function.
	     */
	    function createDefaults(assigner, customizer) {
	      return restParam(function(args) {
	        var object = args[0];
	        if (object == null) {
	          return object;
	        }
	        args.push(customizer);
	        return assigner.apply(undefined, args);
	      });
	    }

	    /**
	     * Creates a `_.max` or `_.min` function.
	     *
	     * @private
	     * @param {Function} comparator The function used to compare values.
	     * @param {*} exValue The initial extremum value.
	     * @returns {Function} Returns the new extremum function.
	     */
	    function createExtremum(comparator, exValue) {
	      return function(collection, iteratee, thisArg) {
	        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	          iteratee = undefined;
	        }
	        iteratee = getCallback(iteratee, thisArg, 3);
	        if (iteratee.length == 1) {
	          collection = isArray(collection) ? collection : toIterable(collection);
	          var result = arrayExtremum(collection, iteratee, comparator, exValue);
	          if (!(collection.length && result === exValue)) {
	            return result;
	          }
	        }
	        return baseExtremum(collection, iteratee, comparator, exValue);
	      };
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(eachFunc, fromRight) {
	      return function(collection, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        if (isArray(collection)) {
	          var index = baseFindIndex(collection, predicate, fromRight);
	          return index > -1 ? collection[index] : undefined;
	        }
	        return baseFind(collection, predicate, eachFunc);
	      };
	    }

	    /**
	     * Creates a `_.findIndex` or `_.findLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindIndex(fromRight) {
	      return function(array, predicate, thisArg) {
	        if (!(array && array.length)) {
	          return -1;
	        }
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFindIndex(array, predicate, fromRight);
	      };
	    }

	    /**
	     * Creates a `_.findKey` or `_.findLastKey` function.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFindKey(objectFunc) {
	      return function(object, predicate, thisArg) {
	        predicate = getCallback(predicate, thisArg, 3);
	        return baseFind(object, predicate, objectFunc, true);
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return function() {
	        var wrapper,
	            length = arguments.length,
	            index = fromRight ? length : -1,
	            leftIndex = 0,
	            funcs = Array(length);

	        while ((fromRight ? index-- : ++index < length)) {
	          var func = funcs[leftIndex++] = arguments[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {
	            wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? -1 : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;

	          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      };
	    }

	    /**
	     * Creates a function for `_.forEach` or `_.forEachRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForEach(arrayFunc, eachFunc) {
	      return function(collection, iteratee, thisArg) {
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee)
	          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
	      };
	    }

	    /**
	     * Creates a function for `_.forIn` or `_.forInRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForIn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee, keysIn);
	      };
	    }

	    /**
	     * Creates a function for `_.forOwn` or `_.forOwnRight`.
	     *
	     * @private
	     * @param {Function} objectFunc The function to iterate over an object.
	     * @returns {Function} Returns the new each function.
	     */
	    function createForOwn(objectFunc) {
	      return function(object, iteratee, thisArg) {
	        if (typeof iteratee != 'function' || thisArg !== undefined) {
	          iteratee = bindCallback(iteratee, thisArg, 3);
	        }
	        return objectFunc(object, iteratee);
	      };
	    }

	    /**
	     * Creates a function for `_.mapKeys` or `_.mapValues`.
	     *
	     * @private
	     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.
	     * @returns {Function} Returns the new map function.
	     */
	    function createObjectMapper(isMapKeys) {
	      return function(object, iteratee, thisArg) {
	        var result = {};
	        iteratee = getCallback(iteratee, thisArg, 3);

	        baseForOwn(object, function(value, key, object) {
	          var mapped = iteratee(value, key, object);
	          key = isMapKeys ? mapped : key;
	          value = isMapKeys ? value : mapped;
	          result[key] = value;
	        });
	        return result;
	      };
	    }

	    /**
	     * Creates a function for `_.padLeft` or `_.padRight`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify padding from the right.
	     * @returns {Function} Returns the new pad function.
	     */
	    function createPadDir(fromRight) {
	      return function(string, length, chars) {
	        string = baseToString(string);
	        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
	      };
	    }

	    /**
	     * Creates a `_.partial` or `_.partialRight` function.
	     *
	     * @private
	     * @param {boolean} flag The partial bit flag.
	     * @returns {Function} Returns the new partial function.
	     */
	    function createPartial(flag) {
	      var partialFunc = restParam(function(func, partials) {
	        var holders = replaceHolders(partials, partialFunc.placeholder);
	        return createWrapper(func, flag, undefined, partials, holders);
	      });
	      return partialFunc;
	    }

	    /**
	     * Creates a function for `_.reduce` or `_.reduceRight`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over an array.
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @returns {Function} Returns the new each function.
	     */
	    function createReduce(arrayFunc, eachFunc) {
	      return function(collection, iteratee, accumulator, thisArg) {
	        var initFromArray = arguments.length < 3;
	        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
	          ? arrayFunc(collection, iteratee, accumulator, initFromArray)
	          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with optional `this`
	     * binding of, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & ARY_FLAG,
	          isBind = bitmask & BIND_FLAG,
	          isBindKey = bitmask & BIND_KEY_FLAG,
	          isCurry = bitmask & CURRY_FLAG,
	          isCurryBound = bitmask & CURRY_BOUND_FLAG,
	          isCurryRight = bitmask & CURRY_RIGHT_FLAG,
	          Ctor = isBindKey ? undefined : createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it to other functions.
	        var length = arguments.length,
	            index = length,
	            args = Array(length);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight);
	        }
	        if (isCurry || isCurryRight) {
	          var placeholder = wrapper.placeholder,
	              argsHolders = replaceHolders(args, placeholder);

	          length -= argsHolders.length;
	          if (length < arity) {
	            var newArgPos = argPos ? arrayCopy(argPos) : undefined,
	                newArity = nativeMax(arity - length, 0),
	                newsHolders = isCurry ? argsHolders : undefined,
	                newHoldersRight = isCurry ? undefined : argsHolders,
	                newPartials = isCurry ? args : undefined,
	                newPartialsRight = isCurry ? undefined : args;

	            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
	            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

	            if (!isCurryBound) {
	              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
	            }
	            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],
	                result = createHybridWrapper.apply(undefined, newData);

	            if (isLaziable(func)) {
	              setData(result, newData);
	            }
	            result.placeholder = placeholder;
	            return result;
	          }
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        if (argPos) {
	          args = reorder(args, argPos);
	        }
	        if (isAry && ary < args.length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtorWrapper(func);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates the padding required for `string` based on the given `length`.
	     * The `chars` string is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {string} string The string to create padding for.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the pad for `string`.
	     */
	    function createPadding(string, length, chars) {
	      var strLength = string.length;
	      length = +length;

	      if (strLength >= length || !nativeIsFinite(length)) {
	        return '';
	      }
	      var padLength = length - strLength;
	      chars = chars == null ? ' ' : (chars + '');
	      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);
	    }

	    /**
	     * Creates a function that wraps `func` and invokes it with the optional `this`
	     * binding of `thisArg` and the `partials` prepended to those provided to
	     * the wrapper.
	     *
	     * @private
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to the new function.
	     * @returns {Function} Returns the new bound function.
	     */
	    function createPartialWrapper(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & BIND_FLAG,
	          Ctor = createCtorWrapper(func);

	      function wrapper() {
	        // Avoid `arguments` object use disqualifying optimizations by
	        // converting it to an array before providing it `func`.
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength);

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.ceil`, `_.floor`, or `_.round` function.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        precision = precision === undefined ? 0 : (+precision || 0);
	        if (precision) {
	          precision = pow(10, precision);
	          return func(number * precision) / precision;
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.
	     *
	     * @private
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {Function} Returns the new index function.
	     */
	    function createSortedIndex(retHighest) {
	      return function(array, value, iteratee, thisArg) {
	        var callback = getCallback(iteratee);
	        return (iteratee == null && callback === baseCallback)
	          ? binaryIndex(array, value, retHighest)
	          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to reference.
	     * @param {number} bitmask The bitmask of flags.
	     *  The bitmask may be composed of the following flags:
	     *     1 - `_.bind`
	     *     2 - `_.bindKey`
	     *     4 - `_.curry` or `_.curryRight` of a bound function
	     *     8 - `_.curry`
	     *    16 - `_.curryRight`
	     *    32 - `_.partial`
	     *    64 - `_.partialRight`
	     *   128 - `_.rearg`
	     *   256 - `_.ary`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      length -= (holders ? holders.length : 0);
	      if (bitmask & PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func),
	          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

	      if (data) {
	        mergeData(newData, data);
	        bitmask = newData[1];
	        arity = newData[9];
	      }
	      newData[9] = arity == null
	        ? (isBindKey ? 0 : func.length)
	        : (nativeMax(arity - length, 0) || 0);

	      if (bitmask == BIND_FLAG) {
	        var result = createBindWrapper(newData[0], newData[2]);
	      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
	        result = createPartialWrapper.apply(undefined, newData);
	      } else {
	        result = createHybridWrapper.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setter(result, newData);
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing arrays.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var index = -1,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
	        return false;
	      }
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index],
	            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

	        if (result !== undefined) {
	          if (result) {
	            continue;
	          }
	          return false;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (isLoose) {
	          if (!arraySome(other, function(othValue) {
	                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
	              })) {
	            return false;
	          }
	        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag) {
	      switch (tag) {
	        case boolTag:
	        case dateTag:
	          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	          return +object == +other;

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case numberTag:
	          // Treat `NaN` vs. `NaN` as equal.
	          return (object != +object)
	            ? other != +other
	            : object == +other;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings primitives and string
	          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	          return object == (other + '');
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Function} [customizer] The function to customize comparing values.
	     * @param {boolean} [isLoose] Specify performing partial comparisons.
	     * @param {Array} [stackA] Tracks traversed `value` objects.
	     * @param {Array} [stackB] Tracks traversed `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	      var objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isLoose) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      var skipCtor = isLoose;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key],
	            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
	          return false;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (!skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Gets the appropriate "callback" function. If the `_.callback` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseCallback` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getCallback(func, thisArg, argCount) {
	      var result = lodash.callback || callback;
	      result = result === callback ? baseCallback : result;
	      return argCount ? result(func, thisArg, argCount) : result;
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = func.name,
	          array = realNames[result],
	          length = array ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
	     * customized this function returns the custom method, otherwise it returns
	     * the `baseIndexOf` function. If arguments are provided the chosen function
	     * is invoked with them and its result is returned.
	     *
	     * @private
	     * @returns {Function|number} Returns the chosen function or its result.
	     */
	    function getIndexOf(collection, target, fromIndex) {
	      var result = lodash.indexOf || indexOf;
	      result = result === indexOf ? baseIndexOf : result;
	      return collection ? result(collection, target, fromIndex) : result;
	    }

	    /**
	     * Gets the "length" property value of `object`.
	     *
	     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	     * that affects Safari on at least iOS 8.1-8.3 ARM64.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {*} Returns the "length" value.
	     */
	    var getLength = baseProperty('length');

	    /**
	     * Gets the propery names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = pairs(object),
	          length = result.length;

	      while (length--) {
	        result[length][2] = isStrictComparable(result[length][1]);
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = object == null ? undefined : object[key];
	      return isNative(value) ? value : undefined;
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add array properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      var Ctor = object.constructor;
	      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
	        Ctor = Object;
	      }
	      return new Ctor;
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return bufferClone(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          var buffer = object.buffer;
	          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          var result = new Ctor(object.source, reFlags.exec(object));
	          result.lastIndex = object.lastIndex;
	      }
	      return result;
	    }

	    /**
	     * Invokes the method at `path` on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function invokePath(object, path, args) {
	      if (object != null && !isKey(path, object)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        path = last(path);
	      }
	      var func = object == null ? object : object[path];
	      return func == null ? undefined : func.apply(object, args);
	    }

	    /**
	     * Checks if `value` is array-like.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(getLength(value));
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return value > -1 && value % 1 == 0 && value < length;
	    }

	    /**
	     * Checks if the provided arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	          ? (isArrayLike(object) && isIndex(index, object.length))
	          : (type == 'string' && index in object)) {
	        var other = object[index];
	        return value === value ? (value === other) : (other !== other);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      var type = typeof value;
	      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	        return true;
	      }
	      if (isArray(value)) {
	        return false;
	      }
	      var result = !reIsDeepProp.test(value);
	      return result || (object != null && value in toObject(object));
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func);
	      if (!(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      var other = lodash[funcName];
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     */
	    function isLength(value) {
	      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers required to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
	     * augment function arguments, making the order in which they are executed important,
	     * preventing the merging of metadata. However, we make an exception for a safe
	     * common case where curried functions have `_.ary` and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < ARY_FLAG;

	      var isCombo =
	        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||
	        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||
	        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = arrayCopy(value);
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objectValue The destination object property value.
	     * @param {*} sourceValue The source object property value.
	     * @returns {*} Returns the value to assign to the destination object.
	     */
	    function mergeDefaults(objectValue, sourceValue) {
	      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);
	    }

	    /**
	     * A specialized version of `_.pick` which picks `object` properties specified
	     * by `props`.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} props The property names to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByArray(object, props) {
	      object = toObject(object);

	      var index = -1,
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index];
	        if (key in object) {
	          result[key] = object[key];
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.pick` which picks `object` properties `predicate`
	     * returns truthy for.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Object} Returns the new object.
	     */
	    function pickByCallback(object, predicate) {
	      var result = {};
	      baseForIn(object, function(value, key, object) {
	        if (predicate(value, key, object)) {
	          result[key] = value;
	        }
	      });
	      return result;
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = arrayCopy(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity function
	     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = (function() {
	      var count = 0,
	          lastCalled = 0;

	      return function(key, value) {
	        var stamp = now(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return key;
	          }
	        } else {
	          count = 0;
	        }
	        return baseSetData(key, value);
	      };
	    }());

	    /**
	     * A fallback implementation of `Object.keys` which creates an array of the
	     * own enumerable property names of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function shimKeys(object) {
	      var props = keysIn(object),
	          propsLength = props.length,
	          length = propsLength && object.length;

	      var allowIndexes = !!length && isLength(length) &&
	        (isArray(object) || isArguments(object));

	      var index = -1,
	          result = [];

	      while (++index < propsLength) {
	        var key = props[index];
	        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to an array-like object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array|Object} Returns the array-like object.
	     */
	    function toIterable(value) {
	      if (value == null) {
	        return [];
	      }
	      if (!isArrayLike(value)) {
	        return values(value);
	      }
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to an object if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Object} Returns the object.
	     */
	    function toObject(value) {
	      return isObject(value) ? value : Object(value);
	    }

	    /**
	     * Converts `value` to property path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {Array} Returns the property path array.
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return value;
	      }
	      var result = [];
	      baseToString(value).replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      return wrapper instanceof LazyWrapper
	        ? wrapper.clone()
	        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `collection` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new array containing chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if (guard ? isIterateeCall(array, size, guard) : size == null) {
	        size = 1;
	      } else {
	        size = nativeMax(nativeFloor(size) || 1, 1);
	      }
	      var index = 0,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[++resIndex] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array ? array.length : 0,
	          resIndex = -1,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[++resIndex] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of unique `array` values not included in the other
	     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The arrays of values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.difference([1, 2, 3], [4, 2]);
	     * // => [1, 3]
	     */
	    var difference = restParam(function(array, values) {
	      return (isObjectLike(array) && isArrayLike(array))
	        ? baseDifference(array, baseFlatten(values, false, true))
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that match the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [1]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active', false), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.dropWhile(users, 'active'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8], '*', 1, 2);
	     * // => [4, '*', 8]
	     */
	    function fill(array, value, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(chr) {
	     *   return chr.user == 'barney';
	     * });
	     * // => 0
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findIndex(users, 'active', false);
	     * // => 0
	     *
	     * // using the `_.property` callback shorthand
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    var findIndex = createFindIndex();

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(chr) {
	     *   return chr.user == 'pebbles';
	     * });
	     * // => 2
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastIndex(users, 'active', false);
	     * // => 2
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    var findLastIndex = createFindIndex(true);

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias head
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.first([1, 2, 3]);
	     * // => 1
	     *
	     * _.first([]);
	     * // => undefined
	     */
	    function first(array) {
	      return array ? array[0] : undefined;
	    }

	    /**
	     * Flattens a nested array. If `isDeep` is `true` the array is recursively
	     * flattened, otherwise it is only flattened a single level.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {boolean} [isDeep] Specify a deep flatten.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, [4]]
	     *
	     * // using `isDeep`
	     * _.flatten([1, [2, 3, [4]]], true);
	     * // => [1, 2, 3, 4]
	     */
	    function flatten(array, isDeep, guard) {
	      var length = array ? array.length : 0;
	      if (guard && isIterateeCall(array, isDeep, guard)) {
	        isDeep = false;
	      }
	      return length ? baseFlatten(array, isDeep) : [];
	    }

	    /**
	     * Recursively flattens a nested array.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to recursively flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, 3, [4]]]);
	     * // => [1, 2, 3, 4]
	     */
	    function flattenDeep(array) {
	      var length = array ? array.length : 0;
	      return length ? baseFlatten(array, true) : [];
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`
	     * performs a faster binary search.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
	     *  to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // using `fromIndex`
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     *
	     * // performing a binary search
	     * _.indexOf([1, 1, 2, 2], 2, true);
	     * // => 2
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      if (typeof fromIndex == 'number') {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
	      } else if (fromIndex) {
	        var index = binaryIndex(array, value);
	        if (index < length &&
	            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {
	          return index;
	        }
	        return -1;
	      }
	      return baseIndexOf(array, value, fromIndex || 0);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      return dropRight(array, 1);
	    }

	    /**
	     * Creates an array of unique values that are included in all of the provided
	     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of shared values.
	     * @example
	     * _.intersection([1, 2], [4, 2], [2, 1]);
	     * // => [2]
	     */
	    var intersection = restParam(function(arrays) {
	      var othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(length),
	          indexOf = getIndexOf(),
	          isCommon = indexOf == baseIndexOf,
	          result = [];

	      while (othIndex--) {
	        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];
	        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;
	      }
	      var array = arrays[0],
	          index = -1,
	          length = array ? array.length : 0,
	          seen = caches[0];

	      outer:
	      while (++index < length) {
	        value = array[index];
	        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
	          var othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(value);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    });

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array ? array.length : 0;
	      return length ? array[length - 1] : undefined;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to search.
	     * @param {*} value The value to search for.
	     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
	     *  or `true` to perform a binary search on a sorted array.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // using `fromIndex`
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     *
	     * // performing a binary search
	     * _.lastIndexOf([1, 1, 2, 2], 2, true);
	     * // => 3
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (typeof fromIndex == 'number') {
	        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
	      } else if (fromIndex) {
	        index = binaryIndex(array, value, true) - 1;
	        var other = array[index];
	        if (value === value ? (value === other) : (other !== other)) {
	          return index;
	        }
	        return -1;
	      }
	      if (value !== value) {
	        return indexOfNaN(array, index, true);
	      }
	      while (index--) {
	        if (array[index] === value) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Removes all provided values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3, 1, 2, 3];
	     *
	     * _.pull(array, 2, 3);
	     * console.log(array);
	     * // => [1, 1]
	     */
	    function pull() {
	      var args = arguments,
	          array = args[0];

	      if (!(array && array.length)) {
	        return array;
	      }
	      var index = 0,
	          indexOf = getIndexOf(),
	          length = args.length;

	      while (++index < length) {
	        var fromIndex = 0,
	            value = args[index];

	        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * Removes elements from `array` corresponding to the given indexes and returns
	     * an array of the removed elements. Indexes may be specified as an array of
	     * indexes or as individual arguments.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [5, 10, 15, 20];
	     * var evens = _.pullAt(array, 1, 3);
	     *
	     * console.log(array);
	     * // => [5, 15]
	     *
	     * console.log(evens);
	     * // => [10, 20]
	     */
	    var pullAt = restParam(function(array, indexes) {
	      indexes = baseFlatten(indexes);

	      var result = baseAt(array, indexes);
	      basePullAt(array, indexes.sort(baseCompareAscending));
	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate, thisArg) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getCallback(predicate, thisArg, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @alias tail
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.rest([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function rest(array) {
	      return drop(array, 1);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of `Array#slice` to support node
	     * lists in IE < 9 and to ensure dense arrays are returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value` should
	     * be inserted into `array` in order to maintain its sort order. If an iteratee
	     * function is provided it is invoked for `value` and each element of `array`
	     * to compute their sort ranking. The iteratee is bound to `thisArg` and
	     * invoked with one argument; (value).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     *
	     * _.sortedIndex([4, 4, 5, 5], 5);
	     * // => 2
	     *
	     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
	     *
	     * // using an iteratee function
	     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
	     *   return this.data[word];
	     * }, dict);
	     * // => 1
	     *
	     * // using the `_.property` callback shorthand
	     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	     * // => 1
	     */
	    var sortedIndex = createSortedIndex();

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 4, 5, 5], 5);
	     * // => 4
	     */
	    var sortedLastIndex = createSortedIndex(true);

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (guard ? isIterateeCall(array, n, guard) : n == null) {
	        n = 1;
	      }
	      n = length - (+n || 0);
	      return baseSlice(array, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
	     * and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRightWhile([1, 2, 3], function(n) {
	     *   return n > 1;
	     * });
	     * // => [2, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
	     * // => ['pebbles']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
	     * // => ['fred', 'pebbles']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeRightWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is bound to
	     * `thisArg` and invoked with three arguments: (value, index, array).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeWhile([1, 2, 3], function(n) {
	     *   return n < 3;
	     * });
	     * // => [1, 2]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active', false), 'user');
	     * // => ['barney', 'fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.takeWhile(users, 'active'), 'user');
	     * // => []
	     */
	    function takeWhile(array, predicate, thisArg) {
	      return (array && array.length)
	        ? baseWhile(array, getCallback(predicate, thisArg, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all of the provided arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([1, 2], [4, 2], [2, 1]);
	     * // => [1, 2, 4]
	     */
	    var union = restParam(function(arrays) {
	      return baseUniq(baseFlatten(arrays, false, true));
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurence of each element
	     * is kept. Providing `true` for `isSorted` performs a faster search algorithm
	     * for sorted arrays. If an iteratee function is provided it is invoked for
	     * each element in the array to generate the criterion by which uniqueness
	     * is computed. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, array).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias unique
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {boolean} [isSorted] Specify the array is sorted.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new duplicate-value-free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     *
	     * // using `isSorted`
	     * _.uniq([1, 1, 2], true);
	     * // => [1, 2]
	     *
	     * // using an iteratee function
	     * _.uniq([1, 2.5, 1.5, 2], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => [1, 2.5]
	     *
	     * // using the `_.property` callback shorthand
	     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniq(array, isSorted, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      if (isSorted != null && typeof isSorted != 'boolean') {
	        thisArg = iteratee;
	        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;
	        isSorted = false;
	      }
	      var callback = getCallback();
	      if (!(iteratee == null && callback === baseCallback)) {
	        iteratee = callback(iteratee, thisArg, 3);
	      }
	      return (isSorted && getIndexOf() == baseIndexOf)
	        ? sortedUniq(array, iteratee)
	        : baseUniq(array, iteratee);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['fred', 'barney'], [30, 40], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var index = -1,
	          length = 0;

	      array = arrayFilter(array, function(group) {
	        if (isArrayLike(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = arrayMap(array, baseProperty(index));
	      }
	      return result;
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts an iteratee to specify
	     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee] The function to combine regrouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee, thisArg) {
	      var length = array ? array.length : 0;
	      if (!length) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      iteratee = bindCallback(iteratee, thisArg, 4);
	      return arrayMap(result, function(group) {
	        return arrayReduce(group, iteratee, undefined, true);
	      });
	    }

	    /**
	     * Creates an array excluding all provided values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {Array} array The array to filter.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.without([1, 2, 1, 3], 1, 2);
	     * // => [3]
	     */
	    var without = restParam(function(array, values) {
	      return isArrayLike(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the provided arrays.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of values.
	     * @example
	     *
	     * _.xor([1, 2], [4, 2]);
	     * // => [1, 4]
	     */
	    function xor() {
	      var index = -1,
	          length = arguments.length;

	      while (++index < length) {
	        var array = arguments[index];
	        if (isArrayLike(array)) {
	          var result = result
	            ? arrayPush(baseDifference(result, array), baseDifference(array, result))
	            : array;
	        }
	      }
	      return result ? baseUniq(result) : [];
	    }

	    /**
	     * Creates an array of grouped elements, the first of which contains the first
	     * elements of the given arrays, the second of which contains the second elements
	     * of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
	     * // => [['fred', 30, true], ['barney', 40, false]]
	     */
	    var zip = restParam(unzip);

	    /**
	     * The inverse of `_.pairs`; this method returns an object composed from arrays
	     * of property names and values. Provide either a single two dimensional array,
	     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names
	     * and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @alias object
	     * @category Array
	     * @param {Array} props The property names.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject([['fred', 30], ['barney', 40]]);
	     * // => { 'fred': 30, 'barney': 40 }
	     *
	     * _.zipObject(['fred', 'barney'], [30, 40]);
	     * // => { 'fred': 30, 'barney': 40 }
	     */
	    function zipObject(props, values) {
	      var index = -1,
	          length = props ? props.length : 0,
	          result = {};

	      if (length && !values && !isArray(props[0])) {
	        values = [];
	      }
	      while (++index < length) {
	        var key = props[index];
	        if (values) {
	          result[key] = values[index];
	        } else if (key) {
	          result[key[0]] = key[1];
	        }
	      }
	      return result;
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an iteratee to specify
	     * how grouped values should be combined. The `iteratee` is bound to `thisArg`
	     * and invoked with four arguments: (accumulator, value, index, group).
	     *
	     * @static
	     * @memberOf _
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee] The function to combine grouped values.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);
	     * // => [111, 222]
	     */
	    var zipWith = restParam(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 2 ? arrays[length - 2] : undefined,
	          thisArg = length > 1 ? arrays[length - 1] : undefined;

	      if (length > 2 && typeof iteratee == 'function') {
	        length -= 2;
	      } else {
	        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;
	        thisArg = undefined;
	      }
	      arrays.length = length;
	      return unzipWith(arrays, iteratee, thisArg);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object that wraps `value` with explicit method
	     * chaining enabled.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _.chain(users)
	     *   .sortBy('age')
	     *   .map(function(chr) {
	     *     return chr.user + ' is ' + chr.age;
	     *   })
	     *   .first()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor is
	     * bound to `thisArg` and invoked with one argument; (value). The purpose of
	     * this method is to "tap into" a method chain in order to perform operations
	     * on intermediate results within the chain.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor, thisArg) {
	      interceptor.call(thisArg, value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     *
	     * @static
	     * @memberOf _
	     * @category Chain
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @param {*} [thisArg] The `this` binding of `interceptor`.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor, thisArg) {
	      return interceptor.call(thisArg, value);
	    }

	    /**
	     * Enables explicit method chaining on the wrapper object.
	     *
	     * @name chain
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // without explicit chaining
	     * _(users).first();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // with explicit chaining
	     * _(users).chain()
	     *   .first()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chained sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Creates a new array joining a wrapped array with any additional arrays
	     * and/or values.
	     *
	     * @name concat
	     * @memberOf _
	     * @category Chain
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var wrapped = _(array).concat(2, [3], [[4]]);
	     *
	     * console.log(wrapped.value());
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    var wrapperConcat = restParam(function(values) {
	      values = baseFlatten(values);
	      return this.thru(function(array) {
	        return arrayConcat(isArray(array) ? array : [toObject(array)], values);
	      });
	    });

	    /**
	     * Creates a clone of the chained sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).map(function(value) {
	     *   return Math.pow(value, 2);
	     * });
	     *
	     * var other = [3, 4];
	     * var otherWrapped = wrapped.plant(other);
	     *
	     * otherWrapped.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * Reverses the wrapped array so the first element becomes the last, the
	     * second element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @category Chain
	     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;

	      var interceptor = function(value) {
	        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();
	      };
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(interceptor);
	    }

	    /**
	     * Produces the result of coercing the unwrapped value to a string.
	     *
	     * @name toString
	     * @memberOf _
	     * @category Chain
	     * @returns {string} Returns the coerced string value.
	     * @example
	     *
	     * _([1, 2, 3]).toString();
	     * // => '1,2,3'
	     */
	    function wrapperToString() {
	      return (this.value() + '');
	    }

	    /**
	     * Executes the chained sequence to extract the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @alias run, toJSON, valueOf
	     * @category Chain
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements corresponding to the given keys, or indexes,
	     * of `collection`. Keys may be specified as individual arguments or as arrays
	     * of keys.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(number|number[]|string|string[])} [props] The property names
	     *  or indexes of elements to pick, specified individually or in arrays.
	     * @returns {Array} Returns the new array of picked elements.
	     * @example
	     *
	     * _.at(['a', 'b', 'c'], [0, 2]);
	     * // => ['a', 'c']
	     *
	     * _.at(['barney', 'fred', 'pebbles'], 0, 2);
	     * // => ['barney', 'pebbles']
	     */
	    var at = restParam(function(collection, props) {
	      return baseAt(collection, baseFlatten(props));
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the number of times the key was returned by `iteratee`.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy([4.3, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': 1, '6': 2 }
	     *
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * The predicate is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias all
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': false },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.every(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias select
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.filter([4, 5, 6], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 6]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.filter(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.filter(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function filter(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, predicate);
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias detect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.result(_.find(users, function(chr) {
	     *   return chr.age < 40;
	     * }), 'user');
	     * // => 'barney'
	     *
	     * // using the `_.matches` callback shorthand
	     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.result(_.find(users, 'active', false), 'user');
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.result(_.find(users, 'active'), 'user');
	     * // => 'barney'
	     */
	    var find = createFind(baseEach);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(baseEachRight, true);

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning the first element that has equivalent property
	     * values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
	     * // => 'barney'
	     *
	     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
	     * // => 'fred'
	     */
	    function findWhere(collection, source) {
	      return find(collection, baseMatches(source));
	    }

	    /**
	     * Iterates over elements of `collection` invoking `iteratee` for each element.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection). Iteratee functions may exit iteration early
	     * by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length" property
	     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
	     * may be used for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @alias each
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEach(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from left to right and returns the array
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
	     *   console.log(n, key);
	     * });
	     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
	     */
	    var forEach = createForEach(arrayEach, baseEach);

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array|Object|string} Returns `collection`.
	     * @example
	     *
	     * _([1, 2]).forEachRight(function(n) {
	     *   console.log(n);
	     * }).value();
	     * // => logs each value from right to left and returns the array
	     */
	    var forEachRight = createForEach(arrayEachRight, baseEachRight);

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is an array of the elements responsible for generating the key.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return Math.floor(n);
	     * });
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * _.groupBy([4.2, 6.1, 6.4], function(n) {
	     *   return this.floor(n);
	     * }, Math);
	     * // => { '4': [4.2], '6': [6.1, 6.4] }
	     *
	     * // using the `_.property` callback shorthand
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        result[key] = [value];
	      }
	    });

	    /**
	     * Checks if `value` is in `collection` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it is used as the offset
	     * from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @alias contains, include
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {*} target The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
	     * // => true
	     *
	     * _.includes('pebbles', 'eb');
	     * // => true
	     */
	    function includes(collection, target, fromIndex, guard) {
	      var length = collection ? getLength(collection) : 0;
	      if (!isLength(length)) {
	        collection = values(collection);
	        length = collection.length;
	      }
	      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {
	        fromIndex = 0;
	      } else {
	        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
	      }
	      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
	        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)
	        : (!!length && getIndexOf(collection, target, fromIndex) > -1);
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` through `iteratee`. The corresponding value
	     * of each key is the last element responsible for generating the key. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var keyData = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.indexBy(keyData, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return String.fromCharCode(object.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.indexBy(keyData, function(object) {
	     *   return this.fromCharCode(object.code);
	     * }, String);
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     */
	    var indexBy = createAggregator(function(result, value, key) {
	      result[key] = value;
	    });

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `methodName` is a function it is
	     * invoked for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invoke([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invoke = restParam(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          isProp = isKey(path),
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);
	        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an array of values by running each element in `collection` through
	     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
	     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
	     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
	     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
	     * `sum`, `uniq`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @alias collect
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function timesThree(n) {
	     *   return n * 3;
	     * }
	     *
	     * _.map([1, 2], timesThree);
	     * // => [3, 6]
	     *
	     * _.map({ 'a': 1, 'b': 2 }, timesThree);
	     * // => [3, 6] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee, thisArg) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return func(collection, iteratee);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, while the second of which
	     * contains elements `predicate` returns falsey for. The predicate is bound
	     * to `thisArg` and invoked with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * _.partition([1, 2, 3], function(n) {
	     *   return n % 2;
	     * });
	     * // => [[1, 3], [2]]
	     *
	     * _.partition([1.2, 2.3, 3.4], function(n) {
	     *   return this.floor(n) % 2;
	     * }, Math);
	     * // => [[1.2, 3.4], [2.3]]
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * var mapper = function(array) {
	     *   return _.pluck(array, 'user');
	     * };
	     *
	     * // using the `_.matches` callback shorthand
	     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
	     * // => [['pebbles'], ['barney', 'fred']]
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.map(_.partition(users, 'active', false), mapper);
	     * // => [['barney', 'pebbles'], ['fred']]
	     *
	     * // using the `_.property` callback shorthand
	     * _.map(_.partition(users, 'active'), mapper);
	     * // => [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Gets the property value of `path` from all elements in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Array|string} path The path of the property to pluck.
	     * @returns {Array} Returns the property values.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.pluck(users, 'user');
	     * // => ['barney', 'fred']
	     *
	     * var userIndex = _.indexBy(users, 'user');
	     * _.pluck(userIndex, 'age');
	     * // => [36, 40] (iteration order is not guaranteed)
	     */
	    function pluck(collection, path) {
	      return map(collection, property(path));
	    }

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` through `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not provided the first element of `collection` is used as the initial
	     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,
	     * and `sortByOrder`
	     *
	     * @static
	     * @memberOf _
	     * @alias foldl, inject
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.reduce([1, 2], function(total, n) {
	     *   return total + n;
	     * });
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     *   return result;
	     * }, {});
	     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
	     */
	    var reduce = createReduce(arrayReduce, baseEach);

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias foldr
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    var reduceRight = createReduce(arrayReduceRight, baseEachRight);

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * _.reject([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 0;
	     * });
	     * // => [1, 3]
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
	     * // => ['barney']
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.pluck(_.reject(users, 'active', false), 'user');
	     * // => ['fred']
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.reject(users, 'active'), 'user');
	     * // => ['barney']
	     */
	    function reject(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      predicate = getCallback(predicate, thisArg, 3);
	      return func(collection, function(value, index, collection) {
	        return !predicate(value, index, collection);
	      });
	    }

	    /**
	     * Gets a random element or `n` random elements from a collection.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to sample.
	     * @param {number} [n] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {*} Returns the random sample(s).
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     *
	     * _.sample([1, 2, 3, 4], 2);
	     * // => [3, 1]
	     */
	    function sample(collection, n, guard) {
	      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
	        collection = toIterable(collection);
	        var length = collection.length;
	        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
	      }
	      var index = -1,
	          result = toArray(collection),
	          length = result.length,
	          lastIndex = length - 1;

	      n = nativeMin(n < 0 ? 0 : (+n || 0), length);
	      while (++index < n) {
	        var rand = baseRandom(index, lastIndex),
	            value = result[rand];

	        result[rand] = result[index];
	        result[index] = value;
	      }
	      result.length = n;
	      return result;
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      return sample(collection, POSITIVE_INFINITY);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the size of `collection`.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      var length = collection ? getLength(collection) : 0;
	      return isLength(length) ? length : keys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * The function returns as soon as it finds a passing value and does not iterate
	     * over the entire collection. The predicate is bound to `thisArg` and invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias any
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // using the `_.matches` callback shorthand
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.some(users, 'active', false);
	     * // => true
	     *
	     * // using the `_.property` callback shorthand
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, thisArg) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
	        predicate = undefined;
	      }
	      if (typeof predicate != 'function' || thisArg !== undefined) {
	        predicate = getCallback(predicate, thisArg, 3);
	      }
	      return func(collection, predicate);
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection through `iteratee`. This method performs
	     * a stable sort, that is, it preserves the original sort order of equal elements.
	     * The `iteratee` is bound to `thisArg` and invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return Math.sin(n);
	     * });
	     * // => [3, 1, 2]
	     *
	     * _.sortBy([1, 2, 3], function(n) {
	     *   return this.sin(n);
	     * }, Math);
	     * // => [3, 1, 2]
	     *
	     * var users = [
	     *   { 'user': 'fred' },
	     *   { 'user': 'pebbles' },
	     *   { 'user': 'barney' }
	     * ];
	     *
	     * // using the `_.property` callback shorthand
	     * _.pluck(_.sortBy(users, 'user'), 'user');
	     * // => ['barney', 'fred', 'pebbles']
	     */
	    function sortBy(collection, iteratee, thisArg) {
	      if (collection == null) {
	        return [];
	      }
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      var index = -1;
	      iteratee = getCallback(iteratee, thisArg, 3);

	      var result = baseMap(collection, function(value, key, collection) {
	        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };
	      });
	      return baseSortBy(result, compareAscending);
	    }

	    /**
	     * This method is like `_.sortBy` except that it can sort by multiple iteratees
	     * or property names.
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees
	     *  The iteratees to sort by, specified as individual values or arrays of values.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
	     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]
	     *
	     * _.map(_.sortByAll(users, 'user', function(chr) {
	     *   return Math.floor(chr.age / 10);
	     * }), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    var sortByAll = restParam(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var guard = iteratees[2];
	      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
	        iteratees.length = 1;
	      }
	      return baseSortByOrder(collection, baseFlatten(iteratees), []);
	    });

	    /**
	     * This method is like `_.sortByAll` except that it allows specifying the
	     * sort orders of the iteratees to sort by. If `orders` is unspecified, all
	     * values are sorted in ascending order. Otherwise, a value is sorted in
	     * ascending order if its corresponding order is "asc", and descending if "desc".
	     *
	     * If a property name is provided for an iteratee the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If an object is provided for an iteratee the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {boolean[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 42 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // sort by `user` in ascending order and by `age` in descending order
	     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);
	     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]
	     */
	    function sortByOrder(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (guard && isIterateeCall(iteratees, orders, guard)) {
	        orders = undefined;
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseSortByOrder(collection, iteratees, orders);
	    }

	    /**
	     * Performs a deep comparison between each element in `collection` and the
	     * source object, returning an array of all elements that have equivalent
	     * property values.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to search.
	     * @param {Object} source The object of property values to match.
	     * @returns {Array} Returns the new filtered array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
	     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
	     * ];
	     *
	     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
	     * // => ['barney']
	     *
	     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
	     * // => ['fred']
	     */
	    function where(collection, source) {
	      return filter(collection, baseMatches(source));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the number of milliseconds that have elapsed since the Unix epoch
	     * (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @category Date
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => logs the number of milliseconds it took for the deferred function to be invoked
	     */
	    var now = nativeNow || function() {
	      return new Date().getTime();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it is called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => logs 'done saving!' after the two async saves have completed
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      n = nativeIsFinite(n = +n) ? n : 0;
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that accepts up to `n` arguments ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      if (guard && isIterateeCall(func, n, guard)) {
	        n = undefined;
	      }
	      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
	      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it is called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery('#add').on('click', _.before(5, addContactToList));
	     * // => allows adding up to 4 contacts to the list
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        if (typeof n == 'function') {
	          var temp = n;
	          n = func;
	          func = temp;
	        } else {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	      }
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and prepends any additional `_.bind` arguments to those provided to the
	     * bound function.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind` this method does not set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var greet = function(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * };
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // using placeholders
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = restParam(function(func, thisArg, partials) {
	      var bitmask = BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bind.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method. Method names may be specified as individual arguments or as arrays
	     * of method names. If no method names are provided all enumerable function
	     * properties, own and inherited, of `object` are bound.
	     *
	     * **Note:** This method does not set the "length" property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} [methodNames] The object method names to bind,
	     *  specified as individual method names or arrays of method names.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'onClick': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view);
	     * jQuery('#docs').on('click', view.onClick);
	     * // => logs 'clicked docs' when the element is clicked
	     */
	    var bindAll = restParam(function(object, methodNames) {
	      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

	      var index = -1,
	          length = methodNames.length;

	      while (++index < length) {
	        var key = methodNames[index];
	        object[key] = createWrapper(object[key], BIND_FLAG, object);
	      }
	      return object;
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` and prepends
	     * any additional `_.bindKey` arguments to those provided to the bound function.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist.
	     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Object} object The object the method belongs to.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // using placeholders
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = restParam(function(object, key, partials) {
	      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, bindKey.placeholder);
	        bitmask |= PARTIAL_FLAG;
	      }
	      return createWrapper(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts one or more arguments of `func` that when
	     * called either invokes `func` returning its result, if all `func` arguments
	     * have been provided, or returns a function that accepts one or more of the
	     * remaining `func` arguments, and so on. The arity of `func` may be specified
	     * if `func.length` is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    var curry = createCurry(CURRY_FLAG);

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method does not set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // using placeholders
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    var curryRight = createCurry(CURRY_RIGHT_FLAG);

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed invocations. Provide an options object to indicate that `func`
	     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
	     * Subsequent calls to the debounced function return the result of the last
	     * `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the debounced function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=false] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
	     *  delayed before it is invoked.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // avoid costly calculations while the window size is in flux
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
	     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // ensure `batchLog` is invoked once after 1 second of debounced calls
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', _.debounce(batchLog, 250, {
	     *   'maxWait': 1000
	     * }));
	     *
	     * // cancel a debounced call
	     * var todoChanges = _.debounce(batchLog, 1000);
	     * Object.observe(models.todo, todoChanges);
	     *
	     * Object.observe(models, function(changes) {
	     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
	     *     todoChanges.cancel();
	     *   }
	     * }, ['delete']);
	     *
	     * // ...at some point `models.todo` is changed
	     * models.todo.completed = true;
	     *
	     * // ...before 1 second has passed `models.todo` is deleted
	     * // which cancels the debounced `todoChanges` call
	     * delete models.todo;
	     */
	    function debounce(func, wait, options) {
	      var args,
	          maxTimeoutId,
	          result,
	          stamp,
	          thisArg,
	          timeoutId,
	          trailingCall,
	          lastCalled = 0,
	          maxWait = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = wait < 0 ? 0 : (+wait || 0);
	      if (options === true) {
	        var leading = true;
	        trailing = false;
	      } else if (isObject(options)) {
	        leading = !!options.leading;
	        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function cancel() {
	        if (timeoutId) {
	          clearTimeout(timeoutId);
	        }
	        if (maxTimeoutId) {
	          clearTimeout(maxTimeoutId);
	        }
	        lastCalled = 0;
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	      }

	      function complete(isCalled, id) {
	        if (id) {
	          clearTimeout(id);
	        }
	        maxTimeoutId = timeoutId = trailingCall = undefined;
	        if (isCalled) {
	          lastCalled = now();
	          result = func.apply(thisArg, args);
	          if (!timeoutId && !maxTimeoutId) {
	            args = thisArg = undefined;
	          }
	        }
	      }

	      function delayed() {
	        var remaining = wait - (now() - stamp);
	        if (remaining <= 0 || remaining > wait) {
	          complete(trailingCall, maxTimeoutId);
	        } else {
	          timeoutId = setTimeout(delayed, remaining);
	        }
	      }

	      function maxDelayed() {
	        complete(trailing, timeoutId);
	      }

	      function debounced() {
	        args = arguments;
	        stamp = now();
	        thisArg = this;
	        trailingCall = trailing && (timeoutId || !leading);

	        if (maxWait === false) {
	          var leadingCall = leading && !timeoutId;
	        } else {
	          if (!maxTimeoutId && !leading) {
	            lastCalled = stamp;
	          }
	          var remaining = maxWait - (stamp - lastCalled),
	              isCalled = remaining <= 0 || remaining > maxWait;

	          if (isCalled) {
	            if (maxTimeoutId) {
	              maxTimeoutId = clearTimeout(maxTimeoutId);
	            }
	            lastCalled = stamp;
	            result = func.apply(thisArg, args);
	          }
	          else if (!maxTimeoutId) {
	            maxTimeoutId = setTimeout(maxDelayed, remaining);
	          }
	        }
	        if (isCalled && timeoutId) {
	          timeoutId = clearTimeout(timeoutId);
	        }
	        else if (!timeoutId && wait !== maxWait) {
	          timeoutId = setTimeout(delayed, wait);
	        }
	        if (leadingCall) {
	          isCalled = true;
	          result = func.apply(thisArg, args);
	        }
	        if (isCalled && !timeoutId && !maxTimeoutId) {
	          args = thisArg = undefined;
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // logs 'deferred' after one or more milliseconds
	     */
	    var defer = restParam(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke the function with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => logs 'later' after one second
	     */
	    var delay = restParam(function(func, wait, args) {
	      return baseDelay(func, wait, args);
	    });

	    /**
	     * Creates a function that returns the result of invoking the provided
	     * functions with the `this` binding of the created function, where each
	     * successive invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow(_.add, square);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the provided functions from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @alias backflow, compose
	     * @category Function
	     * @param {...Function} [funcs] Functions to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight(square, _.add);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is coerced to a string and used as the
	     * cache key. The `func` is invoked with the `this` binding of the memoized
	     * function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoizing function.
	     * @example
	     *
	     * var upperCase = _.memoize(function(string) {
	     *   return string.toUpperCase();
	     * });
	     *
	     * upperCase('fred');
	     * // => 'FRED'
	     *
	     * // modifying the result cache
	     * upperCase.cache.set('fred', 'BARNEY');
	     * upperCase('fred');
	     * // => 'BARNEY'
	     *
	     * // replacing `_.memoize.Cache`
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'barney' };
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'fred' }
	     *
	     * _.memoize.Cache = WeakMap;
	     * var identity = _.memoize(_.identity);
	     *
	     * identity(object);
	     * // => { 'user': 'fred' }
	     * identity(other);
	     * // => { 'user': 'barney' }
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result);
	        return result;
	      };
	      memoized.cache = new memoize.Cache;
	      return memoized;
	    }

	    /**
	     * Creates a function that runs each argument through a corresponding
	     * transform function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms] The functions to transform
	     * arguments, specified as individual functions or arrays of functions.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var modded = _.modArgs(function(x, y) {
	     *   return [x, y];
	     * }, square, doubled);
	     *
	     * modded(1, 2);
	     * // => [1, 4]
	     *
	     * modded(5, 10);
	     * // => [25, 20]
	     */
	    var modArgs = restParam(function(func, transforms) {
	      transforms = baseFlatten(transforms);
	      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = transforms.length;
	      return restParam(function(args) {
	        var index = nativeMin(args.length, length);
	        while (index--) {
	          args[index] = transforms[index](args[index]);
	        }
	        return func.apply(this, args);
	      });
	    });

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        return !predicate.apply(this, arguments);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first call. The `func` is invoked
	     * with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // `initialize` invokes `createApplication` once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with `partial` arguments prepended
	     * to those provided to the new function. This method is like `_.bind` except
	     * it does **not** alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // using placeholders
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = createPartial(PARTIAL_FLAG);

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to those provided to the new function.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method does not set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * var greet = function(greeting, name) {
	     *   return greeting + ' ' + name;
	     * };
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // using placeholders
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified indexes where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes,
	     *  specified as individual indexes or arrays of indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, 2, 0, 1);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     *
	     * var map = _.rearg(_.map, [1, 0]);
	     * map(function(n) {
	     *   return n * 3;
	     * }, [1, 2, 3]);
	     * // => [3, 6, 9]
	     */
	    var rearg = restParam(function(func, indexes) {
	      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as an array.
	     *
	     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.restParam(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function restParam(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            rest = Array(length);

	        while (++index < length) {
	          rest[index] = args[start + index];
	        }
	        switch (start) {
	          case 0: return func.call(this, rest);
	          case 1: return func.call(this, args[0], rest);
	          case 2: return func.call(this, args[0], args[1], rest);
	        }
	        var otherArgs = Array(start + 1);
	        index = -1;
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = rest;
	        return func.apply(this, otherArgs);
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the created
	     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).
	     *
	     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * // with a Promise
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function(array) {
	        return func.apply(this, array);
	      };
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed invocations. Provide an options object to indicate
	     * that `func` should be invoked on the leading and/or trailing edge of the
	     * `wait` timeout. Subsequent calls to the throttled function return the
	     * result of the last `func` call.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
	     * on the trailing edge of the timeout only if the the throttled function is
	     * invoked more than once during the `wait` timeout.
	     *
	     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.leading=true] Specify invoking on the leading
	     *  edge of the timeout.
	     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
	     *  edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // avoid excessively updating the position while scrolling
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
	     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
	     *   'trailing': false
	     * }));
	     *
	     * // cancel a trailing throttled call
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (options === false) {
	        leading = false;
	      } else if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });
	    }

	    /**
	     * Creates a function that provides `value` to the wrapper function as its
	     * first argument. Any additional arguments provided to the function are
	     * appended to those provided to the wrapper function. The wrapper is invoked
	     * with the `this` binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} wrapper The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      wrapper = wrapper == null ? identity : wrapper;
	      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
	     * otherwise they are assigned by reference. If `customizer` is provided it is
	     * invoked to produce the cloned values. If `customizer` returns `undefined`
	     * cloning is handled by the method instead. The `customizer` is bound to
	     * `thisArg` and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var shallow = _.clone(users);
	     * shallow[0] === users[0];
	     * // => true
	     *
	     * var deep = _.clone(users, true);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.clone(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 0
	     */
	    function clone(value, isDeep, customizer, thisArg) {
	      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
	        isDeep = false;
	      }
	      else if (typeof isDeep == 'function') {
	        thisArg = customizer;
	        customizer = isDeep;
	        isDeep = false;
	      }
	      return typeof customizer == 'function'
	        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))
	        : baseClone(value, isDeep);
	    }

	    /**
	     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
	     * to produce the cloned values. If `customizer` returns `undefined` cloning
	     * is handled by the method instead. The `customizer` is bound to `thisArg`
	     * and invoked with two argument; (value [, index|key, object]).
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).
	     * The enumerable properties of `arguments` objects and objects created by
	     * constructors other than `Object` are cloned to plain `Object` objects. An
	     * empty object is returned for uncloneable values such as functions, DOM nodes,
	     * Maps, Sets, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to deep clone.
	     * @param {Function} [customizer] The function to customize cloning values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {*} Returns the deep cloned value.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * var deep = _.cloneDeep(users);
	     * deep[0] === users[0];
	     * // => false
	     *
	     * // using a customizer callback
	     * var el = _.cloneDeep(document.body, function(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * });
	     *
	     * el === document.body
	     * // => false
	     * el.nodeName
	     * // => BODY
	     * el.childNodes.length;
	     * // => 20
	     */
	    function cloneDeep(value, customizer, thisArg) {
	      return typeof customizer == 'function'
	        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))
	        : baseClone(value, true);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    function gt(value, other) {
	      return value > other;
	    }

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    function gte(value, other) {
	      return value >= other;
	    }

	    /**
	     * Checks if `value` is classified as an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    function isArguments(value) {
	      return isObjectLike(value) && isArrayLike(value) &&
	        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	    }

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(function() { return arguments; }());
	     * // => false
	     */
	    var isArray = nativeIsArray || function(value) {
	      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	    };

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    function isDate(value) {
	      return isObjectLike(value) && objToString.call(value) == dateTag;
	    }

	    /**
	     * Checks if `value` is a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is empty. A value is considered empty unless it is an
	     * `arguments` object, array, string, or jQuery-like collection with a length
	     * greater than `0` or an object with own enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Array|Object|string} value The value to inspect.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
	          (isObjectLike(value) && isFunction(value.splice)))) {
	        return !value.length;
	      }
	      return !keys(value).length;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent. If `customizer` is provided it is invoked to compare values.
	     * If `customizer` returns `undefined` comparisons are handled by the method
	     * instead. The `customizer` is bound to `thisArg` and invoked with three
	     * arguments: (value, other [, index|key]).
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. Functions and DOM nodes
	     * are **not** supported. Provide a customizer function to extend support
	     * for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @alias eq
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var other = { 'user': 'fred' };
	     *
	     * object == other;
	     * // => false
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * // using a customizer callback
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqual(array, other, function(value, other) {
	     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
	     *     return true;
	     *   }
	     * });
	     * // => true
	     */
	    function isEqual(value, other, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(10);
	     * // => true
	     *
	     * _.isFinite('10');
	     * // => false
	     *
	     * _.isFinite(true);
	     * // => false
	     *
	     * _.isFinite(Object(10));
	     * // => false
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in older versions of Chrome and Safari which return 'function' for regexes
	      // and Safari 8 equivalents which return 'object' for typed array constructors.
	      return isObject(value) && objToString.call(value) == funcTag;
	    }

	    /**
	     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(1);
	     * // => false
	     */
	    function isObject(value) {
	      // Avoid a V8 JIT bug in Chrome 19-20.
	      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	      var type = typeof value;
	      return !!value && (type == 'object' || type == 'function');
	    }

	    /**
	     * Performs a deep comparison between `object` and `source` to determine if
	     * `object` contains equivalent property values. If `customizer` is provided
	     * it is invoked to compare values. If `customizer` returns `undefined`
	     * comparisons are handled by the method instead. The `customizer` is bound
	     * to `thisArg` and invoked with three arguments: (value, other, index|key).
	     *
	     * **Note:** This method supports comparing properties of arrays, booleans,
	     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
	     * and DOM nodes are **not** supported. Provide a customizer function to extend
	     * support for comparing other values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize value comparisons.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.isMatch(object, { 'age': 40 });
	     * // => true
	     *
	     * _.isMatch(object, { 'age': 36 });
	     * // => false
	     *
	     * // using a customizer callback
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatch(object, source, function(value, other) {
	     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
	     * });
	     * // => true
	     */
	    function isMatch(object, source, customizer, thisArg) {
	      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;
	      return baseIsMatch(object, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)
	     * which returns `true` for `undefined` and other non-numeric values.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a native function.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (value == null) {
	        return false;
	      }
	      if (isFunction(value)) {
	        return reIsNative.test(fnToString.call(value));
	      }
	      return isObjectLike(value) && reIsHostCtor.test(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	     * as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isNumber(8.4);
	     * // => true
	     *
	     * _.isNumber(NaN);
	     * // => true
	     *
	     * _.isNumber('8.4');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * **Note:** This method assumes objects created by the `Object` constructor
	     * have no inherited enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      var Ctor;

	      // Exit early for non `Object` objects.
	      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||
	          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
	        return false;
	      }
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      var result;
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      baseForIn(value, function(subValue, key) {
	        result = key;
	      });
	      return result === undefined || hasOwnProperty.call(value, result);
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    function isRegExp(value) {
	      return isObject(value) && objToString.call(value) == regexpTag;
	    }

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    function isTypedArray(value) {
	      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
	    }

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    function lt(value, other) {
	      return value < other;
	    }

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    function lte(value, other) {
	      return value <= other;
	    }

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * (function() {
	     *   return _.toArray(arguments).slice(1);
	     * }(1, 2, 3));
	     * // => [2, 3]
	     */
	    function toArray(value) {
	      var length = value ? getLength(value) : 0;
	      if (!isLength(length)) {
	        return values(value);
	      }
	      if (!length) {
	        return [];
	      }
	      return arrayCopy(value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable
	     * properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return baseCopy(value, keysIn(value));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Recursively merges own enumerable properties of the source object(s), that
	     * don't resolve to `undefined` into the destination object. Subsequent sources
	     * overwrite property assignments of previous sources. If `customizer` is
	     * provided it is invoked to produce the merged values of the destination and
	     * source properties. If `customizer` returns `undefined` merging is handled
	     * by the method instead. The `customizer` is bound to `thisArg` and invoked
	     * with five arguments: (objectValue, sourceValue, key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var users = {
	     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
	     * };
	     *
	     * var ages = {
	     *   'data': [{ 'age': 36 }, { 'age': 40 }]
	     * };
	     *
	     * _.merge(users, ages);
	     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
	     *
	     * // using a customizer callback
	     * var object = {
	     *   'fruits': ['apple'],
	     *   'vegetables': ['beet']
	     * };
	     *
	     * var other = {
	     *   'fruits': ['banana'],
	     *   'vegetables': ['carrot']
	     * };
	     *
	     * _.merge(object, other, function(a, b) {
	     *   if (_.isArray(a)) {
	     *     return a.concat(b);
	     *   }
	     * });
	     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
	     */
	    var merge = createAssigner(baseMerge);

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources overwrite property assignments of previous sources.
	     * If `customizer` is provided it is invoked to produce the assigned values.
	     * The `customizer` is bound to `thisArg` and invoked with five arguments:
	     * (objectValue, sourceValue, key, object, source).
	     *
	     * **Note:** This method mutates `object` and is based on
	     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
	     *
	     * @static
	     * @memberOf _
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {*} [thisArg] The `this` binding of `customizer`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using a customizer callback
	     * var defaults = _.partialRight(_.assign, function(value, other) {
	     *   return _.isUndefined(value) ? other : value;
	     * });
	     *
	     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var assign = createAssigner(function(object, source, customizer) {
	      return customizer
	        ? assignWith(object, source, customizer)
	        : baseAssign(object, source);
	    });

	    /**
	     * Creates an object that inherits from the given `prototype` object. If a
	     * `properties` object is provided its own enumerable properties are assigned
	     * to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties, guard) {
	      var result = baseCreate(prototype);
	      if (guard && isIterateeCall(prototype, properties, guard)) {
	        properties = undefined;
	      }
	      return properties ? baseAssign(result, properties) : result;
	    }

	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to `undefined`. Once a
	     * property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var defaults = createDefaults(assign, assignDefaults);

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });
	     * // => { 'user': { 'name': 'barney', 'age': 36 } }
	     *
	     */
	    var defaultsDeep = createDefaults(merge, mergeDefaults);

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    var findKey = createFindKey(baseForOwn);

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * If a property name is provided for `predicate` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `predicate` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to search.
	     * @param {Function|Object|string} [predicate=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(chr) {
	     *   return chr.age < 40;
	     * });
	     * // => returns `pebbles` assuming `_.findKey` returns `barney`
	     *
	     * // using the `_.matches` callback shorthand
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // using the `_.matchesProperty` callback shorthand
	     * _.findLastKey(users, 'active', false);
	     * // => 'fred'
	     *
	     * // using the `_.property` callback shorthand
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    var findLastKey = createFindKey(baseForOwnRight);

	    /**
	     * Iterates over own and inherited enumerable properties of an object invoking
	     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
	     */
	    var forIn = createForIn(baseFor);

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
	     */
	    var forInRight = createForIn(baseForRight);

	    /**
	     * Iterates over own enumerable properties of an object invoking `iteratee`
	     * for each property. The `iteratee` is bound to `thisArg` and invoked with
	     * three arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'a' and 'b' (iteration order is not guaranteed)
	     */
	    var forOwn = createForOwn(baseForOwn);

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
	     */
	    var forOwnRight = createForOwn(baseForOwnRight);

	    /**
	     * Creates an array of function property names from all enumerable properties,
	     * own and inherited, of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @alias methods
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the new array of property names.
	     * @example
	     *
	     * _.functions(_);
	     * // => ['after', 'ary', 'assign', ...]
	     */
	    function functions(object) {
	      return baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the property value at `path` of `object`. If the resolved value is
	     * `undefined` the `defaultValue` is used in its place.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
	      return result === undefined ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': { 'c': 3 } } };
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b.c');
	     * // => true
	     *
	     * _.has(object, ['a', 'b', 'c']);
	     * // => true
	     */
	    function has(object, path) {
	      if (object == null) {
	        return false;
	      }
	      var result = hasOwnProperty.call(object, path);
	      if (!result && !isKey(path)) {
	        path = toPath(path);
	        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	        if (object == null) {
	          return false;
	        }
	        path = last(path);
	        result = hasOwnProperty.call(object, path);
	      }
	      return result || (isLength(object.length) && isIndex(path, object.length) &&
	        (isArray(object) || isArguments(object)));
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite property
	     * assignments of previous values unless `multiValue` is `true`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {boolean} [multiValue] Allow multiple values per key.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     *
	     * // with `multiValue`
	     * _.invert(object, true);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function invert(object, multiValue, guard) {
	      if (guard && isIterateeCall(object, multiValue, guard)) {
	        multiValue = undefined;
	      }
	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = {};

	      while (++index < length) {
	        var key = props[index],
	            value = object[key];

	        if (multiValue) {
	          if (hasOwnProperty.call(result, value)) {
	            result[value].push(key);
	          } else {
	            result[value] = [key];
	          }
	        }
	        else {
	          result[value] = key;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    var keys = !nativeKeys ? shimKeys : function(object) {
	      var Ctor = object == null ? undefined : object.constructor;
	      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	          (typeof object != 'function' && isArrayLike(object))) {
	        return shimKeys(object);
	      }
	      return isObject(object) ? nativeKeys(object) : [];
	    };

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      if (object == null) {
	        return [];
	      }
	      if (!isObject(object)) {
	        object = Object(object);
	      }
	      var length = object.length;
	      length = (length && isLength(length) &&
	        (isArray(object) || isArguments(object)) && length) || 0;

	      var Ctor = object.constructor,
	          index = -1,
	          isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	          result = Array(length),
	          skipIndexes = length > 0;

	      while (++index < length) {
	        result[index] = (index + '');
	      }
	      for (var key in object) {
	        if (!(skipIndexes && isIndex(key, length)) &&
	            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * property of `object` through `iteratee`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    var mapKeys = createObjectMapper(true);

	    /**
	     * Creates an object with the same keys as `object` and values generated by
	     * running each own enumerable property of `object` through `iteratee`. The
	     * iteratee function is bound to `thisArg` and invoked with three arguments:
	     * (value, key, object).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
	     *  per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Object} Returns the new mapped object.
	     * @example
	     *
	     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
	     *   return n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * // using the `_.property` callback shorthand
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    var mapValues = createObjectMapper();

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable properties of `object` that are not omitted.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to omit, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.omit(object, 'age');
	     * // => { 'user': 'fred' }
	     *
	     * _.omit(object, _.isNumber);
	     * // => { 'user': 'fred' }
	     */
	    var omit = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      if (typeof props[0] != 'function') {
	        var props = arrayMap(baseFlatten(props), String);
	        return pickByArray(object, baseDifference(keysIn(object), props));
	      }
	      var predicate = bindCallback(props[0], props[1], 3);
	      return pickByCallback(object, function(value, key, object) {
	        return !predicate(value, key, object);
	      });
	    });

	    /**
	     * Creates a two dimensional array of the key-value pairs for `object`,
	     * e.g. `[[key1, value1], [key2, value2]]`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the new array of key-value pairs.
	     * @example
	     *
	     * _.pairs({ 'barney': 36, 'fred': 40 });
	     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	     */
	    function pairs(object) {
	      object = toObject(object);

	      var index = -1,
	          props = keys(object),
	          length = props.length,
	          result = Array(length);

	      while (++index < length) {
	        var key = props[index];
	        result[index] = [key, object[key]];
	      }
	      return result;
	    }

	    /**
	     * Creates an object composed of the picked `object` properties. Property
	     * names may be specified as individual arguments or as arrays of property
	     * names. If `predicate` is provided it is invoked for each property of `object`
	     * picking the properties `predicate` returns truthy for. The predicate is
	     * bound to `thisArg` and invoked with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function|...(string|string[])} [predicate] The function invoked per
	     *  iteration or property names to pick, specified as individual property
	     *  names or arrays of property names.
	     * @param {*} [thisArg] The `this` binding of `predicate`.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'user': 'fred', 'age': 40 };
	     *
	     * _.pick(object, 'user');
	     * // => { 'user': 'fred' }
	     *
	     * _.pick(object, _.isString);
	     * // => { 'user': 'fred' }
	     */
	    var pick = restParam(function(object, props) {
	      if (object == null) {
	        return {};
	      }
	      return typeof props[0] == 'function'
	        ? pickByCallback(object, bindCallback(props[0], props[1], 3))
	        : pickByArray(object, baseFlatten(props));
	    });

	    /**
	     * This method is like `_.get` except that if the resolved value is a function
	     * it is invoked with the `this` binding of its parent object and its result
	     * is returned.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a.b.c', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a.b.c', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      var result = object == null ? undefined : object[path];
	      if (result === undefined) {
	        if (object != null && !isKey(path, object)) {
	          path = toPath(path);
	          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	          result = object == null ? undefined : object[last(path)];
	        }
	        result = result === undefined ? defaultValue : result;
	      }
	      return isFunction(result) ? result.call(object) : result;
	    }

	    /**
	     * Sets the property value of `path` on `object`. If a portion of `path`
	     * does not exist it is created.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to augment.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, 'x[0].y.z', 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      if (object == null) {
	        return object;
	      }
	      var pathKey = (path + '');
	      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = path[index];
	        if (isObject(nested)) {
	          if (index == lastIndex) {
	            nested[key] = value;
	          } else if (nested[key] == null) {
	            nested[key] = isIndex(path[index + 1]) ? [] : {};
	          }
	        }
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own enumerable
	     * properties through `iteratee`, with each invocation potentially mutating
	     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
	     * with four arguments: (accumulator, value, key, object). Iteratee functions
	     * may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Array|Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * });
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
	     *   result[key] = n * 3;
	     * });
	     * // => { 'a': 3, 'b': 6 }
	     */
	    function transform(object, iteratee, accumulator, thisArg) {
	      var isArr = isArray(object) || isTypedArray(object);
	      iteratee = getCallback(iteratee, thisArg, 4);

	      if (accumulator == null) {
	        if (isArr || isObject(object)) {
	          var Ctor = object.constructor;
	          if (isArr) {
	            accumulator = isArray(object) ? new Ctor : [];
	          } else {
	            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);
	          }
	        } else {
	          accumulator = {};
	        }
	      }
	      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Creates an array of the own enumerable property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property values
	     * of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Checks if `n` is between `start` and up to but not including, `end`. If
	     * `end` is not specified it is set to `start` with `start` then set to `0`.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} n The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     */
	    function inRange(value, start, end) {
	      start = +start || 0;
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      return value >= nativeMin(start, end) && value < nativeMax(start, end);
	    }

	    /**
	     * Produces a random number between `min` and `max` (inclusive). If only one
	     * argument is provided a number between `0` and the given number is returned.
	     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
	     * number is returned instead of an integer.
	     *
	     * @static
	     * @memberOf _
	     * @category Number
	     * @param {number} [min=0] The minimum possible value.
	     * @param {number} [max=1] The maximum possible value.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(min, max, floating) {
	      if (floating && isIterateeCall(min, max, floating)) {
	        max = floating = undefined;
	      }
	      var noMin = min == null,
	          noMax = max == null;

	      if (floating == null) {
	        if (noMax && typeof min == 'boolean') {
	          floating = min;
	          min = 1;
	        }
	        else if (typeof max == 'boolean') {
	          floating = max;
	          noMax = true;
	        }
	      }
	      if (noMin && noMax) {
	        max = 1;
	        noMax = false;
	      }
	      min = +min || 0;
	      if (noMax) {
	        max = min;
	        min = 0;
	      } else {
	        max = +max || 0;
	      }
	      if (floating || min % 1 || max % 1) {
	        var rand = nativeRandom();
	        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
	      }
	      return baseRandom(min, max);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__foo_bar__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
	    });

	    /**
	     * Capitalizes the first character of `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('fred');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      string = baseToString(string);
	      return string && (string.charAt(0).toUpperCase() + string.slice(1));
	    }

	    /**
	     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = baseToString(string);
	      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search from.
	     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = baseToString(string);
	      target = (target + '');

	      var length = string.length;
	      position = position === undefined
	        ? length
	        : nativeMin(position < 0 ? 0 : (+position || 0), length);

	      position -= target.length;
	      return position >= 0 && string.indexOf(target, position) == position;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', "'", and "\`", in `string` to
	     * their corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional characters
	     * use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value.
	     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * Backticks are escaped because in Internet Explorer < 9, they can break out
	     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
	     * for more details.
	     *
	     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
	     * to reduce XSS vectors.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
	      string = baseToString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "\", "/", "^", "$", ".", "|", "?",
	     * "*", "+", "(", ")", "[", "]", "{" and "}" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https:\/\/lodash\.com\/\)'
	     */
	    function escapeRegExp(string) {
	      string = baseToString(string);
	      return (string && reHasRegExpChars.test(string))
	        ? string.replace(reRegExpChars, escapeRegExpChar)
	        : (string || '(?:)');
	    }

	    /**
	     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__foo_bar__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = baseToString(string);
	      length = +length;

	      var strLength = string.length;
	      if (strLength >= length || !nativeIsFinite(length)) {
	        return string;
	      }
	      var mid = (length - strLength) / 2,
	          leftLength = nativeFloor(mid),
	          rightLength = nativeCeil(mid);

	      chars = createPadding('', rightLength, chars);
	      return chars.slice(0, leftLength) + string + chars;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padLeft('abc', 6);
	     * // => '   abc'
	     *
	     * _.padLeft('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padLeft('abc', 3);
	     * // => 'abc'
	     */
	    var padLeft = createPadDir();

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padRight('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padRight('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padRight('abc', 3);
	     * // => 'abc'
	     */
	    var padRight = createPadDir(true);

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
	     * in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)
	     * of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
	      // Chrome fails to trim leading <BOM> whitespace characters.
	      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
	      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      string = trim(string);
	      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=0] The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n) {
	      var result = '';
	      string = baseToString(string);
	      n = +n;
	      if (n < 1 || !string || !nativeIsFinite(n)) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        string += string;
	      } while (n);

	      return result;
	    }

	    /**
	     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--foo-bar');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__foo_bar__');
	     * // => 'Foo Bar'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to search.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = baseToString(string);
	      position = position == null
	        ? 0
	        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);

	      return string.lastIndexOf(target, position) == position;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is provided it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options] The options object.
	     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	     * @param {Object} [options.imports] An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
	     * @param {string} [options.variable] The data object variable name.
	     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // using the "interpolate" delimiter to create a compiled template
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // using the HTML "escape" delimiter to escape data property values
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the internal `print` function in "evaluate" delimiters
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // using custom template delimiters
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // using backslashes to treat delimiters as plain text
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // using the `imports` option to import `jQuery` as `jq`
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // using the `sourceURL` option to specify a custom sourceURL for the template
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	     *
	     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // using the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and a stack trace
	     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, otherOptions) {
	      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
	        options = otherOptions = undefined;
	      }
	      string = baseToString(string);
	      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

	      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products requires returning the `match`
	        // string in order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
	      }
	      chars = (chars + '');
	      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimLeft('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimLeft('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimLeft(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(trimmedLeftIndex(string));
	      }
	      return string.slice(charsLeftIndex(string, (chars + '')));
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimRight('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimRight('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimRight(string, chars, guard) {
	      var value = string;
	      string = baseToString(string);
	      if (!string) {
	        return string;
	      }
	      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
	        return string.slice(0, trimmedRightIndex(string) + 1);
	      }
	      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object|number} [options] The options object or maximum string length.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.trunc('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', 24);
	     * // => 'hi-diddly-ho there, n...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.trunc('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function trunc(string, options, guard) {
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (options != null) {
	        if (isObject(options)) {
	          var separator = 'separator' in options ? options.separator : separator;
	          length = 'length' in options ? (+options.length || 0) : length;
	          omission = 'omission' in options ? baseToString(options.omission) : omission;
	        } else {
	          length = +options || 0;
	        }
	      }
	      string = baseToString(string);
	      if (length >= string.length) {
	        return string;
	      }
	      var end = length - omission.length;
	      if (end < 1) {
	        return omission;
	      }
	      var result = string.slice(0, end);
	      if (separator == null) {
	        return result + omission;
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              newEnd,
	              substring = string.slice(0, end);

	          if (!separator.global) {
	            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            newEnd = match.index;
	          }
	          result = result.slice(0, newEnd == null ? end : newEnd);
	        }
	      } else if (string.indexOf(separator, end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
	     * corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
	     * entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = baseToString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      if (guard && isIterateeCall(string, pattern, guard)) {
	        pattern = undefined;
	      }
	      string = baseToString(string);
	      return string.match(pattern || reWords) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it is invoked.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function} func The function to attempt.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // avoid throwing errors for invalid selectors
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = restParam(function(func, args) {
	      try {
	        return func.apply(undefined, args);
	      } catch(e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and arguments of the created function. If `func` is a property name the
	     * created callback returns the property value for a given element. If `func`
	     * is an object the created callback returns `true` for elements that contain
	     * the equivalent object properties, otherwise it returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @alias iteratee
	     * @category Utility
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // wrap to create custom callback shorthands
	     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
	     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
	     *   if (!match) {
	     *     return callback(func, thisArg);
	     *   }
	     *   return function(object) {
	     *     return match[2] == 'gt'
	     *       ? object[match[1]] > match[3]
	     *       : object[match[1]] < match[3];
	     *   };
	     * });
	     *
	     * _.filter(users, 'age__gt36');
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     */
	    function callback(func, thisArg, guard) {
	      if (guard && isIterateeCall(func, thisArg, guard)) {
	        thisArg = undefined;
	      }
	      return isObjectLike(func)
	        ? matches(func)
	        : baseCallback(func, thisArg);
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     * var getter = _.constant(object);
	     *
	     * getter() === object;
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * This method returns the first argument provided to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.identity(object) === object;
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that performs a deep comparison between a given object
	     * and `source`, returning `true` if the given object has equivalent property
	     * values, else `false`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties. For comparing a single
	     * own or inherited property value see `_.matchesProperty`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
	     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, true));
	    }

	    /**
	     * Creates a function that compares the property value of `path` on a given
	     * object to `value`.
	     *
	     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
	     * numbers, `Object` objects, regexes, and strings. Objects are compared by
	     * their own, not inherited, enumerable properties.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * _.find(users, _.matchesProperty('user', 'fred'));
	     * // => { 'user': 'fred' }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, true));
	    }

	    /**
	     * Creates a function that invokes the method at `path` on a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': _.constant(2) } } },
	     *   { 'a': { 'b': { 'c': _.constant(1) } } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    var method = restParam(function(path, args) {
	      return function(object) {
	        return invokePath(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path on `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = restParam(function(object, args) {
	      return function(path) {
	        return invokePath(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable function properties of a source object to the
	     * destination object. If `object` is a function then methods are added to
	     * its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options] The options object.
	     * @param {boolean} [options.chain=true] Specify whether the functions added
	     *  are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      if (options == null) {
	        var isObj = isObject(source),
	            props = isObj ? keys(source) : undefined,
	            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;

	        if (!(methodNames ? methodNames.length : isObj)) {
	          methodNames = false;
	          options = source;
	          source = object;
	          object = this;
	        }
	      }
	      if (!methodNames) {
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = true,
	          index = -1,
	          isFunc = isFunction(object),
	          length = methodNames.length;

	      if (options === false) {
	        chain = false;
	      } else if (isObject(options) && 'chain' in options) {
	        chain = options.chain;
	      }
	      while (++index < length) {
	        var methodName = methodNames[index],
	            func = source[methodName];

	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = (function(func) {
	            return function() {
	              var chainAll = this.__chain__;
	              if (chain || chainAll) {
	                var result = object(this.__wrapped__),
	                    actions = result.__actions__ = arrayCopy(this.__actions__);

	                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	                result.__chain__ = chainAll;
	                return result;
	              }
	              return func.apply(object, arrayPush([this.value()], arguments));
	            };
	          }(func));
	        }
	      }
	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      root._ = oldDash;
	      return this;
	    }

	    /**
	     * A no-operation function that returns `undefined` regardless of the
	     * arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @example
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * _.noop(object) === undefined;
	     * // => true
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that returns the property value at `path` on a
	     * given object.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': { 'c': 2 } } },
	     *   { 'a': { 'b': { 'c': 1 } } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b.c'));
	     * // => [2, 1]
	     *
	     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the property value at a given path on `object`.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return baseGet(object, toPath(path), path + '');
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. If `end` is not specified it is
	     * set to `start` with `start` then set to `0`. If `end` is less than `start`
	     * a zero-length range is created unless a negative `step` is specified.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the new array of numbers.
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    function range(start, end, step) {
	      if (step && isIterateeCall(start, end, step)) {
	        end = step = undefined;
	      }
	      start = +start || 0;
	      step = step == null ? 1 : (+step || 0);

	      if (end == null) {
	        end = start;
	        start = 0;
	      } else {
	        end = +end || 0;
	      }
	      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
	      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (++index < length) {
	        result[index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * Invokes the iteratee function `n` times, returning an array of the results
	     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
	     * one argument; (index).
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
	     * // => [3, 6, 4]
	     *
	     * _.times(3, function(n) {
	     *   mage.castSpell(n);
	     * });
	     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`
	     *
	     * _.times(3, function(n) {
	     *   this.cast(n);
	     * }, mage);
	     * // => also invokes `mage.castSpell(n)` three times
	     */
	    function times(n, iteratee, thisArg) {
	      n = nativeFloor(n);

	      // Exit early to avoid a JSC JIT bug in Safari 8
	      // where `Array(0)` is treated as `Array(1)`.
	      if (n < 1 || !nativeIsFinite(n)) {
	        return [];
	      }
	      var index = -1,
	          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

	      iteratee = bindCallback(iteratee, thisArg, 1);
	      while (++index < n) {
	        if (index < MAX_ARRAY_LENGTH) {
	          result[index] = iteratee(index);
	        } else {
	          iteratee(index);
	        }
	      }
	      return result;
	    }

	    /**
	     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
	     *
	     * @static
	     * @memberOf _
	     * @category Utility
	     * @param {string} [prefix] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return baseToString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} augend The first number to add.
	     * @param {number} addend The second number to add.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    function add(augend, addend) {
	      return (+augend || 0) + (+addend || 0);
	    }

	    /**
	     * Calculates `n` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Calculates `n` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Gets the maximum value of `collection`. If `collection` is empty or falsey
	     * `-Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => -Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.max(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'fred', 'age': 40 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.max(users, 'age');
	     * // => { 'user': 'fred', 'age': 40 }
	     */
	    var max = createExtremum(gt, NEGATIVE_INFINITY);

	    /**
	     * Gets the minimum value of `collection`. If `collection` is empty or falsey
	     * `Infinity` is returned. If an iteratee function is provided it is invoked
	     * for each value in `collection` to generate the criterion by which the value
	     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
	     * arguments: (value, index, collection).
	     *
	     * If a property name is provided for `iteratee` the created `_.property`
	     * style callback returns the property value of the given element.
	     *
	     * If a value is also provided for `thisArg` the created `_.matchesProperty`
	     * style callback returns `true` for elements that have a matching property
	     * value, else `false`.
	     *
	     * If an object is provided for `iteratee` the created `_.matches` style
	     * callback returns `true` for elements that have the properties of the given
	     * object, else `false`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => Infinity
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * _.min(users, function(chr) {
	     *   return chr.age;
	     * });
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // using the `_.property` callback shorthand
	     * _.min(users, 'age');
	     * // => { 'user': 'barney', 'age': 36 }
	     */
	    var min = createExtremum(lt, POSITIVE_INFINITY);

	    /**
	     * Calculates `n` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {number} n The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Gets the sum of the values in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @category Math
	     * @param {Array|Object|string} collection The collection to iterate over.
	     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
	     * @param {*} [thisArg] The `this` binding of `iteratee`.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 6]);
	     * // => 10
	     *
	     * _.sum({ 'a': 4, 'b': 6 });
	     * // => 10
	     *
	     * var objects = [
	     *   { 'n': 4 },
	     *   { 'n': 6 }
	     * ];
	     *
	     * _.sum(objects, function(object) {
	     *   return object.n;
	     * });
	     * // => 10
	     *
	     * // using the `_.property` callback shorthand
	     * _.sum(objects, 'n');
	     * // => 10
	     */
	    function sum(collection, iteratee, thisArg) {
	      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
	        iteratee = undefined;
	      }
	      iteratee = getCallback(iteratee, thisArg, 3);
	      return iteratee.length == 1
	        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)
	        : baseSum(collection, iteratee);
	    }

	    /*------------------------------------------------------------------------*/

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    // Add functions to the `Map` cache.
	    MapCache.prototype['delete'] = mapDelete;
	    MapCache.prototype.get = mapGet;
	    MapCache.prototype.has = mapHas;
	    MapCache.prototype.set = mapSet;

	    // Add functions to the `Set` cache.
	    SetCache.prototype.push = cachePush;

	    // Assign cache to `_.memoize`.
	    memoize.Cache = MapCache;

	    // Add functions that return wrapped values when chaining.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.callback = callback;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.functions = functions;
	    lodash.groupBy = groupBy;
	    lodash.indexBy = indexBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.invert = invert;
	    lodash.invoke = invoke;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.modArgs = modArgs;
	    lodash.negate = negate;
	    lodash.omit = omit;
	    lodash.once = once;
	    lodash.pairs = pairs;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pluck = pluck;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.restParam = restParam;
	    lodash.set = set;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortByAll = sortByAll;
	    lodash.sortByOrder = sortByOrder;
	    lodash.spread = spread;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.times = times;
	    lodash.toArray = toArray;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.union = union;
	    lodash.uniq = uniq;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.where = where;
	    lodash.without = without;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.backflow = flowRight;
	    lodash.collect = map;
	    lodash.compose = flowRight;
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.extend = assign;
	    lodash.iteratee = callback;
	    lodash.methods = functions;
	    lodash.object = zipObject;
	    lodash.select = filter;
	    lodash.tail = rest;
	    lodash.unique = uniq;

	    // Add functions to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add functions that return unwrapped values when chaining.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.deburr = deburr;
	    lodash.endsWith = endsWith;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.findWhere = findWhere;
	    lodash.first = first;
	    lodash.floor = floor;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isBoolean = isBoolean;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isMatch = isMatch;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isString = isString;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.min = min;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padLeft = padLeft;
	    lodash.padRight = padRight;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.sum = sum;
	    lodash.template = template;
	    lodash.trim = trim;
	    lodash.trimLeft = trimLeft;
	    lodash.trimRight = trimRight;
	    lodash.trunc = trunc;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.words = words;

	    // Add aliases.
	    lodash.all = every;
	    lodash.any = some;
	    lodash.contains = includes;
	    lodash.eq = isEqual;
	    lodash.detect = find;
	    lodash.foldl = reduce;
	    lodash.foldr = reduceRight;
	    lodash.head = first;
	    lodash.include = includes;
	    lodash.inject = reduce;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!lodash.prototype[methodName]) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), false);

	    /*------------------------------------------------------------------------*/

	    // Add functions capable of returning wrapped and unwrapped values when chaining.
	    lodash.sample = sample;

	    lodash.prototype.sample = function(n) {
	      if (!this.__chain__ && n == null) {
	        return sample(this.value());
	      }
	      return this.thru(function(value) {
	        return sample(value, n);
	      });
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type string
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        var filtered = this.__filtered__;
	        if (filtered && !index) {
	          return new LazyWrapper(this);
	        }
	        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);

	        var result = this.clone();
	        if (filtered) {
	          result.__takeCount__ = nativeMin(result.__takeCount__, n);
	        } else {
	          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type != LAZY_MAP_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
	        var result = this.clone();
	        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.first` and `_.last`.
	    arrayEach(['first', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
	    arrayEach(['initial', 'rest'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
	    arrayEach(['pluck', 'where'], function(methodName, index) {
	      var operationName = index ? 'filter' : 'map',
	          createCallback = index ? baseMatches : property;

	      LazyWrapper.prototype[methodName] = function(value) {
	        return this[operationName](createCallback(value));
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.reject = function(predicate, thisArg) {
	      predicate = getCallback(predicate, thisArg, 1);
	      return this.filter(function(value) {
	        return !predicate(value);
	      });
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = start == null ? 0 : (+start || 0);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = (+end || 0);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {
	      return this.reverse().takeWhile(predicate, thisArg).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(POSITIVE_INFINITY);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),
	          retUnwrapped = /^(?:first|last)$/.test(methodName),
	          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var args = retUnwrapped ? [1] : arguments,
	            chainAll = this.__chain__,
	            value = this.__wrapped__,
	            isHybrid = !!this.__actions__.length,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var interceptor = function(value) {
	          return (retUnwrapped && chainAll)
	            ? lodashFunc(value, 1)[0]
	            : lodashFunc.apply(undefined, arrayPush([value], args));
	        };

	        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },
	            onlyLazy = isLazy && !isHybrid;

	        if (retUnwrapped && !chainAll) {
	          if (onlyLazy) {
	            value = value.clone();
	            value.__actions__.push(action);
	            return func.call(value);
	          }
	          return lodashFunc.call(undefined, this.value())[0];
	        }
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push(action);
	          return new LodashWrapper(result, chainAll);
	        }
	        return this.thru(interceptor);
	      };
	    });

	    // Add `Array` and `String` methods to `lodash.prototype`.
	    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {
	      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          return func.apply(this.value(), args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(value, args);
	        });
	      };
	    });

	    // Map minified function names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = lodashFunc.name,
	            names = realNames[key] || (realNames[key] = []);

	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];

	    // Add functions to the lazy wrapper.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chaining functions to the `lodash` wrapper.
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.concat = wrapperConcat;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toString = wrapperToString;
	    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add function aliases to the `lodash` wrapper.
	    lodash.prototype.collect = lodash.prototype.map;
	    lodash.prototype.head = lodash.prototype.first;
	    lodash.prototype.select = lodash.prototype.filter;
	    lodash.prototype.tail = lodash.prototype.rest;

	    return lodash;
	  }

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers like r.js check for condition patterns like the following:
	  if (true) {
	    // Expose lodash to the global object when an AMD loader is present to avoid
	    // errors in cases where lodash is loaded by a script tag and not intended
	    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
	    // more details.
	    root._ = _;

	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
	  else if (freeExports && freeModule) {
	    // Export for Node.js or RingoJS.
	    if (moduleExports) {
	      (freeModule.exports = _)._ = _;
	    }
	    // Export for Rhino with CommonJS support.
	    else {
	      freeExports._ = _;
	    }
	  }
	  else {
	    // Export for a browser or Rhino.
	    root._ = _;
	  }
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)(module), (function() { return this; }())))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var d        = __webpack_require__(9)
	  , callable = __webpack_require__(10)

	  , apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		callable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		callable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		callable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d(on),
		once: d(once),
		off: d(off),
		emit: d(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var assign        = __webpack_require__(13)
	  , normalizeOpts = __webpack_require__(11)
	  , isCallable    = __webpack_require__(12)
	  , contains      = __webpack_require__(14)

	  , d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = function (fn) {
		if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
		return fn;
	};


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	module.exports = function (options/*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (options == null) return;
			process(Object(options), result);
		});
		return result;
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	// Deprecated

	'use strict';

	module.exports = function (obj) { return typeof obj === 'function'; };


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(15)()
		? Object.assign
		: __webpack_require__(16);


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(17)()
		? String.prototype.contains
		: __webpack_require__(18);


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== 'function') return false;
		obj = { foo: 'raz' };
		assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
		return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var keys  = __webpack_require__(20)
	  , value = __webpack_require__(19)

	  , max = Math.max;

	module.exports = function (dest, src/*, …srcn*/) {
		var error, i, l = max(arguments.length, 2), assign;
		dest = Object(value(dest));
		assign = function (key) {
			try { dest[key] = src[key]; } catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < l; ++i) {
			src = arguments[i];
			keys(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var str = 'razdwatrzy';

	module.exports = function () {
		if (typeof str.contains !== 'function') return false;
		return ((str.contains('dwa') === true) && (str.contains('foo') === false));
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var indexOf = String.prototype.indexOf;

	module.exports = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = function (value) {
		if (value == null) throw new TypeError("Cannot use null or undefined");
		return value;
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(21)()
		? Object.keys
		: __webpack_require__(22);


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = function () {
		try {
			Object.keys('primitive');
			return true;
		} catch (e) { return false; }
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var keys = Object.keys;

	module.exports = function (object) {
		return keys(object == null ? object : Object(object));
	};


/***/ }
/******/ ])